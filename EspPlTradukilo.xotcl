# automatically generated from XOTclIDE
# script require component EspTradukilo
@ Component EspPlTradukilo {
description {Specifaj elementoj por pola tradukado}
}
package provide EspPlTradukilo 0.993
package require EspTradukilo
Class ETPlSubstantivoartaMix -superclass ::ETSubstantivoartaMix
@ ::ETPlSubstantivoartaMix idemeta component EspPlTradukilo
ETPlSubstantivoartaMix instproc preparuFunkcion_comp radikaTradukElemento {
    my set kazo N
}
ETPlSubstantivoartaMix instproc preparuFunkcion_nekonata radikaTradukElemento {
    my instvar arto persono
    # nepura programado pro kazo
    # multe de (substantiv) en rolo de subjekto
    # la frazo "multe da viroj estas malgranda"
    # attributo estas en pluralo
    # verbo en singularo
    set pparent [$radikaTradukElemento parenco]
    if {$pparent ne "" && [[$pparent set elemento] prenuFunkcioNomo] eq "pos"} {
        set pparent [$pparent set parenco]
        set pelemento [$pparent set elemento]
        if {[$pelemento istype SintaksAsto::advsup] && [$pelemento eblasKielSubstantivo] && [$pelemento set funkcio] eq "subj"} {
            set taMain [$pparent parenco]
            $taMain set persono $persono
            $taMain set nombro singularo
            $taMain set arto $arto
        }
    }
}
ETPlSubstantivoartaMix instproc preparuFunkcion_obj radikaTradukElemento {
    my instvar kazo
    if {[my cxuNeVerbo]} {
        my set kazo D
    } else {
        my set kazo B
    }
}
ETPlSubstantivoartaMix instproc preparuFunkcion_subj radikaTradukElemento {
    my instvar nombro arto persono kazo elemento

    set taMain [$radikaTradukElemento parenco]
    $taMain set persono $persono
    set tnombro [[$radikaTradukElemento elemento] prenuNombron]
    # problemoj kun "sub1 kaj sub2"
    # substantivoj nur en pluralo
    if {[my exists nombroPluralo]} {
        # ekzemple piec grubych ksiazek jest ciezkich
        $taMain set nombro pluralo
        $taMain set nombroPluralo 1
    } elseif {$tnombro eq "singularo" && $nombro eq "pluralo"} {
        $taMain set nombro $nombro
    } elseif {$tnombro eq $nombro} {
        $taMain set nombro $nombro
    } else {
        set r [$radikaTradukElemento prenuRadiko]
        if {[$r istype ETPlNumeralo]} {
            # du trionoj de homoj laboras
            $taMain set nombro $nombro
        } else {
            # Tulipo kaj rozo estas belaj floroj.
            $taMain set nombro $tnombro
        }
    }
    $taMain set arto $arto
    set kazo M
}
Class ETPlTradukElemento
@ ::ETPlTradukElemento idemeta component EspPlTradukilo
ETPlTradukElemento instproc kazoTrans esperantaKazo {
    # nominativo mianownik
    # akuzativo biernik
    # dativo celownik
    switch $esperantaKazo {
        A -
        akuzativo {
            return B
        }
        N -
        nominativo {
            return M
        }
        default {
            return [string map {N M A B D C} $esperantaKazo]
        }
    }
}
ETPlTradukElemento instproc prenuFleksilon {} {
    PolaFleksio
}
ETPlTradukElemento instproc probuVortfaradon bazaformo {
    PolaVortFarado prenuVortfaradoj2 $bazaformo
}
Class ETPlAdjektivo -superclass {::ETPlTradukElemento ::ETPlSubstantivoartaMix ::ETAdjektivo}
@ ::ETPlAdjektivo idemeta component EspPlTradukilo
ETPlAdjektivo instproc distinguGramatikon frazTraduko {
    my instvar parenco elemento kazo nombro arto
    my distinguPPTransformo $frazTraduko
    next

    if {[$elemento prenuVorton] eq "kelkaj" || [$elemento prenuVorton] eq "kelkajn"} {
        set rad [my miAuxRadikaElemento]
        set par [$rad parenco]
        if {$par ne "" && [[$par elemento] istype SintaksAsto::np]} {
            if {[$par exists kazo] && [lsearch {M B} [$par set kazo]]>=0} {
                $par set kazo D
                $par set persono 3
                $par set arto ni
                set prad [$par prenuRadiko]
                $prad set arto ni
                $prad set nombroPluralo 1
                $prad distinguSubstantivanDifinilon
                $prad metuAttributonEnRadikaFunkcion kazo D
            }
        }
    }
    # Mi vidis ion granda
    # Mi parolis pri io granda
    set tab [my selektu {elemento parenco {filtruVeron hasclass SintaksAsto::np} radiko {filtruVeron hasclass GP::TabloVorto}}]
    if {$tab ne "" && [$tab estasArto o]} {
        if {$kazo in {M B}} {
            set kazo D
        }
    }

    my bazaTraduko [$frazTraduko prenuVortaron]
    if {[$elemento havasMerkmalon substantivaRolo]} {
        my set persono 3
        my distinguSubstantivanDifinilon
    }
}
ETPlAdjektivo instproc distinguKazon {} {
    my instvar kazo parenco
    if {[my prenuFunkcioNomo] eq "attr"} {
        set nombroPluralo [my sxercxuAttributonSupren nombroPluralo]
        if {$nombroPluralo eq "1"} {
            set kazo D
        } else {
            set kazo M
        }
    } else {
        next
    }
}
ETPlAdjektivo instproc kreuKomperativon gparenco {
    my instvar bazaTraduko traduko elemento fgrupo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko [lindex $k 1]
            return 1
        }
    }
    return 0
}
ETPlAdjektivo instproc kreuPliKajPli gparenco {
    my instvar bazaTraduko traduko fgrupo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko "coraz [lindex $k 1]"
            return 1
        }
    }
    set bazaTraduko "coraz bardziej $bazaTraduko"
    return 1
}
ETPlAdjektivo instproc kreuSuperlativon {gparenco i} {
    my instvar bazaTraduko fgrupo
    # testu cxu komperativo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko naj[lindex $k 1]
            return 1
        }
    }
    return 0
}
ETPlAdjektivo instproc traduku vortaro {
    my instvar bazaTraduko kazo nombro traduko arto elemento fgrupo parenco gramatiko
    if {[info exists traduko]} return
    if {![my testuSentradukeco]} {
        next
        set fleksilo [my prenuFleksilon]
        if {[$elemento prenuVorton] eq "kelkaj" || [$elemento prenuVorton] eq "kelkajn"} {
            set traduko [$fleksilo prenuPersonPronomon kelka $arto $kazo $nombro]
        } else {
            if {$bazaTraduko eq "taki samy"} {
                set traduko [join [concat [$fleksilo prenuAdjektivon [lindex $bazaTraduko 0] $arto $kazo $nombro] [$fleksilo prenuAdjektivon [lindex $bazaTraduko 1] $arto $kazo $nombro]]]
            } else {
                if {[lindex $bazaTraduko 0] eq "coraz"} {
                    set traduko [join [concat [lrange $bazaTraduko 0 end-1] [$fleksilo prenuAdjektivon [lindex $bazaTraduko end] $arto $kazo $nombro]]]
                } else {
                    if {[info exists gramatiko] && "gen" in $gramatiko} {
                        set traduko $bazaTraduko
                    } elseif {[info exists gramatiko] && "last" in $gramatiko} {
                        # adjektivo estas la last vorto de traduko
                        set traduko [join [concat [lrange $bazaTraduko 0 end-1] [$fleksilo prenuAdjektivon [lindex $bazaTraduko end] $arto $kazo $nombro]]]
                    } else {
                        set traduko [join [concat [$fleksilo prenuAdjektivon [lindex $bazaTraduko 0] $arto $kazo $nombro] [lrange $bazaTraduko 1 end]]]
                    }
                }
            }
        }
    }
}
Class ETPlAdverbo -superclass {::ETPlTradukElemento ::ETAdverbo}
@ ::ETPlAdverbo idemeta component EspPlTradukilo
ETPlAdverbo instproc kreuKomperativon {} {
    my instvar bazaTraduko fgrupo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko [lindex $k 1]
            return 1
        }
    }
    return 0
}
ETPlAdverbo instproc kreuPliKajPli {} {
    my instvar bazaTraduko traduko fgrupo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko "coraz [lindex $k 1]"
            return 1
        }
    }
    set bazaTraduko "coraz bardziej $bazaTraduko"
    return 1
}
ETPlAdverbo instproc kreuSuperlativon {} {
    my instvar bazaTraduko fgrupo
    foreach k $fgrupo {
        if {[lindex $k 0] eq "komp"} {
            set bazaTraduko naj[lindex $k 1]
            return 1
        }
    }
    return 0
}
ETPlAdverbo instproc traduku vortaro {
    my instvar bazaTraduko traduko arto kazo
    next
    if {[info exists kazo]} {
        # multe da viroj
        set fleksilo [my prenuFleksilon]
        if {$bazaTraduko eq "kilka"} {
            set traduko [$fleksilo prenuPseudoNumeralon kelke $arto $kazo]
        } elseif {$bazaTraduko eq "wiele"} {
            set traduko [$fleksilo prenuPseudoNumeralon multe $arto $kazo]
        }
    }
}
Class ETPlDifinilo -superclass ::ElemTraduko
@ ::ETPlDifinilo idemeta component EspPlTradukilo
ETPlDifinilo instproc distinguGramatikon frazTraduko {
    my instvar parenco elemento kazo nombro arto

    if {[$elemento prenuVorton] eq "la"} {
        return
    }

    set kazo [my sxercxuAttributonSupren kazo]
    if {$kazo eq ""} {
        my metuMesagxon "kazo por adjektivo ne trovita" kazo
        switch [$elemento prenuKazon] {
            nominativo {
                set kazo M
            }
            akuzativo {
                set kazo B
            }
        }
    }
    # por interaktiva tradukado ni devus nuligi fruan rezulton
    set arto ""
    set arto [my sxercxuAttributonSupren arto]
    if {$arto eq ""} {
        my metuMesagxon "arto por difinilo ne trovita" arto
        set arto ms
    }
    set nombro [$parenco sxercxuAttributonSupren nombro]
    if {$nombro eq ""} {
        my metuMesagxon "nombro por difinilo ne trovita" nombro
        set nombro [$elemento prenuNombron]
    }
}
ETPlDifinilo instproc traduku vortaro {
    # pola lingvo ne konas definiloj
    # povas esti ekceptoj???
    my instvar elemento
    if {[$elemento prenuVorton] eq "la"} {
        my set traduko ""
    } elseif {[$elemento prenuVorton] eq "ambaŭ"} {
        my instvar arto kazo nombro
        set dwa [[my prenuFleksilon] prenuNumeroLauKazoArtoGis1000 2 $kazo $arto]
        my set traduko oby$dwa
    } else {
        next
    }
}
Class ETPlInterjekcio -superclass ::ElemTraduko
@ ::ETPlInterjekcio idemeta component EspPlTradukilo
ETPlInterjekcio instproc distinguDifinilon frazTraduko {
    my instvar elemento
    if {[$elemento prenuVorton] eq "ke"} {
        set main [my trovuMainAston]
        if {$main ne ""} {
            set melemento [$main elemento]
            if {[$melemento istype SintaksAsto::main] &&
                [set rad [$melemento prenuRadiko]] ne "" &&
                [$rad estasOrdono]} {
                    $main set keUFrazo 1
                    my set keUFrazo 1
                }
        }
    }
}
ETPlInterjekcio instproc traduku votaro {
    my instvar elemento traduko keUFrazo
    if {[info exists traduko]} {
        return
    }
    switch [$elemento prenuVorton] {
        kaj {
            set traduko i
        }
        ĉu {
            set traduko czy
        }
        ke {
            if {[info exists keUFrazo] && $keUFrazo} {
                set persono [my sxercxuAttributonSupren persono]
                set nombro [my sxercxuAttributonSupren nombro]

                switch $persono {
                    1 {
                        if {$nombro eq "singularo"} {
                            set traduko abym
                        } else {
                            set traduko abyśmy
                        }
                    }
                    2 {
                        if {$nombro eq "singularo"} {
                            set traduko abyś
                        } else {
                            set traduko abyście
                        }
                    }
                    3 {
                        set traduko aby
                    }
                    default {
                        set traduko że
                    }
                }
            } else {
                set traduko że
            }
        }
        se {
            set traduko jeśli
        }
        sed {
            set traduko ale
        }
        ĉar {
            set traduko ponieważ
        }
        dum {
            set traduko gdy
        }
        ĝis {
            set traduko "do kiedy"
        }
        default {
            next
        }
    }
}
Class ETPlKonjunkcio -superclass ::ElemTraduko
@ ::ETPlKonjunkcio idemeta component EspPlTradukilo
ETPlKonjunkcio instproc tradukoPostSinonimoSxangxo {} {
    my set traduko [my set bazaTraduko]
}
ETPlKonjunkcio instproc traduku vortaro {
    my instvar elemento traduko
    if {[info exists traduko]} {
        return
    }
    switch [$elemento prenuVorton] {
        kaj {
            set traduko i
        }
        aŭ {
            set traduko albo
        }
        ol {
            # eblas ankaux 'od' sed tio necesus sxagxoj de kazo
            set traduko aniżeli
        }
        default {
            next
        }
    }
}
Class ETPlKonstanto -superclass {::ETPlTradukElemento ::ElemTraduko}
@ ::ETPlKonstanto idemeta component EspPlTradukilo
ETPlKonstanto instproc distinguDifinilon frazTraduko {
    my instvar arto nombro persono elemento
    if {$elemento ne ""} {
        set s 0
        if {[$elemento estasVirinaNomo]} {
            set arto ze
            set s 1
        } elseif {[$elemento estasViraNomo]} {
            set arto ms
            set s 1
        }
        if {$s} {
            my mixin add ETPlSubstantivoartaMix
            set nombro singularo
            set persono 3
            my distinguSubstantivanDifinilon
            my aliguMerkmalon nomo
        }
     }
}
ETPlKonstanto instproc traduku vortaro {
    my instvar elemento traduko
    if {[my havasMerkmalon nomo]} {
        my instvar kazo bazaTraduko fgrupo
        next
        set fleksilo [my prenuFleksilon]
        if {[my testuSentradukeco]} {
            set v [my prenuBazanFormon]
            set v [string trimright $v o]
            set traduko [$fleksilo prenuSubstantivonLauxTipo $v [$fleksilo divenuTiponDeSubstantivo $v] $kazo singularo]
        } else {
            set traduko [$fleksilo prenuSubstantivonLauxTipo $bazaTraduko $fgrupo $kazo singularo]
        }
        return
    }
    switch -- [$elemento prenuVorton] {
        ktp. {
            set traduko itd.
        }
        ekz. {
            set traduko np.
        }
        p. {
            set traduko s.
        }
        t.n. -
        tn. {
            set traduko tzw.
        }
        ia. -
        ia -
        i.a. {
            set traduko "między innymi"
        }
        vd. {
            set traduko z.
        }
        k.a. {
            set traduko ii.
        }
        inkl. {
           set traduko inkl.
        }
        anst. {
            set traduko zamiast
        }
        tel. {
            set traduko tel.
        }
        j. {
            set traduko r.
        }
        jc. {
            set traduko wiek
        }
        bv. {
            set traduko racz
        }
        ĉ. {
            set traduko ok.
        }
        default {
            set traduko [$elemento prenuVorton]
        }
    }
}
Class ETPlNumeralo -superclass ::ETNumeralo
@ ::ETPlNumeralo idemeta component EspPlTradukilo
ETPlNumeralo instproc distinguDifinilon frazTraduko {
    my instvar elemento arto nombro persono
    if {[$elemento hasclass GP::Substantivo]} {
        set vorto [$elemento prenuVorton]
        if {[string index $vorto end] ne "a" && [string range $vorto end-1 end] ne "an" && ![$elemento estasOnoj]} {
            my class ETPlSubstantivo
            my distinguDifinilon $frazTraduko
            return
        } else {
            my mixin add ETPlSubstantivoartaMix
            set arto ze
            set nombro singularo
            set persono 3
            my distinguSubstantivanDifinilon
        }
    } else {
        next
    }
}
ETPlNumeralo instproc distinguGramatikon frazTraduko {
    # Nombroj pli grandaj ol 5 kauzas Genitivon (Dopelniacz) en slaval lingvoj
    # ekzemple
    # 5 libroj - 5 ksiazek

    next

    my instvar elemento kazo veraNombro

    if {[$elemento estasNurNumero]} {
        set rad [my miAuxRadikaElemento]
        set par [$rad parenco]
        if {$par ne "" && [[$par elemento] istype SintaksAsto::np]} {
            # dwie ksiazki M
            # dwa psy M
            # dwóch zolnierzy D
            if {([info exists veraNombro] && $veraNombro>=5) ||
                ([$par exists arto] && [$par set arto] eq "ms" && [$elemento exists veraNombro] && [$elemento set veraNombro]>1) ||
                ([$elemento exists veraNombro] && ([$elemento set veraNombro]>=5 || [string length [$elemento set veraNombro]]>2))} {
                if {[$par exists kazo] && [lsearch {M B} [$par set kazo]]>=0} {
                    $par set kazo D
                    $par set persono 3
                    $par set nombroPluralo 1
                    set prad [$par prenuRadiko]
                    #$prad set arto ni
                    $prad set nombroPluralo 1
                    if {[$prad hasclass ETSubstantivoartaMix]} {
                        $prad distinguSubstantivanDifinilon
                    }
                    $prad metuAttributonEnRadikaFunkcion kazo D
                }
            }
        }
    }
    # tempo
    # mi laboris 2 horojn
    # Ja pracowalem 2 godziny
    if {$kazo eq ""} {
        foreach p [my prenuParencojn] {
            if {[$p exists elemento]
                && [[$p elemento] istype SintaksAsto::subsup]
                && [[$p elemento] set funkcio] eq "tempo"} {
                    set kazo D
                    set arto mn
                    set nombro singularo
                    return
                }
        }
        set kazo M
    }
}
ETPlNumeralo instproc traduku vortaro {
    my instvar traduko bazaTraduko elemento arto kazo nombro veraNombro fgrupo
    if {[my tradukuNeVorto $vortaro]} {
        return
    }

    set fleksiolo [my prenuFleksilon]
    set traduko [$elemento set vorto]
    if {[$elemento hasclass GP::Adjektivo] || [regexp {aj?n?$} [$elemento set vorto]]} {
        set numarto [$elemento set arto]
        switch $numarto {
            {} {
                set mstraduko [$fleksiolo prenuNumero $bazaTraduko ordo]
            }
            op {
                set mstraduko [$fleksiolo prenuNumero $bazaTraduko opo]
            }
            default {
                my bazaTraduko $vortaro
                if {[my testuSentradukeco]} {
                    set traduko $bazaTraduko
                } else {
                    set traduko [$fleksiolo prenuAdjektivon $bazaTraduko $arto $kazo $nombro]
                }
                return
            }
        }
        set traduko [$fleksiolo prenuAdjektivon $mstraduko $arto $kazo $nombro]
        return
    }
    if {[$elemento hasclass GP::Substantivo]} {
        if {[$elemento set arto] eq "on"} {
            set num [$elemento prenuNumeron]
            if {$num==2} {
                my bazaTraduko $vortaro
                if {[my testuSentradukeco]} {
                    set traduko $bazaTraduko
                } else {
                    set nombro singularo
                    set traduko [$fleksiolo prenuSubstantivonLauxTipo $bazaTraduko $fgrupo $kazo $nombro]
                    return
                }
            } else {
                set bnum [$fleksiolo prenuNumeroGis1000 $num ordo]
                set traduko [$fleksiolo prenuAdjektivon $bnum ze $kazo [$elemento prenuNombron]]
                if {[set ae [$elemento prenuAntauxElemento]] eq "" || ![$ae istype GP::Numeralo]} {
                    set traduko "[$fleksiolo prenuBazaNumeroLauKazoArto 1 $kazo ze] $traduko"
                }
                return
            }
        }
        my bazaTraduko $vortaro
        set traduko $bazaTraduko
        my metuMesagxon "nombroarto nun ne subtenata" subteno
        return
    }
    if {[$elemento hasclass GP::Adverbo]} {
        set numarto [$elemento set arto]
        switch $numarto {
            {} {
                set mstraduko [$fleksiolo prenuNumero $bazaTraduko ordo]
            }
            default {
                my bazaTraduko $vortaro
                set traduko $bazaTraduko
                if {[my testuSentradukeco]} {
                    my metuMesagxon "nombroarto $numarto nun ne subtenata" subteno
                }
                return
            }
        }
        if {[string index $mstraduko end] eq "i"} {
            append mstraduko e
        } else {
            set mstraduko [string range $mstraduko 0 end-1]e
        }
        set traduko "po $mstraduko"
        return
    }
    set traduko [$fleksiolo prenuNumeroLauKazoArtoGis1000 $bazaTraduko $kazo $arto]
}
Class ETPlParticipoMix -superclass ::ETParticipoMix
@ ::ETPlParticipoMix idemeta component EspPlTradukilo
ETPlParticipoMix instproc bazaTraduko vortaro {
    my instvar elemento tempo preTraduko

    if {![my bazaTradukoDirekte $vortaro]} {
        # divenu partizipon de verbo
        next
        my instvar bazaTraduko tempo gramatiko fgrupo nombro mesagxoTipo arto kazo tradukoListoj
        set fleksilo [my prenuFleksilon]
        if {![my testuSentradukeco]} {
            set vtempo $tempo
            if {[my istype ETAdverbo] && $bazaTraduko eq "być"} {
                switch $tempo {
                    ante {
                        set bazaTraduko "będąc"
                    }
                    onte {
                        set bazaTraduko "będąc w przyszłości"
                    }
                    inte {
                        set bazaTraduko "będąc wcześniej"
                    }
                }
            } else {
                switch $vtempo {
                    ota {
                        set preTraduko "w przyszłości"
                        set vtempo ata
                    }
                    ita {
                         if {[lsearch $gramatiko dk]<0} {
                            set preTraduko "wcześniej"
                            set vtempo ata
                        }
                    }
                    ont -
                    onto -
                    onta -
                    onte {
                        set preTraduko "w przyszłości"
                        if {$vtempo eq "ont"} {
                            set vtempo anta
                        } else {
                            set vtempo ant[string index $vtempo end]
                        }
                    }
                    int -
                    into -
                    inta -
                    inte {
                        if {[my istype ETAdverbo] && [lsearch $gramatiko dk]>=0} {
                            # set vtempo inte
                        } else {
                            set preTraduko "wcześniej"
                            if {$vtempo eq "int"} {
                                set vtempo anta
                            } else {
                                set vtempo ant[string index $vtempo end]
                            }
                        }
                    }
                }
                if {$fgrupo eq ""} {
                    set fgrupo [$fleksilo sxercxuFGrupoPorVerbo $bazaTraduko]
                    my metuMesagxon "fleksia grupo ne konata" fleksio
                }
                if {[lindex $bazaTraduko 0] eq "nie"} {
                    set bazaTraduko [lrange $bazaTraduko 1 end]
                    lappend preTraduko nie
                }
                if {[llength $bazaTraduko]>1} {
                    # ekzemple: rajti -> miec racje (majacy racje)
                    my set postTraduko [join [lrange $bazaTraduko 1 end]]
                    set nurverbo [lindex $bazaTraduko 0]
                } else {
                    set nurverbo $bazaTraduko
                }
                if {[info exists nombro] && $nombro eq "pluralo" && [info exists arto] && $arto eq "ms" && [info exists kazo] && $kazo eq "M"} {
                    set bazaTraduko [$fleksilo prenuVerbon $nurverbo $fgrupo 3 mz $nombro $vtempo]
                } else {
                    set bazaTraduko [$fleksilo prenuVerbon $nurverbo $fgrupo 3 mz singularo $vtempo]
                }
                if {[my istype ETSubstantivo]} {
                    set fgrupo 52
                }
                set novTradukListo {}
                set sinonimoj [list]
                lappend sinonimoj $bazaTraduko
                foreach {svorto sfgrupo sgramatiko} $tradukoListoj {
                    if {[info exists nombro] && $nombro eq "pluralo" && [info exists arto] && $arto eq "ms" && [info exists kazo] && $kazo eq "M"} {
                        set sbazaTraduko [$fleksilo prenuVerbon $svorto $sfgrupo 3 mz $nombro $vtempo]
                    } else {
                        set sbazaTraduko [$fleksilo prenuVerbon $svorto $sfgrupo 3 mz singularo $vtempo]
                    }
                    if {[my istype ETSubstantivo]} {
                        set sfgrupo 52
                    } elseif {[my istype ETAdverbo] && $vtempo ne "ite"} {
                        set sbazaTraduko [string range $bazaTraduko 0 end-1]
                    }
                    lappend sinonimoj $sbazaTraduko
                    lappend novTradukListo $sbazaTraduko $sfgrupo $sgramatiko
                }
                set tradukoListoj $novTradukListo
                if {[llength $novTradukListo]>3} {
                    my aliguEblo sinonimo $sinonimoj $bazaTraduko sxangxuSinonimon
                }
            }
        }
    }
}
ETPlParticipoMix instproc bazaTradukoDirekteOVorto vortaro {
    my instvar fgrupo tempo elemento
    # se *into testu *anto
    set b [$elemento prenuParticipanBazanFormon]
    set listo [list]
    if {[regexp {^.+into$} $b]} {
         set pbazaVorto [string replace [$elemento prenuParticipanBazanFormon] end-3 end-3 a]
         set listo [$vortaro sxercxuRezListo $pbazaVorto [[my info parent] lingvo]]
    }
    return $listo
}
ETPlParticipoMix instproc selektuBazanTradukon tradukojListojTemp {
    my instvar bazaTraduko fgrupo gramatiko tradukoListoj tempo
    set tradukoListoj $tradukojListojTemp
    set n 100
    set tradukoListo [list]
    # avantagxi "dk" formon por "it". Pardoni al mi Barbara
    if {[lsearch {inta ita inte ite} $tempo]>=0} {
        set alisto [list]
        foreach l $tradukoListoj {
            array set attrArr {gramatiko {} sento {} ordo {}}
            array set attrArr $l
            if {[lsearch $attrArr(gramatiko) dk]>=0} {
                lappend alisto $l
            }
        }
        if {[llength $alisto]>0} {
            set tradukoListoj $alisto
        }
    }
    foreach l $tradukoListoj {
        # TODO dict
        array set attrArr {gramatiko {} sento {} ordo {}}
        array set attrArr $l
        if {[string first n $tempo]>=0 && [lsearch $attrArr(gramatiko) dk]>=0} {
            continue
        }
        if {$tempo eq "it" && [lsearch $attrArr(gramatiko) ndk]>=0} {
            continue
        }
        if {($attrArr(ordo) ne "" && $attrArr(ordo)!=0 && $attrArr(ordo)<$n) || [llength $tradukoListo]==0} {
            set n $attrArr(ordo)
            if {$n eq "" || $n==0} {
                set n 100
            }
            set tradukoListo $l
        }
    }
    if {[llength $tradukoListo]==0} {
        set tradukoListo [lindex $tradukoListoj 0]
        my metuMesagxon "'dk' verbo por pasinta tempo ne trovita" leksikono
    }
    esp::mapDict $tradukoListo traduko bazaTraduko fgrupo fgrupo gramatiko gramatiko
}
Class ETPlPersonPronomo -superclass {::ETPlTradukElemento ::ETPersonPronomo ::ETPlSubstantivoartaMix}
@ ::ETPlPersonPronomo idemeta component EspPlTradukilo
ETPlPersonPronomo instproc cxuArtoGravas {} {
    my instvar elemento
    if {[$elemento set funkcio] eq "subj"} {
        set ma [my trovuMainAston]
        if {$ma ne "" && [set rad [$ma prenuRadiko]] ne ""} {
            set relem [$rad set elemento]
            if {[$relem exists tempo] && [$relem set tempo] eq "is"} {
                return 1
            }
            foreach a [$ma astoj] {
                if {[$a exists elemento] && [[$a elemento] prenuFunkcioNomo] eq "attr"} {
                    return 1
                }
            }
        }
    }
    return 0
}
ETPlPersonPronomo instproc distinguDifinilon frazTraduko {
    my instvar elemento arto nombro persono
    set nombro [$elemento prenuNombron]
    set vorto [$elemento prenuVorton]
    set persono [$elemento prenuPersonon]
    switch -- [string trimright $vorto n] {
        mi {
            if {[my cxuArtoGravas]} {
                my metuMesagxon "arto de personalpronomo ne konata" arto
                my aliguEblo arto {ms ze} ms sxangxuArton
            }
            if {[EsperantoConf set tradPreferuInanSekson]} {
                set arto ze
            } else {
                set arto ms
            }
        }
        vi {
            if {[my cxuArtoGravas]} {
                my metuMesagxon "arto de personalpronomo ne konata" arto
                my aliguEblo arto {ms ze} ms sxangxuArton
            }
            if {$nombro ne "pluralo"} {
                my aliguEblo nombro {singularo pluralo} singularo sxangxuNombron
            }
            if {[EsperantoConf set tradPreferuInanSekson]} {
                set arto ze
            } else {
                set arto ms
            }
        }
        li {
            set arto ms
        }
        ŝi {
            set arto ze
        }
        ĝi {
            my metuMesagxon "arto de personalpronomo ne konata" arto
            my aliguEblo arto {ni ms ze} ni sxangxuArton
            set arto ni
        }
        ni {
            set arto ms
        }
        ili {
            my metuMesagxon "arto de personalpronomo ne konata" arto
            my aliguEblo arto {ms ze} mi sxangxuArton
            set arto ms
        }
        oni {
            set arto ni
        }
        si {
            set arto ms
        }
        default {
            set arto ms
        }
    }
    my distinguSubstantivanDifinilon
}
ETPlPersonPronomo instproc distinguDifinilonPost frazTraduko {
    set radikaTradukElemento [my miAuxRadikaElemento]
    set dfunkcio [[$radikaTradukElemento elemento] set funkcio]
    if {$dfunkcio eq "subj"} {
        my distinguSubstantivanDifinilon
        set krad [my trovuMainAston]
        if {$krad ne ""} {
            set vrad [$krad prenuRadiko]
            if {$vrad ne ""} {
                $vrad distinguGramatikon $frazTraduko
                $vrad traduku [$frazTraduko prenuVortaron]
            }
        }
        foreach a [$krad astoj] {
            if {[$a exists elemento] && [[$a elemento] prenuFunkcioNomo] eq "attr"} {
                $a distinguGramatikon $frazTraduko
                $a traduku [$frazTraduko prenuVortaron]
            }
        }
    }
}
ETPlPersonPronomo instproc distinguGramatikon frazTraduko {
    my instvar parenco kazo elemento
    set skazo [$parenco sxercxuAttributonSupren kazo]
    if {$skazo ne ""} {
        set kazo $skazo
    } else {
        if {[info exists kazo] && $kazo eq ""} {
            set kazo [my kazoTrans [$elemento prenuKazon]]
        }
    }
}
ETPlPersonPronomo instproc posttradukaPlibonigo {indekso folioj} {
    my instvar persono nombro
    if {[EsperantoConf set tradPlForiguPronomojn] && [my prenuFunkcioNomo] eq "subj"} {
        if {$persono!=3} {
            my foriguDeParenco
        }
    }
}
ETPlPersonPronomo instproc sxangxuArton narto {
    set bazaFormo [[my elemento] prenuBazanFormon]
    if {$bazaFormo eq "ĝi" || $bazaFormo eq "ili"} {
        my set arto $narto
        my sxangxuEbloAktuala arto $narto
        my distinguDifinilonPost [my info parent]
        my traduku [[my info parent] prenuVortaron]
    } else {
        next
    }
}
ETPlPersonPronomo instproc traduku vortaro {
    my instvar persono parenco pprepozicio
    if {$persono==4} {
        my set traduko ""
    } else {
        set bazaformo [[my elemento] prenuBazanFormon]
        my instvar kazo arto nombro
        if {[info exists pprepozicio]} {
            set prepozicia $pprepozicio
        } else {
            if {[$parenco exists elemento]
            && [[$parenco set elemento] istype SintaksAsto::pp]
            && ([[$parenco set elemento] set funkcio] ne "iobj" || $kazo ne "C")} {
                set prepozicia 1
            } else {
                set prepozicia 0
                # Li lavis sin. -> On mył się
                if {[my prenuFunkcioNomo] eq "obj"} {
                    set vasto [my trovuMainVerboAston]
                    if {$vasto ne ""} {
                        set sub [$vasto trovuKunFunkcio subj]
                        if {$sub ne ""} {
                            set sub [$sub prenuRadiko]
                            if {[$sub prenuBazanFormon] eq $bazaformo || $bazaformo eq "si"} {
                                set vrad [$vasto prenuRadiko]
                                if {$vrad ne "" && [$vrad exists gramatiko] && "ref" in [$vrad set gramatiko]} {
                                    my set traduko się
                                    return
                                }
                            }
                        }
                    }
                }

            }
        }
        my set traduko [[my prenuFleksilon] prenuPersonPronomon $bazaformo $arto $kazo $nombro $prepozicia]
    }
}
Class ETPlPosesivPronomo -superclass {::ETPlTradukElemento ::ETPosesivPronomo}
@ ::ETPlPosesivPronomo idemeta component EspPlTradukilo
Class ETPlPrepozicio -superclass ::ETPrepozicio
@ ::ETPlPrepozicio idemeta component EspPlTradukilo
ETPlPrepozicio instproc posttradukaPlibonigo {indekso folioj} {
    my instvar traduko
    set f ""
    for {set i [expr {$indekso+1}]} {$i<[llength $folioj]} {incr i} {
        set tf [lindex $folioj $i]
        if {[$tf set traduko] ne ""} {
            set f $tf
            break
        }
    }
    if {$f eq "" || [$f testuSentradukeco]} return
    set mListo {z w przez przed bez spod od nad}
    if {[lsearch $mListo $traduko]>=0 && ([$f set traduko] eq "mnie" || [$f set traduko] eq "mną")} {
        append traduko e
        return
    }
    if {$traduko eq "z"} {
        set p {s z ż ź w f}
        set ftraduko [string trimleft [$f set traduko] "\{"]
        if {[lsearch $p [string index $ftraduko 0]]>=0 && ![[my prenuFleksilon] estasVovel [string index $ftraduko 1]]} {
            set traduko ze
            return
        }
    } elseif {$traduko eq "w"} {
        set p {w f}
        set ftraduko [string trimleft [$f set traduko] "\{"]
        if {[lsearch $p [string index $ftraduko 0]]>=0 && ![[my prenuFleksilon] estasVovel [string index $ftraduko 1]]} {
            set traduko we
            return
        }
    }
}
ETPlPrepozicio instproc preparuFunkcion_cxirkaux {} {
    my set traduko około
}
ETPlPrepozicio instproc preparuFunkcion_iobj {} {
    my instvar bazaTraduko traduko kazo
    set kazo C
    set basaTraduko ""
    set traduko ""
}
ETPlPrepozicio instproc preparuFunkcion_je {} {
    my instvar bazaTraduko traduko kazo
    set traduko o
    set kazo Ms
}
ETPlPrepozicio instproc preparuFunkcion_por {} {
    my instvar elemento traduko
    set eperenco [[$elemento set parenco] miAuxRadikaElemento]
    if {[$eperenco istype SintaksAsto::advp]} {
        set traduko na
    } else {
        next
    }
}
ETPlPrepozicio instproc preparuFunkcion_porinf {} {
    my instvar traduko
    set traduko aby
}
ETPlPrepozicio instproc preparuFunkcion_pos {} {
    my instvar bazaTraduko traduko kazo elemento
    set eperenco [[$elemento set parenco] miAuxRadikaElemento]
    set kazo D
    set bazaTraduko ""
    set traduko ""
}
ETPlPrepozicio instproc preparuFunkcion_psubj {} {
    my instvar bazaTraduko traduko kazo
    set kazo D
    set bazaTraduko "przez"
    set traduko "przez"
}
ETPlPrepozicio instproc tradukuHoron {} {
    my instvar traduko parenco kazo
    set kazo Ms
    set traduko o
    set npTrad ""
    foreach a [$parenco set astoj] {
        if {$a ne [self] && [$a istype ::TradukAsto]} {
            set npTrad $a
        }
    }
    if {$npTrad eq ""} return
    set rad [$npTrad prenuRadiko]
    if {[$rad istype ETPlNumeralo]} {
        if {![$rad tradukuNeVorto ""]} {
            $rad class ETSenOrigina
            set num [[my prenuFleksilon] prenuNumero [$rad set bazaTraduko] ordo]
            $rad set traduko [[my prenuFleksilon] prenuAdjektivon $num ze Ms singularo]
        }
    }
}
ETPlPrepozicio proc initializeAfterLoad {} {
    my instvar kazoArr
    # M D C B Ms N W
    # en nuna aldono tiuj priskriboj estas legitaj direkte de vortaro
    array set kazoArr {
        al {D do}
        anstataŭ {B zamiast}
        antaŭ {N przed}
        apud {D obok}
        da {D {}}
        de {D od}
        depost {D od}
        disde {D {osobna od}}
        dum {D {w czasie}}
        ekde {D {z początku}}
        ekster {D {na zewnątrz}}
        el {D z}
        en {Ms w D do}
        inter {N pomiędzy}
        je {D ?}
        kontraŭ {D przeciw}
        krom {D oprócz}
        kun {N z}
        laŭ {D według}
        malantaŭ {D {z tyłu}}
        malgraŭ {D pomimo}
        per {N {}}
        po {B po}
        por {D dla}
        post {Ms po}
        preter {D obok}
        pri {Ms o}
        pro {D {z powodu}}
        sen {D bez}
        sub {N pod B pod}
        super {N ponad}
        sur {Ms na B na}
        tra {B przez}
        trans {B poprzez}
        ĉe {Ms przy}
        ĉirkaŭ {D wokół}
        ĝis {D do}
    }
}
ETPlPrepozicio proc prenuDiskriboPorPrepozicio {prepozicio {estasMuvo 0}} {
    my instvar kazoArr
    if {![info exists kazoArr($prepozicio)]} {
        return
    }
    set ret $kazoArr($prepozicio)
    if {$estasMuvo} {
        if {[llength $ret]>2} {
            lrange $ret 2 3
        } else {
            lrange $ret 0 1
        }
    } else {
        lrange $ret 0 1
    }
}
Class ETPlPrimitivaAdverbo -superclass ::ElemTraduko
@ ::ETPlPrimitivaAdverbo idemeta component EspPlTradukilo
ETPlPrimitivaAdverbo instproc distinguGramatikon frazTraduko {
    my instvar elemento parenco
    if {[$elemento prenuVorton] eq "ĉi"} {
        my set traduko ""
        $parenco set cxi 1
    }
}
ETPlPrimitivaAdverbo instproc tradukoPostSinonimoSxangxo {} {
    my set traduko [my set bazaTraduko]
}
ETPlPrimitivaAdverbo instproc traduku vortaro {
    my instvar elemento parenco
    if {[$elemento prenuVorton] eq "ĉi"} {
        my set traduko ""
    } elseif {[$elemento prenuVorton] eq "mem"} {
        my instvar traduko bazaTraduko kazo personon nombro arto
        set bazaTraduko sam
        set kazo [my sxercxuAttributonSupren kazo]
        if {$kazo eq ""} {
            set kazo M
        }
        set nombro [my sxercxuAttributonSupren nombro]
        if {$nombro eq ""} {
            set nombro singularo
        }
        set arto [my sxercxuAttributonSupren arto]
        if {$arto eq ""} {
            set arto ms
        }
        set traduko [[my prenuFleksilon] prenuPosesivPronomon mem $arto $kazo $nombro]
    } elseif {[$elemento prenuVorton] eq "pli" && [[$parenco elemento] istype SintaksAsto::padj]} {
        my set traduko "bardziej"
    } elseif {[$elemento prenuVorton] eq "plu" && [[$parenco elemento] istype SintaksAsto::ne]} {
        # mi lin ne plu vidis
        my set traduko "więcej"
        $parenco movuAlPozicio [self] 0
    } elseif {[$elemento prenuVorton] eq "for" && [[$parenco elemento] istype SintaksAsto::advsup]} {
        # du metrojn for de mi
        my set traduko od
    } else {
        next
    }
}
Class ETPlSubstantivo -superclass {::ETPlTradukElemento ::ETSubstantivo ::ETPlSubstantivoartaMix}
@ ::ETPlSubstantivo idemeta component EspPlTradukilo
ETPlSubstantivo instproc bazaTraduko vortaro {
    my instvar gramatiko nombro
    next
    if {[info exists gramatiko] && [lsearch $gramatiko blp]>=0 && $nombro eq "singularo"} {
        set nombro pluralo
    }

}
ETPlSubstantivo instproc distinguArtonKajDefinilon {} {
    my instvar fgrupo bazaTraduko arto
    set fleksilo [my prenuFleksilon]
    if {$fgrupo ne ""} {
        # kilku kiel "ni"
        # kilku siedzialo na schodach
        if {$bazaTraduko ne "kilku"} {
            set arto [$fleksilo prenuArtoDeTipo $fgrupo]
        }
    } else {
        my metuMesagxon "fgrupo por substantivo ne konata" fleksio
        set fgrupo [$fleksilo divenuTiponDeSubstantivo [lindex $bazaTraduko 0]]
        set arto [$fleksilo prenuArtoDeTipo $fgrupo]
    }
    my distinguSubstantivanDifinilon
}
ETPlSubstantivo instproc distinguDifinilon frazTraduko {
    my instvar elemento arto bazaTraduko parenco nombro fgrupo persono senTraduko

    my distinguDifinilonBaza $frazTraduko

    if {[my testuSentradukeco]} {
        if {$senTraduko==2} {
            # vortfarado "lingvokono -> kono de lingvo"
            return
        }
        set arto mn
        my distinguSubstantivanDifinilon
        return
    }
    if {$bazaTraduko eq "kilku"} {
        my set nombroPluralo 1
        my set arto ni
    }
    my distinguArtonKajDefinilon
}
ETPlSubstantivo instproc distinguGramatikon frazTraduko {
    next
    my instvar bazaTraduko arto fgrupo
    if {[info exists bazaTraduko] && $bazaTraduko eq "jeden"} {
        # unu el bonaj libroj
        # unu el bonaj homoj
        # testu cxu "unu el" esprimo
        set s [my selektu {parenco elemento {filtruVeron istype SintaksAsto::subsup} prenuPPParton radiko {filtruVeron estasVortoj {de el}}}]
        if {$s ne ""} {
            set s [my selektu {parenco 1 1 prenuRadiko}]
            if {$s ne "" && [$s exists arto]} {
                set arto [$s set arto]
                switch $arto {
                    ze {
                        set bazaTraduko jedna
                        set fgrupo 110
                    }
                    ni {
                        set bazaTraduko jedno
                        set fgrupo 94
                    }
                }
            }
        }
    }
}
ETPlSubstantivo instproc prenuTradukTaugecoIndekson attr {
    my instvar nombro
    set n [next $attr]
    if {[lsearch [dict get $attr gramatiko] blm]>=0 && $nombro eq "pluralo"} {
        incr n 101
    }
    # nożyczki, usta, drzwi
    #if {[lsearch [dict get $attr gramatiko] blp]>=0 && $nombro eq "singularo"} {
    #    incr n 101
    #}
    return $n
}
ETPlSubstantivo instproc traduku vortaro {
    my instvar traduko bazaTraduko kazo elemento arto nombro fgrupo gramatiko
    if {[my testuSentradukeco]} {
        set nombro [$elemento prenuNombron]
        return
    }
    if {[$elemento estasVorto %]} {
        set traduko %
        return
    }
    if {"ndm" in $gramatiko} {
        set traduko $bazaTraduko
        return
    }
    if {$fgrupo eq ""} {
        set traduko [[my prenuFleksilon] prenuSubstantivon $bazaTraduko $arto $kazo $nombro]
    } else {
        set traduko [[my prenuFleksilon] prenuKompleksanSubstantivonLauxTipo $bazaTraduko $fgrupo $kazo $nombro]
    }

}
Class ETPlTabloVorto -superclass {::ETPlTradukElemento ::ElemTraduko ::ETPlSubstantivoartaMix}
@ ::ETPlTabloVorto idemeta component EspPlTradukilo
ETPlTabloVorto instproc aliguAjn {havasAjn tradukoRef} {
    if {$havasAjn} {
        upvar $tradukoRef traduko
        if {[string index $traduko end] eq "ś"} {
            set traduko [string range $traduko 0 end-1]
        }
        set traduko ${traduko}kolwiek
    }
}
ETPlTabloVorto instproc distinguDifinilon frazTraduko {
    my instvar elemento persono nombro arto estasRelativPronomo
    set estasRelativPronomo [$elemento estasRelativPronomo]
    if {[$elemento hasclass GP::Substantivo]} {
        set persono 3
        if {$estasRelativPronomo} {
            set arto [my sxercxuAttributonCxeDisk arto]
        } else {
            if {[$elemento set arto] eq "u"} {
                set arto ms
            } else {
                set arto ni
            }
        }
        set nombro [$elemento prenuNombron]
        my distinguSubstantivanDifinilon
    }
}
ETPlTabloVorto instproc distinguGramatikon frazTraduko {
    my instvar kazo parenco elemento nombro arto persono estasRelativPronomo
    set kazo [my sxercxuAttributonSupren kazo]
    if {$kazo eq ""} {
        if {[$elemento exists kazo]} {
            switch [$elemento set kazo] {
                nominativo {
                    set kazo M
                }
                akuzativo {
                    set kazo B
                }
            }
        }
    }
    set arto ""
    if {$estasRelativPronomo} {
        set arto [my sxercxuAttributonCxeDisk arto]
    } else {
        set arto [my sxercxuAttributonSupren arto]
    }
    if {$arto eq ""} {
        my metuMesagxon "arto ne destingebla" arto
        set arto ms
    }
    if {$kazo eq ""} {
        set kazo M
    }
    if {[$elemento hasclass GP::NombroKazo]} {
        set nombro [$elemento prenuNombron]
    } elseif {[$elemento estasArto es]} {
        set nombro [my sxercxuAttributonSupren nombro]
    }
    if {![info exists nombro] || $nombro eq ""} {
        set nombro singularo
    }
}
ETPlTabloVorto instproc tradukoPostSinonimoSxangxo {} {
    my set traduko [my set bazaTraduko]
}
ETPlTabloVorto instproc traduku vortaro {
    my instvar traduko bazaTraduko elemento arto kazo nombro estasRelativPronomo parenco
    if {[info exists traduko]} return
    set bazaTraduko [$elemento prenuBazanFormon]
    set traduko ($bazaTraduko)
    set fleksilo [my prenuFleksilon]
    # iu ajn = kiu ajn -> ktokolwiek
    set aliguKolwiek 0
    if {[[$elemento set parenco] istype SintaksAsto::grupo] && [[[$elemento set parenco] prenuLastan] prenuVorton] eq "ajn"} {
        if {[string index $bazaTraduko 0] eq "i"} {
            set bazaTraduko k$bazaTraduko
        }
        #
        [lindex [$parenco astoj] end] class ETNul
        set aliguKolwiek 1
    }

    if {[$elemento hasclass GP::Substantivo] && !$estasRelativPronomo} {
        if {$bazaTraduko eq "tio" && [$elemento set funkcio] eq "comp"} {
            set kazo M
            # Tio estas mi - To jestem ja
        }
        set traduko [$fleksilo prenuPersonPronomon $bazaTraduko ms $kazo $nombro]
        set cxi [my sxercxuAttributonSupren cxi]
        # cxio cxi
        if {$cxi eq "1" && $bazaTraduko eq "ĉio"} {
            set traduko "[$fleksilo prenuPersonPronomon tio ms $kazo $nombro] $traduko"
        }
        my aliguAjn $aliguKolwiek traduko
        return
    }
    if {[$elemento hasclass GP::NombroKazo] || $estasRelativPronomo} {
        if {[$elemento estasVorto kies]} {
            # kobieta, czyjej spiew był bardzo piekny
            set kazo D
            set tnombro [my sxercxuAttributonCxeDisk nombro]
            if {$tnombro ne ""} {
                set nombro $tnombro
            }
        }
        if {$nombro eq ""} {
            set nombro singularo
        }
        set traduko [$fleksilo prenuPosesivPronomon $bazaTraduko $arto $kazo $nombro]
        my aliguAjn $aliguKolwiek traduko
        return
    }
    if {[$elemento estasVorto kies]} {
        if {$kazo eq ""} {
            set traduko czyj
        } else {
            set traduko [$fleksilo prenuPosesivPronomon kies $arto $kazo $nombro]
        }
        my aliguAjn $aliguKolwiek traduko
        return
    } elseif {[$elemento estasVortoj {nenies ties ies}] && $kazo ne ""} {
        set traduko [$fleksilo prenuPosesivPronomon $bazaTraduko $arto $kazo $nombro]
        return
    }
    if {[$elemento set arto] eq "e" && [[$parenco elemento] istype SintaksAsto::advp] && [[[$parenco elemento] prenuUnuan] estasVorto "de"]} {
        set estasDeIe 1
        set dobj [lindex [$parenco set astoj] 0]
        $dobj class ETNul
        $dobj traduko ""
    } else {
        set estasDeIe 0
    }
    switch [$elemento prenuVorton] {
        kie {
            if {$estasDeIe} {
                set traduko skąd
            } else {
                set traduko gdzie
            }
        }
        ie {
            if {$estasDeIe} {
                set traduko skąś
            } else {
                set traduko gdzieś
            }
        }
        nenien {
            if {$estasDeIe} {
                set traduko {z nikąd}
            } else {
                set traduko {donikąd}
            }
        }
        ĉie {
            if {$estasDeIe} {
                set traduko {ze wsząd}
            } else {
                set traduko wszędzie
            }
        }
        tien -
        tie {
            set cxi [my sxercxuAttributonSupren cxi]
            if {$cxi eq "1"} {
                if {$estasDeIe} {
                    set traduko {z tąd}
                } else {
                    set traduko tutaj
                }
            } else {
                if {$estasDeIe} {
                    set traduko {z tamtąd}
                } else {
                    set traduko tam
                }
            }
        }
        nenie {
            if {$estasDeIe} {
                set traduko {z nikąd}
            } else {
                set traduko nigdzie
            }
        }
        kien {
            if {$estasDeIe} {
                set traduko {skąd}
            } else {
                set traduko dokąd
            }
        }
        ien {
            if {$estasDeIe} {
                set traduko {skąś}
            } else {
                set traduko dokąś
            }
        }
        ĉien {
            if {$estasDeIe} {
                set traduko {ze wsząd}
            } else {
                set traduko wszędzie
            }
        }
        ties {
            set traduko tego
        }
        nenies {
            set traduko niczyj
        }
        ĉies {
            set traduko wszystkich
        }
        ies {
            set traduko czyjś
        }
        kiam {
            set traduko kiedy
        }
        tiam {
            set traduko wtedy
        }
        ĉiam {
            set traduko zawsze
        }
        iam {
            set traduko kiedyś
        }
        kiom {
            if {[set pe [my selektu {elemento parenco}]] ne "" && [$pe istype SintaksAsto::adjp]} {
                set traduko {jak bardzo}
            } elseif {[set pe [my selektu {elemento parenco}]] ne "" && [$pe istype SintaksAsto::advp]} {
                set traduko jak
            } else {
                if {[my miAuxRadikaElemento] ne [self]} {
                    set traduko [$fleksilo prenuPersonPronomon kiom $arto $kazo pluralo]
                } else {
                    set traduko ile
                }
            }
        }
        tiom {
            if {[set pe [my selektu {elemento parenco}]] ne "" && [$pe istype SintaksAsto::adjp]} {
                set traduko {na tyle}
            } else {
                if {[my miAuxRadikaElemento] ne [self]} {
                    set traduko [$fleksilo prenuPersonPronomon tiom $arto $kazo pluralo]
                } else {
                    set traduko ile
                }
            }

        }
        kiel {
            if {[set sekva [$elemento prenuSekvaElemento]] ne "" && [$sekva estasVorto eble]} {
                set traduko ""
                # kiel eble -> możliwie jak
                [set st [my prenuSekvaElemento]] set traduko "możliwie jak"
                $st mixin add ETFiksaMix
            } else {
                set traduko jak
                set epar [my selektu {elemento parenco}]
                if {$epar ne ""} {
                    if {[$epar istype SintaksAsto::kadv]} {
                        # prezidanto kiel homo
                        if {[$epar funkcio] eq "pos"} {
                            set traduko jako
                        } elseif {[$epar funkcio] eq "adv"} {
                            set vrad [my selektu {trovuMainVerboAston elemento prenuRadiko}]
                            if {$vrad ne "" && ![$vrad estasBasaVorto esti]} {
                                set traduko jako
                            }
                        }
                    }
                }
            }
        }
        default {
            my bazaTraduko $vortaro
            next
        }
    }
    my aliguAjn $aliguKolwiek traduko
}
Class ETPlVerbo -superclass {::ETPlTradukElemento ::ETVerbo}
@ ::ETPlVerbo idemeta component EspPlTradukilo
ETPlVerbo instproc distinguDifinilon frazTraduko {
    my instvar elemento bazaTraduko fgrupo gramatiko
    if {[my cxuHavasNeAdverbon]} {
        my neniuVerbon
    } elseif {[info exists elemento] && [$elemento estasBasaVorto devi] && [$elemento set tempo] ne "i"} {
        # vi devas ne fumi
        set nvfp [my selektu {trovuMainAston elemento {trovuKunFunkcio nfvp}}]
        if {$nvfp ne ""} {
            set ne [$nvfp selektu {prenuRadiko parenco}]
            if {$ne ne "" && [$ne istype SintaksAsto::ne]} {
                set ne [$ne prenuUnuan]
                set tne [[my trovuMainAston] trovuUnunanInfanonKiu e {[$e exists elemento] && [$e set elemento] eq $ne}]
                if {$tne ne ""} {
                    $tne foriguDeParenco
                    my aliguMerkmalon devine
                    my neniuVerbon
                }
            }
        }
    }
    my set tempo [[my elemento] tempo]
}
ETPlVerbo instproc neniuVerbon {} {
    my instvar parenco elemento
    set ta [TradukAsto new -childof [my info parent]]
    lappend tastoj [ETSenOrigina new -childof [my info parent] -traduko "nie"]
    lappend tastoj [self]
    $ta astoj $tastoj
    $ta elemento $elemento
    $ta parenco $parenco
    set masto [my trovuMainVerboAston]
    if {$masto ne ""} {
        $masto set estasNeVerbo 1
    }
    $parenco intersxangxiElementoj [self] $ta
    set parenco $ta
}
ETPlVerbo instproc posttradukaPlibonigo {indekso folioj} {
    # ne metu 'się' en fino de frazo
    my instvar traduko
    set len [llength $folioj]
    if {[[lindex $folioj [expr {$len-1}]] hasclass ETSimbolo]} {
        incr len -1
    }
    if {[string range $traduko end-2 end] eq "się" && $indekso==$len-1} {
         set traduko "się [string range $traduko 0 end-4]"
    }
}
ETPlVerbo instproc prenuBazanFormon {} {
    if {[my havasMerkmalon devine]} {
        return povi
    } else {
        next
    }
}
ETPlVerbo instproc prenuTradukTaugecoIndekson attr {
    my instvar nombro tempo
    # neniu aux ordo 0 estas tre malalto ordo 100
    set n [next $attr]

    if {$tempo eq "as" && [lsearch [dict get $attr gramatiko] dk]>=0} {
        incr n 101
    }
    if {[lsearch [dict get $attr gramatiko] dk]>=0 && [my havasMerkmalon dauraTempo]} {
        incr n 101
    }
    if {[lsearch [dict get $attr gramatiko] ndk]>=0 && [my havasMerkmalon punktaTempo]} {
        incr n 101
    }
    if {[my havasMerkmalon nvfp] && [lsearch [dict get $attr gramatiko] inf]<0} {
        incr n 10
    }
    if {[my havasMerkmalon sensubj] && [lsearch [dict get $attr gramatiko] sensubj]<0} {
        incr n 10
    }
    if {[my havasMerkmalon tr] && [lsearch [dict get $attr gramatiko] trans]<0} {
        incr n 10
    }
    if {![my havasMerkmalon tr] && [lsearch [dict get $attr gramatiko] ntrans]<0} {
        incr n 10
    }
    return $n
}
ETPlVerbo instproc selektuBazanTradukon tradukojListojTemp {
    my instvar tempo
    set m [my selektu {trovuMainVerboAston elemento}]
    if {$m ne ""} {
        if {$tempo ne "as"} {
            if {[$m estasDauraTempo]} {
                my aliguMerkmalon dauraTempo
            } elseif {[$m estasPunktaTempo]} {
                my aliguMerkmalon punktaTempo
            }
        }
        if {[$m trovuKunFunkcio nfvp] ne ""} {
            my aliguMerkmalon nvfp
        }
        if {[$m trovuKunFunkcio obj] ne ""} {
            my aliguMerkmalon tr
        }
        if {[$m trovuKunFunkcio subj] eq ""} {
            my aliguMerkmalon sensubj
        }
    }
    my selektuBazanTradukonKunFiltro $tradukojListojTemp
}
ETPlVerbo instproc substantivigi tkazo {
    my instvar kazo
    set kazo $tkazo
    my aliguMerkmalon sub
}
ETPlVerbo instproc sxercxuFGrupoPorVerbo verbo {
    [my prenuFleksilon] sxercxuFGrupoPorVerbo $verbo
}
ETPlVerbo instproc tradukoOrdonon {} {
    my instvar persono arto tempo nombro bazaTraduko traduko fgrupo
    set main [my trovuMainAston]
    if {$main eq "" || ($main ne "" && [[$main elemento] estasOrdonoSenSubjekto])} {
        set traduko [join [concat [[my prenuFleksilon] prenuVerbon [lindex $bazaTraduko 0] $fgrupo 3 $arto $nombro u] [lrange $bazaTraduko 1 end]]]
        return
    }
    if {$main eq "" || ($main ne "" && [[$main elemento] estasOrdonoKunBonvolu])} {
        set traduko proszę
        return
    }
    set pIndekso [expr {$persono-1}]

    set listo {powinienem powinam powinieneś powinaś powinien powina powino powiniśmy powiniśmy powiniście powiniście powini powine}
    set indekso 0
    if {$nombro eq "pluralo"} {
        incr indekso 7
    }
    incr indekso [expr {$pIndekso*2}]
    if {$arto ne "ms"} {
        incr indekso 1
    }
    if {$arto eq "ni" && $persono==2 && $nombro eq "singularo"} {
        incr indekso 1
    }
    if {[my havasMerkmalon dev]} {
        set traduko [lindex $listo $indekso]
    } else {
        set traduko "[lindex $listo $indekso] $bazaTraduko"
    }
}
ETPlVerbo instproc traduku vortaro {
    my instvar traduko bazaTraduko persono nombro tempo arto fgrupo gramatiko elemento keUFrazo
    if {[my testuSentradukeco]} return
    set fleksilo [my prenuFleksilon]
    if {$fgrupo eq ""} {
        my metuMesagxon "Fleksio ne certa" fleksio
        set fgrupo [my sxercxuFGrupoPorVerbo [lindex $bazaTraduko 0]]
    }
    if {$tempo eq "os" && [lsearch $gramatiko "dk"]>=0} {
        set tempo as
    }
    # vidu TAPl::ppinf - "Mi mangxas sen paroli" - jem bez mowienia
    if {[my havasMerkmalon sub]} {
        set tempo o
    }
    set main [my selektu {trovuMainVerboAston elemento}]
    # Libro estis tralegita -> Ksiazka zostala przeczytana
    # Libro estos tralegita -> Ksiazka zostanie przeczytana
    if {$main ne "" && [$main estasPasivaFrazo] && $bazaTraduko eq "być" && $tempo ne "as"} {
        set attrobj [$main trovuKunFunkcio attr]
        set vtempo $tempo
        set vpersono $persono
        if {$keUFrazo eq "1" && $vtempo eq "u"} {
            set vtempo is
            set vpersono 3
        }
        if {$attrobj ne "" && [[$attrobj prenuRadiko] set tempo] eq "ita"} {
            if {$vtempo eq "os"} {
                set ztempo as
            } else {
                set ztempo $vtempo
            }
            set traduko [$fleksilo prenuVerbon zostać Xa $vpersono $arto $nombro $ztempo]
            return
        }
    }
    # Li estis finanta - On konczyl
    if {$main ne "" && [$main estasKompleksaTempo] && $bazaTraduko eq "być"} {
        set attrobj [[$main trovuKunFunkcio attr] prenuRadiko]
        if {$attrobj ne "" && [$attrobj estasPartizipo]} {
            if {[$attrobj set tempo] eq "inta"} {
                my aliguMerkmalon punktaTempo
            } else {
                my aliguMerkmalon dauraTempo
            }
            set a [[my trovuMainAston] trovuKunFunkcio attr]
            if {$a ne ""} {
                [$a prenuRadiko] foriguDeParenco
            }
            my mixin add ETSpecialaTradukoMix
            my set bazaVorto [$attrobj prenuBazanFormon]
            my bazaTraduko $vortaro
        }
    }
    if {$persono==4} {
        my tradukuOni
    } else {
        set vtempo $tempo
        set vpersono $persono
        if {$keUFrazo eq "1" && $vtempo eq "u"} {
            set vtempo is
            set vpersono 3
        } elseif {$vtempo eq "u"} {
            my tradukoOrdonon
            return
        } elseif {[info exists elemento] && [$elemento estasBasaVorto devinti]} {
            my aliguMerkmalon dev
            my tradukoOrdonon
            return
        }
        # indas fari tion - warto to zrobić
        if {[llength $bazaTraduko]>=2 && [lindex $bazaTraduko 0] eq "być" && [lindex $bazaTraduko 1] in {warto można trzeba} && $fgrupo eq "senesti"} {
            if {$vtempo eq "as"} {
                # warto
                set traduko [join [concat [lrange $bazaTraduko 1 end]]]
            } else {
                # warto było
                set traduko [join [concat [lindex $bazaTraduko 1] [$fleksilo prenuVerbon [lindex $bazaTraduko 0] $fgrupo $vpersono $arto $nombro $vtempo] [lrange $bazaTraduko 2 end]]]
            }
        } else {
            set verbfleks [$fleksilo prenuVerbon [lindex $bazaTraduko 0] $fgrupo $vpersono $arto $nombro $vtempo]
            if {[my havasMerkmalon sub]} {
                set tipo [$fleksilo divenuTiponDeSubstantivo $verbfleks]
                set verbfleks [$fleksilo prenuSubstantivonLauxTipo $verbfleks $tipo [my set kazo] singularo]
            }
            # jest potrzebny -> jest potrzebna
            if {[llength $bazaTraduko]==2 && [lindex $bazaTraduko 0] eq "być" && [string first [string index [lindex $bazaTraduko 1] end] "iy"]>=0} {
                lset bazaTraduko 1 [$fleksilo prenuAdjektivon [lindex $bazaTraduko 1] $arto M $nombro]
            }
            set traduko [join [concat $verbfleks [lrange $bazaTraduko 1 end]]]
        }
    }
}
ETPlVerbo instproc tradukuOni {} {
    my instvar traduko bazaTraduko persono nombro tempo arto fgrupo gramatiko elemento
    if {$tempo eq "u"} {
        set traduko "powinno się $bazaTraduko"
    } elseif {[info exists elemento] && [$elemento estasBasaVorto devinti]} {
        set traduko "powinno się"
    } else {
        if {$tempo ne "i"} {
            if {[$elemento prenuBazanFormon] eq "povi"} {
                switch $tempo {
                    as {
                        set traduko "można"
                    }
                    os {
                        set traduko "można będzie"
                    }
                    is {
                        set traduko "można było"

                    }
                    us {
                        set traduko "można by było"
                    }
                }
            } elseif {[$elemento prenuBazanFormon] eq "devi"} {
                switch $tempo {
                    as {
                        set traduko "trzeba"
                    }
                    os {
                        set traduko "trzeba będzie"
                    }
                    is {
                        set traduko "trzeba było"

                    }
                    us {
                        set traduko "trzeba by było"

                    }
                }
            } else {
                set vtrad [lindex $bazaTraduko 0]
                if {[lindex $bazaTraduko 1] eq "się"} {
                    set resto [lrange $bazaTraduko 2 end]
                } else {
                    # oni faris - robiono
                    if {$tempo eq "is"} {
                        set traduko [join [concat [[my prenuFleksilon] prenuVerbon $vtrad $fgrupo 3 $arto singularo ois] [lrange $bazaTraduko 1 end]]]
                        return
                    }
                    set resto [lrange $bazaTraduko 1 end]
                }
                set traduko [join [concat [[my prenuFleksilon] prenuVerbon $vtrad $fgrupo 3 $arto singularo $tempo] się $resto]]
            }
        } else {
            set traduko $bazaTraduko
        }
    }
}
Class TAPl -superclass ::TradukAsto
@ ::TAPl idemeta component EspPlTradukilo
Class TAPl::advp -superclass ::TAPl
@ ::TAPl::advp idemeta component EspPlTradukilo
TAPl::advp instproc traduku vortaro {
    set radobj [my prenuRadiko]
    set rad [[[my prenuRadiko] set elemento] prenuBazanFormon]
    set fpvortaro [[my info parent] set fpvortaro]
    if {[llength [set defj [$fpvortaro prenuPorRadiko $rad]]]>0} {
        foreach d $defj {
            set vorto [lindex $d 0]
            if {[string match *e $vorto]} {
                my instvar astoj
                foreach a $astoj {
                    if {[$a istype ETAdverbo]} {
                        if {$a ne "" && [[[$a prenuRadiko] set elemento] estasBasaVorto $vorto]} {
                            set itrad [lindex $d 2]
                            $radobj metuBazanTradukon $itrad
                            set atrad [lindex $d 3]
                            [$a prenuRadiko] metuBazanTradukon $atrad
                        }
                        break
                    }
                }
            }
        }
    }
    next
}
Class TAPl::advsup -superclass ::TAPl
@ ::TAPl::advsup idemeta component EspPlTradukilo
TAPl::advsup instproc distinguDifinilon frazTraduko {
    my instvar parenco elemento arto persono nombro nombroPluralo kazo
    next
    # kiom da, tiom da ...
    if {[$elemento eblasKielSubstantivo]} {
        set subrad [my selektu {end 1 prenuRadiko}]
        if {$subrad ne "" && [$subrad exists arto]} {
            set arto [$subrad set arto]
            set persono 3
            set nombro pluralo
            set nombroPluralo 1
            # La asto nun laboras kiel elemento
            # tio povus kauxzi problemojn
            set r [my prenuRadiko]
            $r set persono $persono
            $r set arto $arto
            $r set nombro $nombro
            $r set nombroPluralo 1
            if {![$r hasclass ETPlSubstantivoartaMix]} {
                $r mixin add ETPlSubstantivoartaMix
            }
            $r distinguSubstantivanDifinilon
            if {[$r set kazo] ne "M" && [$r set kazo] ne "B" && [$r set kazo] ne ""} {
                $subrad set kazo [$r set kazo]
                [my selektu {end}] set kazo [$r set kazo]
                [my selektu {end 1}] distinguDifinilon $frazTraduko
            }
        }
    }
}
Class TAPl::ktempo -superclass {::TradukAstoKTempo ::TAPl}
@ ::TAPl::ktempo idemeta component EspPlTradukilo
Class TAPl::main -superclass {::TradukAstoMain ::TAPl}
@ ::TAPl::main idemeta component EspPlTradukilo
TAPl::main instproc preparuElementoPorKreuArbon {} {
    my transformuSubsupDePrononom
}
TAPl::main instproc reordigu {} {
    my instvar astoj parenco elemento
    if {[info exists elemento] && [$elemento funkcio] eq "subfrazo" && [my selektu {0 prenuAntauxElemento}] ne ""} {
        set unua [my selektu {prenuUnuan elemento}]
        if {$unua ne "" && ![$unua istype GP::Simbolo] && ![$unua estasVorto kaj]} {
            set komo [ETSenOrigina new -childof [my info parent] -traduko ,]
            my movuAlAbsPozicio $komo 0
        }
    }
    # Li vidis tion -> On to widzial
    set lobj [lindex $astoj end]
    if {[$lobj istype ETSimbolo]} {
        set lobj [lindex $astoj end-1]
    }
    if {$lobj ne "" && [$lobj exists elemento]} {
        set eobj [$lobj set elemento]
        if {([$eobj istype GP::TabloVorto] && [$eobj hasclass GP::Substantivo]) || [$eobj istype GP::PersonPronomo]} {
            set npos [expr {[lsearch $astoj $lobj]-1}]
            if {$npos>=1} {
                my movuAlAbsPozicio $lobj $npos
            }
        }
    }
    next
}
Class TAPl::nfvp -superclass ::TAPl
@ ::TAPl::nfvp idemeta component EspPlTradukilo
TAPl::nfvp instproc distinguDifinilon frazTraduko {
    my instvar elemento parenco
    set cverbo [$elemento prenuCentranVerbon]
    # mi vidis lin labori -> mi vidis lin, kiam li laboris.

    if {$cverbo ne "" && [lsearch {peti alvoki konvinki ĝoji igi domeĝi eviti vidi aŭskulti observi promesi rifuzi rezigni inviti ebligi pensi preti interesiĝi devigi} [$cverbo prenuBazanFormon]]>=0} {
        set rez [$elemento tranformuNFVPAlSubfrazo]
        if {$rez ne ""} {
            set cl [TradukAsto klasoPorAsto $rez pl]
            set elem [$cl new -childof [my info parent] -elemento $rez -parenco $parenco]
            $elem kreuArbon [my info parent]
            $parenco tausxuAstoj [self] $elem
            $elem distinguDifinilon $frazTraduko
            return
        }
    }
    next
    if {[my prenuFunkcioNomo] eq "subj"} {
        my instvar arto nombro
        set arto ni
        set nombro singularo
        set main [my trovuMainAston]
        if {$main ne ""} {
            $main set arto $arto
            $main set nombro $nombro
        }
    }
}
TAPl::nfvp instproc reordigu {} {
    my instvar astoj parenco elemento
    # Mi volas vidi tion -> Chce to widziec
    set lobj [lindex $astoj end]
    if {[$lobj istype ETSimbolo]} {
        set lobj [lindex $astoj end-1]
    }
    if {$lobj ne "" && [$lobj exists elemento]} {
        set eobj [$lobj set elemento]
        if {([$eobj istype GP::TabloVorto] && [$eobj hasclass GP::Substantivo]) || [$eobj istype GP::PersonPronomo]} {
            set npos [expr {[lsearch $astoj $lobj]-1}]
            if {$npos>=0} {
                my movuAlAbsPozicio $lobj $npos
            }
        }
    }
    next
}
Class TAPl::nomo -superclass {::TAPl ::ETPlSubstantivoartaMix}
@ ::TAPl::nomo idemeta component EspPlTradukilo
TAPl::nomo instproc distinguDifinilon frazTraduko {
    my instvar arto nombro persono
    if {[set u [my selektu {prenuUnuan elemento}]] ne "" && ([$u estasVirinaNomo] || [string first [string index [$u prenuBazanFormon] end] "aey"]>=0)} {
        set arto ze
    } else {
        set arto ms
    }
    set nombro singularo
    set persono 3
    my distinguSubstantivanDifinilon
    next
}
TAPl::nomo instproc traduku vortaro {
    my instvar kazo astoj arto
    next
    if {[info exists kazo] && $kazo ne "" && [llength $astoj]==2} {
        set u [[lindex $astoj 0] prenuRadiko]
        set v [$u prenuBazanFormon]
        if {[string length $v]>3} {
            $u traduko [PolaFleksio prenuSubstantivonLauxTipo $v [PolaFleksio divenuTiponDeSubstantivo $v] $kazo singularo]
            if {$kazo eq "B" && $arto eq "ms"} {
                $u traduko [$u traduko]a
            }
            set u [[lindex $astoj 1] prenuRadiko]
            set v [$u prenuBazanFormon]
            $u traduku $vortaro
            if {$arto eq "ze"} {
               set listo {ska cka}
               foreach l $listo {
                   set longo [string length $l]
                   incr longo -1
                   if {[string range $v end-$longo end] eq $l} {
                       $u traduko [PolaFleksio prenuSubstantivonLauxTipo $v 109 $kazo singularo]
                       break
                   }
               }
            } else {
               set listo {ik 12 ski 43 ak 7 yk 7 icz 7}
               foreach {l fgrupo} $listo {
                   set longo [string length $l]
                   incr longo -1
                   if {[string range $v end-$longo end] eq $l} {
                       $u traduko [PolaFleksio prenuSubstantivonLauxTipo $v $fgrupo $kazo singularo]
                       break
                   }
               }
            }
        }
    }
}
Class TAPl::np -superclass {::TradukAstoNp ::TAPl}
@ ::TAPl::np idemeta component EspPlTradukilo
TAPl::np instproc reordigu {} {
    my instvar astoj
    set rad [my prenuRadiko]
    if {$rad ne "" && [$rad istype ETPlSubstantivo]} {
        foreach a $astoj {
            if {[$a istype ETPlAdjektivo]} {
                if {[$a exists gramatiko] && ("def" in [$a set gramatiko] || "gen" in [$a set gramatiko])} {
                    # pensu pri "subsup"
                    # La klimata varmiĝo de planedo
                    set r [my prenuRadiko]
                    set p [$r parenco]
                    set i [lsearch [$p astoj] $r]
                    incr i
                    $p movuAlPozicio $a $i
                    break
                }
            }
        }
    }
}
Class TAPl::ppinf -superclass {::TradukAstoMain ::TAPl}
@ ::TAPl::ppinf idemeta component EspPlTradukilo
TAPl::ppinf instproc distinguDifinilon frazTraduko {
    my instvar astoj
    set ppelem [my selektu {prenuRadiko elemento}]
    if {[$ppelem estasVortoj {malgraŭ sen krom}]} {
        set verbo [my selektu {end prenuRadiko}]
        if {[$verbo istype ETPlVerbo]} {
            $verbo substantivigi D
        }
    }
    next
}
Class TAPl::subsup -superclass {::TradukAstoSubsup ::TAPl}
@ ::TAPl::subsup idemeta component EspPlTradukilo
TAPl::subsup instproc traduku vortaro {
    my instvar elemento astoj
    if {[info exists elemento] && [$elemento estasDato]} {
        [lindex $astoj end] traduku $vortaro
        set rad [my prenuRadiko]
        $rad set kazo B
        $rad set arto ms
        $rad set nombro singularo
        $rad traduku $vortaro
    } else {
        next
    }
}
@ Object ImportoIlo {
description {Helpa objekto kun programeroj por purigo kaj kompletigo de vortaro.
Gxi ne estas uzata dum normala rulado.}
}
Object ImportoIlo
@ ::ImportoIlo idemeta categoriesMethodsProcs {{importuVortoj kreuDeklinacjaTabloj kreuAdvAdjKomperativo leguSubstantivajFGrupoj leguVerbojFGrupoj leguVerbojFGrupoj2 leguVerbojFGrupojRoz leguCompAdj leguCompAdv leguHTMLTabloj importuVortaronDeJMemory} {kreuTablo sqlDemandoj testuFalsajPolVortoj testuEblajPolVortoj} testuDeklinacjaTabloj {montruFlegsStatistiko vortaroFremdSkriptoj vortaroCz2Pl vortaroSinonimojDeCz vortaroNekonatajRadikoj vortaroFremdSkriptoj2 vortaroSkriptoj vortaroKreuCzNekonataj} {sxhangxuVorboOrdo sercxuFGrupoPorVerboj changxuFGrupoPorDerivo sercxuNekonatajTradukoj sercxuFGrupoPorSubstantivoj} {autoKreuAdverboj sercxuElbajnAjdDeSubj sercxuElbajnEtoSubj} {sercxuNekonatajGramVerboj testuFGrupoPorVerboj testuFGrupoPorSubstantivoj importuBLPDeDosiero autoKreuVerboFGrupoj testuFGrupoPorSubstantivo importuFGrupojnDeDosiero importuNdkDkDeDosiero importuVerbojFGrupojnDeDosiero kreuDkVerbojDeNdk sercxuFGruponDeSimilaj kreuDkNdkEkzemplojn kreuDkVerbojDeNdkInfikso kreuNdkVerbojDk kreuNdkVerboDeDk divenuFGrupojPorSubstantivojDeKonataj sercxuFGrupoPorVerbojNova sxercxuAspektojPorVerboj} sercxuDubindajTradukoj}
@ ::ImportoIlo idemeta categoriesProcs {migration private tests vortaro-skriptoj datumaro-sxangxoj vortkreado pliricxigo-skriptoj kvalito-statistiko}
@ ::ImportoIlo idemeta component EspPlTradukilo
ImportoIlo proc autoKreuAdverboj {} {
    set sql "select traduko.id,traduko,d.derivo from traduko_pl t,derivo d,radiko r where r.id=d.radikoid and d.id=t.derivoid and d.typo='adverbo' and not exists (select t1.id from traduko_pl t1,derivo d1 where d1.id=t1.derivoid and d1.typo='adjektivo' and d1.radikoid=r.id)"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set pre {przy prze po zy na ob od wy we ze z w}
    while {[llength [set row [$query fetch]]]>0} {
        foreach {id traduko derivo} $row {}
    }
}
@ ImportoIlo proc autoKreuVerboFGrupoj {} {
description {skribto provas kopi konataj grupoj al ne konataj sed
samaj verboj

chodzic - przychodzic, przechodzic}
}
ImportoIlo proc autoKreuVerboFGrupoj {} {
    set sql "select t.id,t.fgrupo,t.traduko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='verbo'"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set rez ""
    set pre {przy prze po zy na o ob od wy we ze z w roz roze za do u pod {}}
    while {[llength [set row [$query fetch]]]>0} {
        foreach {id grupo vorto} $row {}
        if {[llength $vorto]>1} {
            set bvorto [lindex $vorto 0]
            set rez [$dbvortaro sxercxuRezListoPorTraduko $bvorto pl]
            foreach r $rez {
                array set rezArr $r
                if {[info exists rezArr(fgrupo)] && $rezArr(fgrupo) ne ""} {
                    puts "$vorto - $bvorto $rezArr(fgrupo)"
                    my changxuFGrupoPorDerivo $rezArr(fgrupo) $vorto Verbo
                    unset rezArr
                    break
                }
                unset rezArr
            }
            set uvorto $bvorto
            foreach p $pre {
                set l [string length $p]
                if {[string range $uvorto 0 [expr {$l-1}]] eq $p} {
                    set bvorto [string range $uvorto $l end]
                    set rez [$dbvortaro sxercxuRezListoPorTraduko $bvorto pl]
                    foreach r $rez {
                        array set rezArr $r
                        if {[info exists rezArr(fgrupo)] && $rezArr(fgrupo) ne ""} {
                            if {[llength $rezArr(fgrupo)]==1} {
                                my changxuFGrupoPorDerivo $rezArr(fgrupo) $vorto Verbo
                            } else {
                                set afgrupo $rezArr(fgrupo)
                                set ngrupo [lindex $afgrupo 0]
                                foreach k [lrange $afgrupo 1 end] {
                                    lappend ngrupo [list [lindex $k 0] $p[lindex $k 1]]
                                }
                                my changxuFGrupoPorDerivo $ngrupo $vorto Verbo
                            }
                            unset rezArr
                            break
                        }
                        unset rezArr
                    }
                }
            }
        } else {
            foreach p $pre {
                set l [string length $p]
                if {[string range $vorto 0 [expr {$l-1}]] eq $p} {
                    set bvorto [string range $vorto $l end]
                    set rez [$dbvortaro sxercxuRezListoPorTraduko $bvorto pl]
                    foreach r $rez {
                        array set rezArr $r
                        if {[info exists rezArr(fgrupo)] && $rezArr(fgrupo) ne ""} {
                            if {[llength $rezArr(fgrupo)]==1} {
                                my changxuFGrupoPorDerivo $rezArr(fgrupo) $vorto Verbo
                            } else {
                                set afgrupo $rezArr(fgrupo)
                                set ngrupo [lindex $afgrupo 0]
                                foreach k [lrange $afgrupo 1 end] {
                                    lappend ngrupo [list [lindex $k 0] $p[lindex $k 1]]
                                }
                                my changxuFGrupoPorDerivo $ngrupo $vorto Verbo
                            }
                            unset rezArr
                            break
                        }
                        unset rezArr
                    }

                }
            }
        }
    }
}
ImportoIlo proc changxuFGrupoPorDerivo {fgrupo ekz tipo {gramatiko {}} {force 0}} {
    set connection [SQLDBVortaro getVortaroConnection]
    set eblajGrupoj [concat [PolaFleksio prenuKonjIndeksoj] irr.]
    if {[lindex $fgrupo 0] ne "komp" && $tipo eq "verbo"} {
        if {[lsearch $eblajGrupoj [lindex $fgrupo 0]]<0} {
            puts " fgrupo ne konata $fgrupo cxe $ekz"
            return
        }
    }

    set sql "select t.id,fgrupo,t.gramatiko from traduko_pl t,derivo d where (traduko='$ekz' or traduko='$ekz się') and t.derivoid=d.id and d.typo='$tipo'"
    set found 0
    foreach l [$connection queryList $sql] {
        set found 1
        set id [lindex $l 0]
        set fagrupo [lindex $l 1]
        set agramatiko [lindex $l 2]
        if {$fgrupo ne "" && ($fagrupo eq "" || $force)} {
            puts "updating fgrupo $id - $ekz=$fgrupo"
            set qfgrupo [$connection escape $fgrupo]
            $connection execute "update traduko_pl set fgrupo='$qfgrupo' where id=$id"
        }
        if {$gramatiko ne "" && ($agramatiko eq "" || $force)} {
            puts "updating gramtiko $ekz=$gramatiko"
            set qfgrupo [$connection escape $gramatiko]
            $connection execute "update traduko_pl set gramatiko='$qfgrupo' where id=$id"
        }
    }
    if {$found == 0} {
        puts "$ekz estis ne trovita"
    }
}
ImportoIlo proc divenuFGrupojPorSubstantivoDeKonataj substantivo {
    set fgrupo [my divenuFGrupojPorSubstantivoDeKonatajBaza $substantivo]
    if {$fgrupo ne ""} {
        return $fgrupo
    }
    if {[string tolower $substantivo] ne $substantivo} {
        set fgrupo [my divenuFGrupojPorSubstantivoDeKonatajBaza [string tolower $substantivo]]
        if {$fgrupo ne ""} {
            return $fgrupo
        }
    }
    if {[regexp {^(pół|przed|pod|nad|przy)(.+)$} $substantivo _ pre vorto]} {
        set fgrupo [my divenuFGrupojPorSubstantivoDeKonatajBaza [string tolower $vorto]]
        if {$fgrupo ne ""} {
            return $fgrupo
        }
    }
}
ImportoIlo proc divenuFGrupojPorSubstantivoDeKonatajBaza substantivo {
     set connection [my getVortaroConnection]
     if {[llength $substantivo]>1} {
         set vorto [lindex $substantivo 0]
     } else {
         set vorto $substantivo
     }
     set rows [$connection queryList "select fgrupo,gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.traduko='$vorto' and length(fgrupo)>0"]
     foreach row $rows {
         if {[lindex $row 1] eq ""} {
             return [lindex $row 0]
         } else {
             return $row
         }
     }
     return
}
ImportoIlo proc divenuFGrupojPorSubstantivojDeKonataj {} {
    set sql "select t.traduko,t.fgrupo,d.derivo from traduko_pl t,derivo d where t.derivoid=d.id and (length(fgrupo)=0 or fgrupo is null) and d.derivo like '%o'"

    set rez ""
    # set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set progreso ""
    set connection [my getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    while {[llength [set row [$query fetch]]]>0} {
        update
        set overbo [lindex $row 0]
        set tfgrupo [lindex $row 1]
        set derivo [lindex $row 2]
        append rez "# $overbo $derivo\n"
        #append rez "#DBVortaro modifuTradukonDeVorto $derivo [list $overbo] {traduko [list [esp::grandskribi $overbo]]} pl\n"
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {[llength $overbo]>1} {
            set vorto [lindex $overbo 0]
        } else {
            set vorto $overbo
        }
        set fgrupo [my divenuFGrupojPorSubstantivoDeKonataj $vorto]
        if {$fgrupo ne ""} {
            puts "sxhangxu $overbo = $fgrupo"
            # my changxuFGrupoPorDerivo $fgrupo $overbo Substantivo
            if {[llength $fgrupo]==1} {
                append rez "DBVortaro modifuTradukonDeVorto $derivo [list $overbo] [list [list fgrupo $fgrupo]] pl\n"
            } else {
                append rez "DBVortaro modifuTradukonDeVorto $derivo [list $overbo] [list [list fgrupo [lindex $fgrupo 0] gramatiko [lindex $fgrupo 1]]] pl\n"
            }
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
    }
    return $rez
}
ImportoIlo proc elektuFGrupo {substantivo fgrupoj {senPluralo 0} {laPlejGranda 1}} {
    ide::lremoveAll fgrupoj {1 102 103 104 105 106 107}
    set kazoj {M D B C Ms N W}
    set nombroj {singularo pluralo}
    set uGrupoj [list]
    set listoj [list]
    set grupoNombro [list]
    # forigu grupoj kiu estas la samaj kiel la fruaj
    foreach fgrupo $fgrupoj {
        set listo [list]
        foreach nombro $nombroj {
            if {$senPluralo && $nombro eq "pluralo"} {
                continue
            }
            foreach kazo $kazoj {
                lappend listo [PolaFleksio prenuSubstantivonLauxTipo $substantivo $fgrupo $kazo $nombro]
            }
        }
        if {[lsearch $listoj $listo]<0} {
            lappend listoj $listo
            lappend uGrupoj $fgrupo
            lappend grupoNombro [list $fgrupo [llength [lsort -unique $listo]]]
        }
    }
    # eble elektu la grupon kun la ple granda nombro de diferencaj kazoj
    if {$laPlejGranda} {
        set grupoNombro [lsort -decreasing -integer -index 1 $grupoNombro]
        set uGrupoj [list [lindex $grupoNombro 0 0]]
        set max [lindex $grupoNombro 0 1]
        set i 1
        while {$i<[llength $grupoNombro] && $max==[lindex $grupoNombro $i 1]} {
            lappend uGrupoj [lindex $grupoNombro $i 0]
            incr i
        }
    }
    return $uGrupoj
}
ImportoIlo proc getVortaroConnection {} {
    set v [DBVortaro prenuVortaron]
    if {[$v hasclass SQLPrivataVortaro]} {
        $v pretiguLingvon pl
    }
    $v set connection
}
ImportoIlo proc importuBLPDeDosiero {} {
    set dosiero /home/artur/esperanto/pl_fontoj/slownik/fgrup.txt
    set f [open $dosiero r]
    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]

    set countOK 0
    while {[gets $f line]>=0} {
        update
        if {$progreso ne ""} {
           if {[$progreso isStopped]} {
               break
           }
        }
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} continue
        if {[string first " blp" $line]>0} {
            my changxuFGrupoPorDerivo {} [lindex $line 0] substantivo blp
        }
    }
    close $f

    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
    }
}
ImportoIlo proc importuFGrupojnDeDosiero {} {
    set dosiero /home/artur/esperanto/pl_fontoj/slownik/fgrup.txt

    set f [open $dosiero r]
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} continue
        set fgrupoArr([lindex $line 0]) [lrange $line 1 end]
    }
    array set transArr {
        m1I 8
        m2I 58
        m3I {69 69'}
        m1II {10 11}
        m2II 61
        m3II 72
        m1III 17
        m2III 62
        m3III {86 85 85* 85'}
        m1IV {3 5}
        m2IV 57
        m3IV {68 80 80'}
        m1V 1A
        żI {114 115}
        żII 122
        żIII {112 112' 112*}
        żIV {119 119' 119*}
        żm1IV {30}
        żm1II {37}
        żm1III {37}
        żm1I {30}
        żV 104
        żVI 122
        nI 89
        nII {97 97*}
        nIII {96 96' 96*}
        nIV 95
        nV 95
        nVI 101
    }


    set sql "select t.traduko,fgrupo,t.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='substantivo'"
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set i 0
    set rows [$query rows]
    set rezulto ""
    set countOK 0
    set countErr 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        set substantivo [lindex [lindex $row 0] 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set sub [lindex $substantivo 0]
        if {![info exists fgrupoArr($sub)]} {
            continue
            puts "ne konata $sub"
        }
        set disc $fgrupoArr($sub)
        set genro2 ""
        if {![regexp {([mżn])([IV]+)\s*(m[123])?} $disc _ genro grupo genro2]} {
            puts "ne rekonata $disc pro $sub"
            continue
        }
        if {$genro eq "m"} {
            set genro $genro2
        } elseif {$genro eq "ż" && $genro2 ne ""} {
            set genro $genro$genro2
        }
        set key $genro$grupo
        set fgrupoj $transArr($key)

        set ok 0
        foreach fgrupo $fgrupoj {
            set eraroj [my testuFGrupoPorSubstantivo $sub $fgrupo $gramatiko $spell]
            if {[llength $eraroj]>0} {
                # nothing yet
            } else {
                my changxuFGrupoPorDerivo $fgrupo $substantivo substantivo
                incr countOK
                set ok 1
                break
            }
        }
        if {!$ok} {
            puts "$sub $fgrupo - eraroj $eraroj"
            incr countErr
        }
        incr i
        after 50
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston "$rezulto\neraroj=$countErr ([expr round(100.0*$countErr/$i)]) ok=$countOK"
}
ImportoIlo proc importuKVortaro {} {
    set filetypes {{{Text Files} *.txt} {{All files} *}}
    set file [::IDE::Dialog getOpenFile $filetypes]
    if {$file eq ""} return
    set f [open $file r]
    set pagxo [list]
    set ret ""
    while 1 {
        set fino [gets $f line]
        if {$fino>=0 && ![regexp {\d+\s+WIMMER - ESPERANTO EN DEK LECIONOJ} $line]} {
            lappend pagxo [string trimleft $line]
            continue
        } else {
            set linioj [list]
            set cl 52
            foreach l $pagxo {
                if {[regexp {(.+\s{2,}).+} $l _ flanko]} {
                    set cl [string length $flanko]
                    incr cl -1
                    puts "trovita $cl $l"
                    break
                }
            }
            foreach l $pagxo {
                set l [string trimleft $l]
                lappend linioj [string trim [string range $l 0 $cl]]
            }
            foreach l $pagxo {
                set l [string trimleft $l]
                lappend linioj [string trim [string range $l [expr $cl+1] end]]
            }
            set tl ""
            foreach l $linioj {
                if {[regexp {^-\w-$} $l]} {
                    puts "ignoru $l"
                    if {$tl ne ""} {
                        append ret $tl \n
                    }
                } else {
                    if {[regexp {^.+ - .+$} $l]} {
                        if {$tl ne ""} {
                            append ret $tl \n
                        }
                        set tl $l
                    } else {
                        append tl " " $l
                    }
                }
            }
            if {$tl ne ""} {
                append ret $tl \n
            }
            set pagxo [list]
        }
        if {$fino<=0} break
    }
    close $f
    return $ret
}
ImportoIlo proc importuNdkDkDeDosiero {} {
    set dosiero /home/artur/esperanto/pl_fontoj/slownik/fgrup.txt

    set f [open $dosiero r]
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} continue
        if {[string first dk $line]<0} continue
        set fgrupoArr([lindex $line 0]) [lrange $line 1 end]
    }

    set sql "select t.traduko,fgrupo,t.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (t.gramatiko is null or t.gramatiko='') and d.typo='verbo'"

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set i 0
    set rows [$query rows]
    set rezulto ""

    while {[llength [set row [$query fetch]]]>0} {
        update
        set verbo [lindex $row 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set vorto [lindex $verbo 0]
        if {![info exists fgrupoArr($vorto)]} {
            continue
            puts "ne konata $vorto"
        }

        set disc $fgrupoArr($vorto)

        if {[string first ndk $disc]>=0} {
            set gramatiko ndk
        } elseif {[string first dk $disc]>=0} {
            set gramatiko dk
        }
        #puts "changxuFGrupoPorDerivo $fgrupo $verbo verbo $gramatiko"
        my changxuFGrupoPorDerivo $fgrupo $verbo verbo $gramatiko

        incr i
        after 50
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
ImportoIlo proc importuVerbojFGrupojnDeDosiero {} {
    set dosiero /home/artur/esperanto/pl_fontoj/slownik/fgrup.txt

    set f [open $dosiero r]
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} continue
        set fgrupoArr([lindex $line 0]) [lrange $line 1 end]
    }
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]

    set sql "select t.traduko,fgrupo,t.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='verbo'"

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set konatajGrupoj [PolaFleksio prenuKonjIndeksoj]

    set i 0
    set rows [$query rows]
    set rezulto ""
    set countOK 0
    set countErr 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        set verbo [lindex $row 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        puts "$row"
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set sub [lindex $verbo 0]
        if {![info exists fgrupoArr($sub)]} {
            puts "ne konata $sub"
            continue
        }
        set disc $fgrupoArr($sub)
        if {[string first ndk $disc]>=0} {
            set gramatiko ndk
        } else {
            set gramatiko dk
        }
        if {![regexp {[IVabc]+} $disc fgrupo]} {
            puts "ne rekonata $disc pro $sub"
            continue
        }
        if {[lsearch $konatajGrupoj $fgrupo]<0} {
            puts "grupo ne konata $fgrupo"
            continue
        }
        set ok 0
        set eraroj [my testuFGrupoPorVerbo $sub $fgrupo $gramatiko $spell]
        puts "test $sub $fgrupo - $eraroj"
        if {[llength $eraroj]>0} {
            puts "eraroj $sub $fgrupo - $eraroj"
        } else {
            puts "changxuFGrupoPorDerivo $fgrupo $verbo verbo"
            my changxuFGrupoPorDerivo $fgrupo $verbo verbo
            incr countOK
            set ok 1
            break
        }
        if {!$ok} {
            puts "$sub $fgrupo - eraroj $eraroj"
            incr countErr
        }
        incr i
        after 50
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
ImportoIlo proc importuVortaronDeJMemory {{dosiero {}}} {
    if {$dosiero eq ""} {
        set dosiero [IDE::Dialog getOpenFile  {{XML *.xml} {All *}}]
    }
    if {$dosiero eq ""} return
    set ofile [IDE::Dialog getSaveFile [file join [file dirname $dosiero] [file tail [file rootname $dosiero]].txt]]
    if {$ofile eq ""} return
    set f [open $dosiero r]
    fconfigure $f -encoding utf-8
    package require tdom
    set document [dom parse -simple [read $f]]
    close $f
    set out [open $ofile w]
    foreach node [[$document documentElement] selectNodes //Card] {
         puts $out "[$node getAttribute Frontside]; [$node getAttribute Backside]"
    }
    close $out
    $document delete
}
ImportoIlo proc importuVortoj {} {
    set connection [SQLDBVortaro getVortaroConnection]
    set file [IDE::Dialog getOpenFile]
    if {$file eq ""} return
    set h [open $file r]
    while {[gets $h linio]!=-1} {
        set tokenoj [split $linio \;]
        $connection insertRow polavorto {vorto id basaid arto fonto kredeco} $tokenoj
    }
    close $h
}
@ ImportoIlo proc kreuAdvAdjKomperativo {} {
description {TODO

select derivo from derivo d where derivo like "mal%a" and not exists (select derivoid from traduko_pl where derivoid=d.id);}
}
ImportoIlo proc kreuAdvAdjKomperativo {} {
    set adjadv {pełny	pełni	pełniejszy	pełno	pełniej
solidny	solidni	solidniejszy	solidnie	solidniej
młody	młodzi	młodszy	młodo	młodziej
ciekawy	ciekawi	ciekawszy	ciekawie	ciekawiej
blady	bladzi	bledszy	blado	bladziej
czerwony	czerwoni	czerwieńszy	czerwono	bardziej czerwono	
nerwowy	nerwowi	bardziej nerwowy	nerwowo	bardziej nerwowo
całkowity	całkowici	bardziej całkowity	całkowicie	bardziej całkowicie
nieustraszony	nieustraszeni	bardziej nieustraszony	nieustraszenie	bardziej nieustraszenie
nieogarniony	nieogarnieni	bardziej nieogarniony
gnieciony	gnieceni	bardziej gnieciony
ciepły	ciepli	cieplejszy	ciepło	cieplej
dorosły	dorośli	doroślejszy	dorośle	doroślej
miły	mili	milszy	miło	milej
trwały	trwali	trwalszy	trwale	trwalej
biały	biali	bielszy	biało	bielej
mały	mali	mniejszy	mało	mniej
zły	źli	gorszy	źle	gorzej
cały	cali	bardziej cały	cało	bardziej cało
zawiły	zawili	bardziej zawiły	zawile	bardziej zawile
wesoły	weseli	weselszy	wesoło	weselej
ostry	ostrzy	ostrzejszy	ostro	ostrzej
mądry	mądrzy	mądrzejszy	mądrze	mądrzej
stary	starzy	starszy	staro	starzej
dobry	dobrzy	lepszy	dobrze	lepiej
szary	szarzy	bardziej szary	szaro	bardziej szaro
cichy	cisi	cichszy	po cichu	ciszej
lichy	lisi	lichszy	licho	bardziej licho
dziki	dzicy	dzikszy	dziko	bardziej dziko
drogi	drodzy	droższy	drogo	drożej
szybki	szybcy	szybszy	szybko	szybciej
bliski	bliscy	bliższy	blisko	bliżej
wąski	wąscy	węższy	wąsko	węziej
krótki	krótcy	krótszy	krótko	krócej
prędki	prędcy	prędszy	prędko	prędzej
brzydki	brzydcy	brzydszy	brzydko	brzydziej
słodki	słodcy	słodszy	słodko	bardziej słodko
lekki	lekcy	lżejszy	lekko	lżej
wielki	wielcy	większy	wielce	więcej
cienki	ciency	cieńszy	cienko	cieniej	ciężki	ciężcy	cięższy	ciężko	ciężej
daleki	dalecy	dalszy	daleko	dalej
głęboki	głębocy	głębszy	głęboko	głębiej
wysoki	wysocy	wyższy	wysoko	wyżej
szeroki	szerocy	szerszy	szeroko	szerzej
gorzki	gorzcy	bardziej gorzki	gorzko	bardziej gorzko
polski	polscy	bardziej polski	po polsku
odpowiedni	odpowiedni	odpowiedniejszy	odpowiednio	odpowiedniej
tani	tani	tańszy	tanio	taniej
letni	letni	bardziej letni	letnio	bardziej letnio
żmii	żmii	bardziej żmii	żmijo	bardziej żmijo
głupi	głupi	głupszy	głupio	głupiej
małpi	małpi	bardziej małpi	małpio	bardziej małpio
diabli	diabli	 	diablo
świeży	świeży	świeższy	świeżo	bardziej świeżo
gorący	gorący	gorętszy	gorąco	goręcej
obcy	obcy	bardziej obcy	obco	bardziej obco
wrzący	wrzący	bardziej wrzący	wrząco	bardziej wrząco
czczy	czczy	bardziej czczy	na czczo
leżący	leżący	 	leżąc
boży	boży	bardziej boży	po bożemu
duży	duzi	większy	dużo	więcej
pieszy	piesi	 	pieszo}
    set dbvortaro [DBVortaro prenuDepVortaron]

    foreach l [split $adjadv \n] {
        foreach {adj adjp adjk adv advk} [split $l \t] {}
        set tlL [$dbvortaro sxercxuRezListoPorTraduko $adj pl]
        if {[llength $tlL]==0} {
            puts "ne konata $adj"
        }
        foreach tl $tlL {
            array set tlArr $tl
            set espAdv [string range $tlArr(vorto) 0 end-1]e
            set advListo [$dbvortaro sxercxuRezListo $espAdv pl]
            if {[llength $advListo]==0} {
                puts "ADV por $espAdv ne konata ($adv)"
                $dbvortaro importuTraduko pl $espAdv $adv
            }
        }
        if {$adjk ne "" && [lindex $adjk 0] ne "bardziej"} {
            foreach tl $tlL {
                array set tlArr $tl
                if {$tlArr(fgrupo) eq ""} {
                    puts "adjk $adj $adjk"
                    my changxuFGrupoPorDerivo [list komp $adjk] $adj Adjektivo
                }
            }
        }
        set tlL [$dbvortaro sxercxuRezListoPorTraduko $adv pl]
        if {$advk ne "" && [lindex $advk 0] ne "bardziej"} {
            foreach tl $tlL {
                array set tlArr $tl
                if {$tlArr(fgrupo) eq ""} {
                    puts "advk $adv $advk"
                    my changxuFGrupoPorDerivo [list komp $advk] $adv Adjektivo
                }
            }
        }

    }
}
ImportoIlo proc kreuDeklinacjaTabloj {} {
    set tablo ""
    foreach d [list deklin1.html deklin2.html deklin3.html] {
        set r [my leguHTMLTabloj [file join /home/artur/polski/polskagramatyka/ $d]]
        set t [lindex $r 0]
        foreach arto $t {
            append tablo "  lappend dekltablo [list $arto]\n"
        }
    }
    return $tablo
}
ImportoIlo proc kreuDkNdkEkzemplojn {} {
    set sql "select traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' and (t.gramatiko is null or t.gramatiko = '')"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set ret ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row traduko derivo fgrupo
        append ret "DBVortaro importuTraduko pl $derivo [list $traduko] {fgrupo ndk}\n"
    }
    return $ret
}
ImportoIlo proc kreuDkVerbojDeNdk {} {
    set sql "select traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' and t.gramatiko='ndk' and not exists (select t1.id from traduko_pl t1,derivo d1 where d1.id=t1.derivoid and d1.typo='verbo' and t1.gramatiko = 'dk' and d.id=d1.id)"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set ret ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row traduko derivo fgrupo
        if {[lindex $traduko 0] in {być mieć}} {
            continue
        }
        foreach prefix {s za z po} {
            set nvorto $prefix[lindex $traduko 0]
            if {[$spell estasVorto $nvorto]==2} {
                if {[llength $fgrupo]>1} {
                    set nfgrupo [list [lindex $fgrupo 0]]
                    foreach v [lrange $fgrupo 1 end] {
                        lappend nfgrupo [list [lindex $v 0] $prefix[lindex $v 1]]
                    }
                } else {
                    set nfgrupo $fgrupo
                }
                set jamEkzistas 0
                set nvorto [join [concat $nvorto {*}[lrange $traduko 1 end]]]
                foreach d [$dbvortaro sxercxuRezListoPorTraduko $traduko pl] {
                    if {[dict get $d traduko] eq $nvorto} {
                        append ret "# jam ekzistas $derivo $traduko
                        set jamEkzistas 1
                        break
                    }
                }
                if {!$jamEkzistas} {
                    append ret "DBVortaro importuTraduko pl $derivo [list $nvorto] {} dk [list $nfgrupo]\n"
                }
            }
        }
    }
    return $ret
}
ImportoIlo proc kreuDkVerbojDeNdkInfikso {} {
    set sql "select traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' and t.gramatiko='ndk' and not exists (select t1.id from traduko_pl t1,derivo d1 where d1.id=t1.derivoid and d1.typo='verbo' and t1.gramatiko = 'dk%' and d.id=d1.id)"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set ret ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row traduko derivo fgrupo
        set verbo [lindex $traduko 0]
        if {$verbo in {havi esti}} continue
        set nvortoj [list]
        append ret "# $verbo\n"
        if {[string range $verbo end-3 end] eq "niać"} {
            lappend nvortoj [string range $verbo 0 end-3]ić
        } elseif {[string range $verbo end-5 end] eq "amiać"} {
            lappend nvortoj [string range $verbo 0 end-5]omić
        } elseif {[string range $verbo end-2 end] eq "iać"} {
            lappend nvortoj [string range $verbo 0 end-3]ić
        } elseif {[string range $verbo end-3 end] eq "ować"} {
            lappend nvortoj [string range $verbo 0 end-4]ić
        } elseif {[string range $verbo end-3 end] eq "uwać"} {
            lappend nvortoj [string range $verbo 0 end-4]uć
        } elseif {[string range $verbo end-3 end] eq "ować"} {
            lappend nvortoj [string range $verbo 0 end-4]ić
        } elseif {[string range $verbo end-3 end] eq "ewać"} {
            lappend nvortoj [string range $verbo 0 end-4]ać
        } elseif {[string range $verbo end-3 end] eq "awać"} {
            lappend nvortoj [string range $verbo 0 end-4]ać
        } elseif {[string range $verbo end-1 end] eq "ać"} {
            lappend nvortoj [string range $verbo 0 end-2]nąć
            lappend nvortoj [string range $verbo 0 end-2]yć
            lappend nvortoj [string range $verbo 0 end-2]ić
            lappend nvortoj [string range $verbo 0 end-2]nyć
        } else {
            continue
        }
        
        foreach nvorto $nvortoj {
            if {[$spell estasVorto $nvorto]==2} {
                set nfgrupo [my sercxuFGrupoPorVerbo $nvorto]
                set jamEkzistas 0
                set nvorto [join [concat $nvorto {*}[lrange $traduko 1 end]]]
                foreach d [$dbvortaro sxercxuRezListoPorTraduko $traduko pl] {
                    if {[dict get $d traduko] eq $nvorto} {
                        append ret "# jam ekzistas $derivo $traduko
                        set jamEkzistas 1
                        break
                    }
                }
                if {!$jamEkzistas} {
                    append ret "DBVortaro importuTraduko pl $derivo [list $nvorto] {} dk [list $nfgrupo]\n"
                }
            }
        }
    }
    return $ret
}
ImportoIlo proc kreuListoMankantajOftajAdjektivoj {} {
    set frek {/home/artur/esperanto/pl_fontoj/lista_frekwencyjna.txt}
    set sub {/home/artur/esperanto/pl_fontoj/przymiotniki.txt}
    set frekFile [open $frek r]
    set i 0
    while {[gets $frekFile line]>=0} {
        if {[regexp {^(\S{3,})=(\d+)$} $line _ vorto nombro]} {
            set frekArr($vorto) $nombro
        }
        incr i
        if {$i%5000==0} {
            puts "legu frek $i"
        }
    }
    close $frekFile

        set f [open $sub r]
        set i 0
        while {[gets $f line]>=0} {
            if {[regexp {^(\S+)=(\S+)$} $line _ bvorto vorto]} {
                if {![catch {set frekArr($vorto)} frek]} {
                    if {[catch {incr bfrekArr($bvorto) $frek}]} {
                        set bfrekArr($bvorto) $frek
                    }
                }
            }
            incr i
            if {$i%5000==0} {
                puts "legu subst $i"
            }
        }
        close $f

    set dbvortaro [DBVortaro prenuDepVortaron]

    set i 0
    for {set sid [array startsearch bfrekArr]} {[array anymore bfrekArr $sid]} {} {
        set vorto [array nextelement bfrekArr $sid]
        set nombro $bfrekArr($vorto)
        incr i
        if {$i%200==0} {
            puts "testu $i"
        }
        if 1 {
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko $vorto pl]]>0} {
            continue
        }
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko "$vorto *" pl]]>0} {
            continue
        }
        }
        lappend listo [list $vorto $nombro]
    }

    set out [open /home/artur/esperanto/pl_fontoj/mank-adj-listo.txt w]
    foreach v [lsort -index 1 -decreasing -integer $listo] {
        puts $out "[lindex $v 0] - [lindex $v 1]"
    }
    close $out
}
ImportoIlo proc kreuListoMankantajOftajSubstantivoj {} {
    set frek {/home/artur/esperanto/pl_fontoj/lista_frekwencyjna.txt}
    set sub {/home/artur/esperanto/pl_fontoj/rzeczowniki.txt}
    set frekFile [open $frek r]
    set i 0
    while {[gets $frekFile line]>=0} {
        if {[regexp {^(\S{3,})=(\d+)$} $line _ vorto nombro]} {
            set frekArr($vorto) $nombro
        }
        incr i
        if {$i%5000==0} {
            puts "legu frek $i"
        }
    }
    close $frekFile

        set f [open $sub r]
        set i 0
        while {[gets $f line]>=0} {
            if {[regexp {^(\S+)=(\S+)$} $line _ bvorto vorto]} {
                if {![catch {set frekArr($vorto)} frek]} {
                    if {[catch {incr bfrekArr($bvorto) $frek}]} {
                        set bfrekArr($bvorto) $frek
                    }
                }
            }
            incr i
            if {$i%5000==0} {
                puts "legu subst $i"
            }
        }
        close $f

    set dbvortaro [DBVortaro prenuDepVortaron]

    set i 0
    for {set sid [array startsearch bfrekArr]} {[array anymore bfrekArr $sid]} {} {
        set vorto [array nextelement bfrekArr $sid]
        set nombro $bfrekArr($vorto)
        incr i
        if {$i%200==0} {
            puts "testu $i"
        }
        if 1 {
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko $vorto pl]]>0} {
            continue
        }
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko "$vorto *" pl]]>0} {
            continue
        }
        }
        lappend listo [list $vorto $nombro]
    }

    set out [open /home/artur/esperanto/pl_fontoj/mank-subst-listo.txt w]
    foreach v [lsort -index 1 -decreasing -integer $listo] {
        puts $out "[lindex $v 0] - [lindex $v 1]"
    }
    close $out
}
ImportoIlo proc kreuListoMankantajOftajVerboj {} {
    set frek {/home/artur/esperanto/pl_fontoj/lista_frekwencyjna.txt}
    set v1 {/home/artur/esperanto/pl_fontoj/czas-pol-mn.txt}
    set v2 {/home/artur/esperanto/pl_fontoj/czas-pol-mn.txt}
    set frekFile [open $frek r]
    set i 0
    while {[gets $frekFile line]>=0} {
        if {[regexp {^(\S{3,})=(\d+)$} $line _ vorto nombro]} {
            set frekArr($vorto) $nombro
        }
        incr i
        if {$i%5000==0} {
            puts "legu frek $i"
        }
    }
    close $frekFile

    foreach fnomo [list $v1 $v2] {
        set f [open $v1 r]
        set i 0
        while {[gets $f line]>=0} {
            if {[regexp {^(\S+)=(\S+)$} $line _ vorto bvorto]} {
                if {![catch {set frekArr($vorto)} frek]} {
                    if {[catch {incr bfrekArr($bvorto) $frek}]} {
                        set bfrekArr($bvorto) $frek
                    }
                }
            }
            incr i
            if {$i%5000==0} {
                puts "legu $fnomo $i"
            }
        }
        close $f
    }

    set dbvortaro [DBVortaro prenuDepVortaron]

    set i 0
    for {set sid [array startsearch bfrekArr]} {[array anymore bfrekArr $sid]} {} {
        set vorto [array nextelement bfrekArr $sid]
        set nombro $bfrekArr($vorto)
        incr i
        if {$i%200==0} {
            puts "testu $i"
        }
        if 1 {
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko $vorto pl]]>0} {
            continue
        }
        if {[llength [$dbvortaro sxercxuRezListoPorTraduko "$vorto *" pl]]>0} {
            continue
        }
        }
        lappend listo [list $vorto $nombro]
    }

    set out [open /home/artur/esperanto/pl_fontoj/mank-verb-listo.txt w]
    foreach v [lsort -index 1 -decreasing -integer $listo] {
        puts $out "[lindex $v 0] - [lindex $v 1]"
    }
    close $out
}
ImportoIlo proc kreuNdkVerboDeDk verbo {
    set kandidatoj [list]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    if {[string match *oić $verbo]} {
        # wykroić
        lappend kandidatoj [string range $verbo 0 end-3]ajać
    }
    if {[string match *eić $verbo]} {
        # wkjeić
        lappend kandidatoj [string range $verbo 0 end-3]ejać
    }
    if {[regexp {o([bpmn])ić$} $verbo _ k]} {
        # wydzwonić, wytropić
        lappend kandidatoj [string range $verbo 0 end-4]a${k}iać
    }
    if {[regexp {o([w])ić$} $verbo _ k]} {
        # zniewolić
        lappend kandidatoj [string range $verbo 0 end-4]a${k}ać
    }
    if {[regexp {o([w])ieć$} $verbo _ k]} {
        # ozdrowieć
        lappend kandidatoj [string range $verbo 0 end-5]a${k}iać
    }
    if {[string match *ić $verbo]} {
        # nasadzić
        lappend kandidatoj [string range $verbo 0 end-2]ać
        # kupić
        lappend kandidatoj [string range $verbo 0 end-2]ować
        # wygrabić
        lappend kandidatoj [string range $verbo 0 end-2]iać
    }
    if {[string match *ścić $verbo]} {
        # wyczyścić
        lappend kandidatoj [string range $verbo 0 end-4]szczać
    }
    if {[string match *nąć $verbo]} {
        # przepłynąć
        lappend kandidatoj [string range $verbo 0 end-3]wać
        # odwyknąć
        lappend kandidatoj [string range $verbo 0 end-3]ać
    }
    if {[string match *ąć $verbo]} {
        # zacząć
        lappend kandidatoj [string range $verbo 0 end-2]ynać
        # wypłynąć
        lappend kandidatoj [string range $verbo 0 end-2]ywać
        # podsłuchać
        lappend kandidatoj [string range $verbo 0 end-2]iwać
        # ogarnąć
        lappend kandidatoj [string range $verbo 0 end-2]iać
    }
    if {[string match *ać $verbo]} {
        # zacząć
        lappend kandidatoj [string range $verbo 0 end-2]ywać
        # wyrzygać
        lappend kandidatoj [string range $verbo 0 end-2]iwać
        # poznać
        lappend kandidatoj [string range $verbo 0 end-2]awać
        # wywiać
        lappend kandidatoj [string range $verbo 0 end-2]ewać
    }
    if {[string match *eć $verbo]} {
        # zamyśleć
        lappend kandidatoj [string range $verbo 0 end-2]ać
    }
    if {[string match *yć $verbo]} {
        # zażyczyć
        lappend kandidatoj [string range $verbo 0 end-2]ać
        # wymyć
        lappend kandidatoj [string range $verbo 0 end-1]wać
    }
    if {[string match *uć $verbo]} {
        # poczuć
        lappend kandidatoj [string range $verbo 0 end-1]wać
    }
    if {[string match *ieć $verbo]} {
        # wybrzmieć
        lappend kandidatoj [string range $verbo 0 end-1]wać
    }
    if {[string match *zić $verbo]} {
        # zarazić
        lappend kandidatoj [string range $verbo 0 end-3]żać
    }
    if {[string match *źć $verbo]} {
        # wygryźć
        lappend kandidatoj [string range $verbo 0 end-2]zać
    }
    if {[string match *czeć $verbo]} {
        # wykrzyczeć
        lappend kandidatoj [string range $verbo 0 end-4]kiwać
    }
    if 0 {
    foreach prefix {s za z po u roz} {
        if {[regexp "^${prefix}(.+)" $verbo _ kerno]} {
            lappend kandidatoj $kerno
        }
    }
    }

    set rezultoj [list]
    foreach k $kandidatoj {
        if {[$spell estasVorto $k]==2} {
            lappend rezultoj $k
        }
    }
    return $rezultoj
}
ImportoIlo proc kreuNdkVerbojDk {} {
    set sql "select traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' and t.gramatiko='dk' and not exists (select t1.id from traduko_pl t1,derivo d1 where d1.id=t1.derivoid and d1.typo='verbo' and (t1.gramatiko = 'ndk%' or t1.gramatiko='ndk') and d.id=d1.id)"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set ret ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row traduko derivo fgrupo
        if {[string match ek* $derivo] || [string match el* $derivo]} {
            continue
        }
        if {[lindex $traduko 0] in {być mieć}} {
            continue
        }
        set ndkj [my kreuNdkVerboDeDk [lindex $traduko 0]]
        if {[llength $ndkj]>1} {
            append ret "# ! multaj ebloj\n"
        }
        foreach k $ndkj {
            set fgrupo [my sercxuFGrupoPorVerboKompleksa $k]
            append ret "# $traduko\n"
            set nvorto [concat $k [lrange $traduko 1 end]]
            append ret "DBVortaro importuTraduko pl $derivo [list $nvorto] {} ndk [list $fgrupo]\n"
        }
        if {[llength $ndkj]==0} {
            append ret "# ne trovita por $traduko - $derivo\n"
        }
    }
    return $ret
}
ImportoIlo proc kreuPlEkzemploj {} {
    set fnomo "10lecionoj_frazekzemploj.txt"
    set f [open $fnomo r]
    set fout [open "10lecionoj_frazekzemploj.xml" w]
    puts $fout "<tradukekzemploj>"
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq ""} continue
        if {[regexp {^(.+)([.!?])(.+)\2} $line _ eo sig pl]} {
            puts $fout "<ekzemplo>
    <origina>${eo}$sig</origina>
    <traduko lang=\"pl\">${pl}$sig</traduko>
    </ekzemplo>"
        } else {
            puts "ne rekonata $line"
        }
    }
    puts $fout "</tradukekzemploj>"
    close $fout
    close $f
}
ImportoIlo proc kreuTablo {} {
    set connection [SQLDBVortaro getVortaroConnection]
    set kreostmt "CREATE TABLE polavorto (
  id int primary key,
  basaid int,
  vorto varchar(200),
  arto varchar(2),
  fonto varchar(2),
  kredeco int,
  index (vorto),
  index (basaid))"
    $connection execute $kreostmt
}
ImportoIlo proc leguCompAdj {} {
    set file [::IDE::Dialog getOpenFile]
    if {$file eq ""} return
    set vortaro [DBVortaro prenuDepVortaron]
    set f [open $file r]
    fconfigure $f -encoding iso8859-2
    set rez ""
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} contine
        set compVorto [lindex $line 0]
        set vorto [PolaFleksio prenuBasanAdjDeComp $compVorto]
        set trovis 0
        foreach t [$vortaro sxercxuRezListoPorTraduko $vorto pl] {
            set trovis 1
            unset -nocomplain tradArr
            array set tradArr $t
            if {[string index $tradArr(vorto) end] ne "a" || $tradArr(fgrupo) ne ""} {
                continue
            }
            append rez "DBVortaro modifuTradukonDeVorto $tradArr(vorto) $vorto [list [list fgrupo [list [list komp $compVorto]]]] pl\n"
        }
        if {!$trovis} {
            append rez "  # $compVorto - $vorto\n"
        }
    }
    close $f
    return $rez
}
ImportoIlo proc leguCompAdv {} {
    set file [::IDE::Dialog getOpenFile]
    if {$file eq ""} return
    set vortaro [DBVortaro prenuDepVortaron]
    set f [open $file r]
    fconfigure $f -encoding iso8859-2
    set rez ""
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} contine
        set vorto [lindex $line 1]
        foreach t [$vortaro sxercxuRezListoPorTraduko $vorto pl] {
            unset -nocomplain tradArr
            array set tradArr $t
            if {[string index $tradArr(vorto) end] ne "e" || $tradArr(fgrupo) ne ""} {
                continue
            }
            append rez "DBVortaro modifuTradukonDeVorto $tradArr(vorto) $vorto [list [list fgrupo [list [list komp [lindex $line 0]]]]] pl\n"
        }
    }
    close $f
    return $rez
}
ImportoIlo proc leguHTMLTabloj {{file {}}} {
    package require tdom
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    package require tdom
    fconfigure $f -encoding iso8859-2
    set document [dom parse -html [read $f]]
    close $f
    puts $document
    set tableNodes [lrange [[$document documentElement] selectNodes */table/tbody] 2 end]
    if {[llength $tableNodes]==0} {
        set tableNodes [lrange [[$document documentElement] selectNodes */table] 1 end]
    }
    set alltable [list]
    set alltable_ekz [list]
    # M D C B N Ms W Mx
    set kazoj [list M D C B N Ms W Mx]
    foreach km {M MB MBW D C B DB MW N Ms Mx W CMs} val {M {M B} {M B W} D C B {D B} {M W} N Ms Mx W {C Ms}} {
        set kazojMallong($km) $val
    }
    foreach table $tableNodes {
        set knowtyp 0
        if {[llength [$table selectNodes tr]]<6} continue
        set types [list]
        foreach column [$table selectNodes tr] {
            if {!$knowtyp} {
                foreach typ [$column selectNodes th] {
                    set typname [[$typ firstChild] nodeValue]
                    if {$typname eq "model"} continue
                    if {![string is integer [string index $typname 0]]} continue
                    if {[lsearch -exact $types $typname]>=0} {
                        set typname multfoje
                    }
                    lappend types $typname
                    set $typname [list M D C B N Ms W M D C B N Ms W Mx]
                    set ${typname}_ekz [list M D C B N Ms W M D C B N Ms W Mx]
                }
                set knowtyp 1
            } else {
                # legu la kazon por linio
                set kazo ""
                foreach onode [$column selectNodes th] {
                    set kazo [[$onode firstChild] nodeValue]
                    if {[string index $kazo end] ne "."} {
                        break
                    }
                    if {$kazo eq "lp."} {
                        set nombro singularo
                    } elseif {$kazo eq "lm."} {
                        set nombro pluralo
                    }
                    set kazo ""
                }
                set x 0
                if {$kazo eq ""} {
                    # eraro !
                    #my halt
                }
                foreach onode [$column selectNodes td] {
                    set type [lindex $types $x]
                    if {$type eq ""} continue
                    incr x
                    set knode [lindex [$onode selectNodes {span[@class="klrd"]}] 0]
                    set koncowka [list]
                    if {$knode eq "" || [$knode firstChild] eq ""} {
                        lappend koncowka [list]
                    } else {
                        lappend koncowka [[$knode firstChild] nodeValue]
                    }
                    set knode [lindex [$onode selectNodes {span[@class="klbl"]}] 0]
                    if {$knode eq "" || [$knode firstChild] eq ""} {
                        # nothing
                    } else {
                        # lappend koncowka [[$knode firstChild] nodeValue]
                    }
                    set wyraz ""
                    foreach t [$onode childNodes] {
                        if {[$t nodeType] eq "TEXT_NODE"} {
                            append wyraz [$t nodeValue]
                        } else {
                            append wyraz [string trim [$t text]]
                        }
                    }
                    foreach kj $kazojMallong($kazo) {
                        set  i [lsearch $kazoj $kj]
                        if {$nombro eq "pluralo"} {
                            incr i 7
                        }
                        lset $type $i $koncowka
                        lset ${type}_ekz $i [string trim $wyraz]
                    }
                }
            }
        }
        foreach typ $types {
            if {$typ eq "multfoje"} continue
            lappend alltable [linsert [set $typ] 0 $typ]
            lappend alltable_ekz [linsert [set ${typ}_ekz] 0 $typ]
        }
    }
    $document delete
    return [list $alltable $alltable_ekz]
}
ImportoIlo proc leguSubstantivajFGrupoj {{file /home/artur/polski/polskagramatyka/deklin4.html}} {
    package require tdom
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    package require tdom
    fconfigure $f -encoding iso8859-2
    set document [dom parse -html [read $f]]
    close $f
    set dbvortaro [SQLDBVortaro getSQLDBVortaron]
    set connection [SQLDBVortaro getVortaroConnection]
    foreach tNode [[$document documentElement] selectNodes */table/tbody] {
        set fcount 0
        if {![[$tNode parentNode] hasAttribute border] || [[$tNode parentNode] getAttribute border] eq "0"} { continue }
        foreach trNode [$tNode selectNodes tr] {
            if {$fcount==0} {
                set fgrupoNode [lindex [$trNode selectNodes {th[1]}] 0]
                set fgrupo [[$fgrupoNode firstChild] nodeValue]
                set fcount [$fgrupoNode getAttribute rowspan 1]
            }
            set ekzNode [lindex [$trNode selectNodes {td[1]}] 0]
            set ekzemploj [$ekzNode text]
            foreach ekz [split $ekzemploj ,] {
                set ekz [string trim $ekz]
                my changxuFGrupoPorDerivo $fgrupo $ekz Substantivo
            }
            incr fcount -1
        }
    }
    $document delete
    return
}
ImportoIlo proc leguVerbojFGrupoj {{file /home/artur/polski/polskagramatyka/czasowniki.html}} {
    package require tdom
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    package require tdom
    fconfigure $f -encoding iso8859-2
    set document [dom parse -html [read $f]]
    close $f
    set dbvortaro [SQLDBVortaro getSQLDBVortaron]
    set connection [SQLDBVortaro getVortaroConnection]
    set eblajGrupoj [PolaFleksio prenuKonjIndeksoj]
    foreach tNode [[$document documentElement] selectNodes */table/tbody] {
        set fcount 0
        foreach trNode [$tNode selectNodes tr] {
            set tdNodes [$trNode selectNodes td]
            if {[llength $tdNodes]!=15} continue

            set fgrupoNode [lindex $tdNodes 0]
            set fgrupo [[$fgrupoNode firstChild] nodeValue]
            set fgrupo [string trim [lindex [split $fgrupo ,] 0]]
            regsub -- {-t} $fgrupo {} fgrupo
            regsub -- {-0} $fgrupo {} fgrupo
            if {$fgrupo eq "irr."} continue

            set ekzNode [lindex $tdNodes 5]
            set ekz [string map {* {} ® {}} [$ekzNode text]]
            set ekz [string trim [lindex [split $ekz ,] 0]]

            foreach {simbolo pos persono tempo nombro arto} {
                1lp 6 1 as singularo mn
                3lp 7 3 as singularo mn
                p3lp 9 3 is singularo mn
                p3lm 10 3 is pluralo mn
            } {
                set fekz [string map {* {} ® {} ™ {}} [[lindex $tdNodes $pos] text]]
                set fekz [string trim [lindex [split $fekz ,] 0]]
                if {[PolaFleksio prenuVerbon $ekz $fgrupo $persono $arto $nombro $tempo] ne $fekz} {
                    lappend fgrupo [list $simbolo $fekz]
                }
            }
            # puts "verbo $ekz $fgrupo"
            my changxuFGrupoPorDerivo $fgrupo $ekz Verbo {} 1
        }
    }
    $document delete
    return
}
ImportoIlo proc leguVerbojFGrupoj2 {{file /home/artur/polski/polskagramatyka/koniug1.html}} {
    package require tdom
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    package require tdom
    fconfigure $f -encoding iso8859-2
    set document [dom parse -html [read $f]]
    close $f
    set dbvortaro [SQLDBVortaro getSQLDBVortaron]
    set connection [SQLDBVortaro getVortaroConnection]
    set eblajGrupoj [PolaFleksio prenuKonjIndeksoj]
    foreach tNode [[$document documentElement] selectNodes */table/tbody] {
        set fcount 0
        foreach trNode [$tNode selectNodes tr] {
            set thNodes [$trNode selectNodes th]
            set tdNodes [$trNode selectNodes td]
            if {[llength $thNodes]==3} {
                set fgrupo [[[lindex $thNodes 0] firstChild] nodeValue]
            } elseif {[llength $thNodes]!=0} {
                continue
            }
            if {[llength $tdNodes]!=1} {
                continue
            }
            set ekzNode [lindex $tdNodes 0]
            foreach supNode [$ekzNode selectNodes sup] {
                [$supNode parentNode] removeChild $supNode
            }
            set ekzemploj [$ekzNode text]
            set gramNode [lindex [$ekzNode selectNodes i] 0]
            if {$gramNode eq ""} {
                continue
            } else {
                set gramatiko [[$gramNode firstChild] nodeValue]
            }
            set ekzemploj [lindex [split $ekzemploj :] 1]
            foreach ekz [split $ekzemploj ,] {
                set ekz [lindex [split $ekz ~] 0]
                set ekz [string trim $ekz]
                regsub -all {\(.+\)} $ekz "" ekz
                if {$ekz eq "~"} continue
                # puts "ekz $ekz fgrupo=$fgrupo gramatiko=$gramatiko"
                my changxuFGrupoPorDerivo $fgrupo $ekz Verbo
            }
        }
    }
    $document delete
    return
}
ImportoIlo proc leguVerbojFGrupojRoz {{file /home/artur/polski/polskagramatyka/czasowniki.html}} {
    package require tdom
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    package require tdom
    fconfigure $f -encoding iso8859-2
    set document [dom parse -html [read $f]]
    close $f
    set dbvortaro [SQLDBVortaro getSQLDBVortaron]
    set connection [SQLDBVortaro getVortaroConnection]
    set eblajGrupoj [PolaFleksio prenuKonjIndeksoj]
    foreach tNode [[$document documentElement] selectNodes */table/tbody] {
        set fcount 0
        foreach trNode [$tNode selectNodes tr] {
            set tdNodes [$trNode selectNodes td]
            if {[llength $tdNodes]!=15} continue

            set fgrupoNode [lindex $tdNodes 0]
            set fgrupo [[$fgrupoNode firstChild] nodeValue]
            set fgrupo [string trim [lindex [split $fgrupo ,] 0]]
            regsub -- {-t} $fgrupo {} fgrupo
            regsub -- {-0} $fgrupo {} fgrupo
            if {$fgrupo eq "irr."} continue

            set ekzNode [lindex $tdNodes 5]
            set ekz [string map {* {} ® {}} [$ekzNode text]]
            set ekz [string trim [lindex [split $ekz ,] 0]]

            foreach {simbolo pos persono tempo nombro arto} {
                roz 8 3 u singularo mn
            } {
                set fekz [string map {* {} ® {} ™ {}} [[lindex $tdNodes $pos] text]]
                set fekz [string trim [lindex [split $fekz ,] 0]]
                set listo [$dbvortaro sxercxuRezListoPorTraduko $ekz pl]
                if {[llength $listo]==0} {
                    puts "verbo $ekz ne trovita"
                    continue
                }
                array set attrArr [lindex $listo 0]
                if {[string trim $fekz] eq "" || $fekz eq " "} continue
                if {[string index $attrArr(vorto) end] ne "i"} {
                    continue
                }
                if {$attrArr(fgrupo) eq ""} {
                    set attrArr(fgrupo) [PolaFleksio sxercxuFGrupoPorVerbo $ekz]
                }
                if {[set ord [PolaFleksio prenuVerbon $ekz $attrArr(fgrupo) $persono $arto $nombro $tempo]] ne $fekz} {
                    if {[string index $ord end] eq "?"} {
                        continue
                    }
                    puts "bezonas $ekz - ordono '$fekz' estas $ord - [concat $attrArr(fgrupo) [list [list roz $fekz]]]"
                    #my changxuFGrupoPorDerivo [concat $attrArr(fgrupo) [list [list roz $fekz]]] $ekz Verbo {} 1
                }
            }
        }
    }
    $document delete
    return
}
ImportoIlo proc montruFlegsStatistiko {} {
    set connection [SQLDBVortaro getVortaroConnection]
    set rez ""
    set sql "select count(t.id) from traduko_pl t,derivo d where t.derivoid=d.id and d.typo='substantivo'and t.fgrupo is null"
    append rez "substantivoj sen fgrupo : [$connection queryList $sql]\n"
    set sql "select count(t.id) from traduko_pl t,derivo d where t.derivoid=d.id and d.typo='substantivo'and t.fgrupo is not null"
    append rez "substantivoj kun fgrupo : [$connection queryList $sql]\n"

    set sql "select count(t.id) from traduko_pl t,derivo d where t.derivoid=d.id and d.typo='verbo'and t.fgrupo is null"
    append rez "verboj sen fgrupo : [$connection queryList $sql]\n"
    set sql "select count(t.id) from traduko_pl t,derivo d where t.derivoid=d.id and d.typo='verbo'and t.fgrupo is not null"
    append rez "verboj kun fgrupo : [$connection queryList $sql]\n"

    IDE::ResultBrowser newBrowser $rez
}
ImportoIlo proc prenuArtoPorSubstantivo {espvorto plvorto} {
    set vortaro [DBVortaro prenuVortaron]
    foreach t [$vortaro sxercxuRezListo $espvorto pl] {
        if {[set fgrupo [dict get $t fgrupo]] ne ""} {
            return [PolaFleksio prenuArtoDeTipo [lindex $fgrupo 0]]
        }
    }
    foreach t [$vortaro sxercxuRezListo $espvorto en] {
        if {"pers" in [dict get $t gramatiko]} {
            return ms
        }
    }
    my instvar genroArr
    if {![array exists genroArr]} {
        set f [open subst-semd-genro.txt r]
        while {[gets $f line]>=0} {
            set vorto [lindex $line 0]
            set genro [lindex $line 1]
            if {$genro eq ""} {
                set genro mn
            }
            set genroArr($vorto) $genro
        }
        close $f
    }
    if {[catch {set genroArr($plvorto)} genro]} {
        return
    }
    return $genro
}
ImportoIlo proc prenuFleksionDeWictionary substnativo {
    set ret [VikipediaLegilo prenuArtikolon $substnativo dic-pl]
    if {$ret ne ""} {
        if {[regexp {{{odmiana\|polski}} (.+?)\n} $ret _ odmiana]} {
            if {[string first nieodm $odmiana]>=0} {
                return ndm
            }
            lassign [split $odmiana \;] lp lm
            set formoj [dict create]
            if {$lp ne ""} {
                set baza $substnativo
                foreach v [split $lp ,] k {M D C B N Ms W} {
                    regsub -all {{{.+?}}} $v "" v
                    regsub -all {\(.+?\)} $v "" v
                    set v [string trim $v]
                    if {[regexp {~(\w*)} $v _ fino]} {
                        dict set formoj singularo $k ${baza}${fino}
                    } elseif {[regexp {^(\w+)\|(\w*)$} $v _ baza fino]} {
                        dict set formoj singularo $k ${baza}${fino}
                    } elseif {[regexp {^(\w+)$} $v _ formo]} {
                        dict set formoj singularo $k $formo
                    }
                }
            }
            if {$lm ne ""} {
                foreach v [split $lm ,] k {M D C B N Ms W} {
                    regsub -all {{{.+?}}} $v "" v
                    regsub -all {\(.+?\)} $v "" v
                    set v [string trim $v]
                    if {[regexp {~(\w*)} $v _ fino]} {
                        dict set formoj pluralo $k ${baza}${fino}
                    } elseif {[regexp {^(\w+)\|(\w*)$} $v _ baza fino]} {
                        dict set formoj pluralo $k ${baza}${fino}
                    } elseif {[regexp {^(\w+)$} $v _ formo]} {
                        dict set formoj pluralo $k $formo
                    }
                }
            }
            return $formoj
        }
    }
    puts " ne trovita $substnativo"
    return 
}
ImportoIlo proc prenuVerboSenPrefikso verbo {
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set pre {przy prze po zy na o ob od wy we ze z w roz nad u za ze do s pod}
    foreach p $pre {
        if {[regexp "^${p}(.+)" $verbo _ rad]} {
            if {[$spell estasVorto rad]==2} {
                return $rad
            }
        }
    }
    return
}
ImportoIlo proc preparuPWVortaron {} {
    set ifn [IDE::Dialog getOpenFile {{{Text Files} .txt}}]
    if {$ifn eq ""} return
    set if [open $ifn r]
    set of [open [file rootname $ifn]2.txt w]
    set last ""
    while {[gets $if line]>=0} {
        if {[string index $line 0] ne "#"} {
            if {[regexp {^-[A-ZĄĆŃŻŹŁĘ]-} $line]} {
                continue
            }
            if {[regexp {\d+ WIMMER - ESPERANTO EN DEK LECIONOJ} $line]} {
                continue
            }
            if {[string first " - " $line]<0} {
                append last $line
                puts $of [string trim $last]
                set last ""
            } else {
                if {$last ne ""} {
                    puts $of [string trim $last]
                }
                set last $line
            }
            continue
        }
        puts $of [string trim $line]
    }
    if {$last ne ""} {
        puts $of [string trim $last]
    }
    close $if
    close $of
}
ImportoIlo proc preparuSubstGenro {} {

    set fm [open subst-morfologik.txt r]
    while {[gets $fm line]>=0} {
        if {[regexp {^(\w+)\t(\w+)\t(.+)$} $line _ v1 v2 gram]} {
            if {$v1 eq $v2 && [regexp {:(f|n|m[123])$} $gram _ genro]} {
                switch $genro {
                    n {
                        set genro ni
                    }
                    f {
                        set genro ze
                    }
                    m1 {
                        set genro ms
                    }
                    m2 {
                        set genro mz
                    }
                    m3 {
                        set genro mn
                    }
                }
                set genrojArr($v1) $genro
            }
        }
    }
    close $fm

    set f [open subst-semd-genro2.txt r]
    set fo [open subst-semd-genro-out.txt w]
    while {[gets $f line]>=0} {
        set vorto [lindex $line 0]
        if {[catch {set genrojArr($vorto)} genro]} {
            set genro ?
        }
        puts $fo "$vorto $genro"
    }
    close $f
    close $fo
}
ImportoIlo proc puriguFGrupojSubstantivoj {} {
    set sql "select t.id,derivo,traduko,fgrupo from derivo d,traduko_pl t where d.id=t.derivoid and d.typo='substantivo' and fgrupo like '\{%'"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    set rez ""
    while {[llength [set row [$query fetch]]]>0} {
        foreach {did traduko vorto fgrupo} $row {}
        $dbvortaro modifuTradukon $did $vorto $traduko [list fgrupo [lindex $fgrupo 0]] pl
    }
    $query destroy
}
ImportoIlo proc puriguMalsamajFgrupojSubstantivo {} {
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo = '' and t.traduko like '% %'"
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo = '97*' "
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo <> '' and t.gramatiko like '%blp%' "

    set sql "select t1.id as t1id,t2.id as t2id,d1.derivo as d1d,t1.traduko as t1t,t1.fgrupo as t1f,d2.derivo as d2d,t2.traduko as t2t,t2.fgrupo  as t2f,t1.gramatiko as t1g, t2.gramatiko as t2g from traduko_pl t1,traduko_pl t2,derivo d1,derivo d2 where  t1.id<t2.id and d1.id<>d2.id and t1.derivoid=d1.id and d1.derivo like '%o' and d2.derivo like '%o'  and t2.derivoid=d2.id and t1.traduko=t2.traduko and t1.fgrupo<>t2.fgrupo"

    #set sql "select t1.id as t1id,t2.id as t2id,d1.derivo as d1d,t1.traduko as t1t,t1.gramatiko as t1f,d2.derivo as d2d,t2.traduko as t2t,t2.gramatiko as t2f from traduko_pl t1,traduko_pl t2,derivo d1,derivo d2 where  t1.id<t2.id and d1.id<>d2.id and t1.derivoid=d1.id and d1.derivo like '%o' and d2.derivo like '%o'  and t2.derivoid=d2.id and t1.traduko=t2.traduko and t1.gramatiko<>t2.gramatiko"


    set connection [my getVortaroConnection]
    set query [$connection query $sql]

    set rows [$query rows]
    set rez ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row t1id t2id d1d t1t t1f d2d t2t t2f t1g t2g
        if {[llength $t1t]>1} continue
        if {[llength [my testuFGrupoPorSubstantivo $t1t $t1f $t1g]]>0} {
            # t1 ne estas gxusta
            if {[llength [my testuFGrupoPorSubstantivo $t2t $t2f $t2g]]==0} {
                append rez "DBVortaro modifuTradukonDeVorto $d1d $t1t [list [list fgrupo $t2f]] pl\n" 
            } else {
                append rez "# ne trovita $d1d $t1t $t2f $t1f\n"
            }
        } elseif {[llength [my testuFGrupoPorSubstantivo $t2t $t2f $t2g]]>0} {
            if {[llength [my testuFGrupoPorSubstantivo $t1t $t1f $t1g]]==0} {
                append rez "DBVortaro modifuTradukonDeVorto $d2d $t2t [list [list fgrupo $t1f]] pl\n" 
            } else {
                append rez "# ne trovita $d1d $t1t $t2f $t1f\n"
            }
        } else {
            if {[llength $t1f]==1 && [llength $t2f]==1} {
                set sfgrupoj [my sercxuFGrupoPorSubstantivoDeGrupoj $t1t $d1d [list $t1f $t2f] _]
                if {[llength $sfgrupoj]==1} {
                    set fgrupo [lindex $sfgrupoj 0]
                    if {$fgrupo eq $t1f} {
                        append rez "DBVortaro modifuTradukonDeVorto $d2d $t2t [list [list fgrupo $t1f]] pl\n" 
                    } else {
                        append rez "DBVortaro modifuTradukonDeVorto $d1d $t1t [list [list fgrupo $t2f]] pl\n" 
                    }
                }
            }
            append rez "# $row\n"
        }
    }
    $query destroy
    return $rez
}
ImportoIlo proc sercxuDubindajTradukoj {{mustero *}} {
    set sql "select d.derivo,t.traduko from traduko_pl t,derivo d where t.derivoid=d.id"
    set connection [my getVortaroConnection]
    set query [$connection query $sql]
    set tradukoj [list]
    set polvortoj [list]
    while {[llength [set row [$query fetch]]]>0} {
        set polvorto [lindex $row 1]
        set esporto [lindex $row 0]
        lappend tradukoj $polvorto $esporto
        lappend polvortoj $polvorto
    }
    set rez ""
    set falsajVortoj [lsort -unique [my testuFalsajPolVortoj $polvortoj]]
    foreach {polVorto espVorto} $tradukoj {
        foreach p $polVorto {
            if {[lsearch -sorted $falsajVortoj $p]>=0} {
                append rez "$espVorto; $polVorto\n"
                break
            }
        }
    }
    IDE::ResultBrowser newBrowser $rez
}
ImportoIlo proc sercxuDubindajTradukojKunForigo {{mustero *}} {
    set sql "select d.derivo,t.traduko from traduko_pl t,derivo d where t.derivoid=d.id"
    set connection [my getVortaroConnection]
    set query [$connection query $sql]
    set tradukoj [list]
    set polvortoj [list]
    set tvortaro [DBVortaro prenuVortaron]
    while {[llength [set row [$query fetch]]]>0} {
        set polvorto [lindex $row 1]
        set esporto [lindex $row 0]
        lappend tradukoj $polvorto $esporto
        lappend polvortoj $polvorto
    }
    set rez ""
    set falsajVortoj [lsort -unique [my testuFalsajPolVortoj $polvortoj]]
    foreach {polVorto espVorto} $tradukoj {
        foreach p $polVorto {
            if {[lsearch -sorted $falsajVortoj $p]>=0} {
                foreach t [$tvortaro sxercxuRezListo $espVorto pl] {
                    set trad [dict get $t traduko]
                    if {[lsearch -sorted $falsajVortoj $trad]>=0} {
                        continue
                    }
                    if {$trad eq $polVorto} continue
                    set ldist [estrings::levenshteinDistance $trad $polVorto]
                    if {$ldist<=1 || ([string length $trad]>6 && $ldist<=2)} {
                        append rez "# $polVorto > $trad\n"
                        append rez "DBVortaro nuliguTradukonDeVorto  pl $espVorto [list $polVorto]\n"
                    }
                }
                break
            }
        }
    }
    return $rez
}
ImportoIlo proc sercxuElbajnAjdDeSubj {} {
    set sql "select r.radiko,d.derivo,t.traduko,d1.derivo,t1.traduko from radiko r,traduko_pl t1,derivo d1, derivo d left outer join traduko_pl t on (d.id=t.derivoid) where d.prefikso = d1.prefikso and d.sufikso='a' and t.derivoid is null and r.id=d.radikoid and r.id=d1.radikoid and d1.sufikso='o' and t1.derivoid=d1.id"

    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    if {$spell eq ""} {
        error "nenio Hunspell por pola lingvo"
    }

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    set senOK 0
    set rez ""

    while {[llength [set row [$query fetch]]]>0} {
        update
        set esp_adj [lindex $row 1]
        set psub [lindex $row 4]
        foreach adj [PolaFleksio prenuEblajnAdjDeSub $psub] {
            if {[$spell estasVorto $adj]==2} {
                append rez "$esp_adj; $adj\n"
            }
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston $rez
}
ImportoIlo proc sercxuElbajnEtoSubj {} {
    set sql "select r.radiko,d.derivo,t.traduko,d1.derivo,t1.traduko from radiko r,traduko_pl t1,derivo d1, derivo d left outer join traduko_pl t on (d.id=t.derivoid) where d.prefikso = d1.prefikso and d.sufikso='eto' and t.derivoid is null and r.id=d.radikoid and r.id=d1.radikoid and d1.sufikso='o' and t1.derivoid=d1.id"

    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    if {$spell eq ""} {
        error "nenio Hunspell por pola lingvo"
    }

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    set senOK 0
    set rez ""
    set i 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set etosub [lindex $row 1]
        set psub [lindex $row 4]
        foreach adj [PolaFleksio divenuEtoFormon $psub] {
            if {[$spell estasVorto $adj]==2} {
                append rez "$etosub; $adj\n"
            }
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston $rez
}
ImportoIlo proc sercxuFGrupoPorSubstantivo substantivo {
    PolaFleksio instvar dekltabloIndekso
    set eblajIndeksoj [list]
    set kazoj {M D B C Ms N W}
    if {[string is upper [string index $substantivo 0]]} {
        set nombroj singularo
    } else {
        set nombroj {singularo pluralo}
    }

    set dekIndeksoj [lsort -integer [array names dekltabloIndekso]]
    set eblajIndekso [list]
    set eblajIndekso2 [list]
    foreach indekso $dekIndeksoj {
        set listo $dekltabloIndekso($indekso)
        set komenco [lindex $listo 0]
        if {$komenco eq ""} {
            lappend eblajIndeksoj2 $indekso
        } elseif {[string match *$komenco $substantivo]} {
            lappend eblajIndeksoj $indekso
        }
    }
    if {[llength $eblajIndeksoj]==0} {
        set eblajIndeksoj $eblajIndeksoj2
    }
    set eblajIndekso2 [list]
    foreach i [PolaFleksio prenuDeklIndeksoj] {
        if {[regexp {^(\d+)} $i _ nombro]} {
            if {$nombro in $eblajIndeksoj} {
                lappend eblajIndekso2 $i
            }
        }
    }
    set eblajIndeksoj $eblajIndekso2

    set formoj [list]
    foreach indekso $eblajIndeksoj {
        foreach nombro $nombroj {
            foreach kazo $kazoj {
                lappend formoj [PolaFleksio prenuSubstantivonLauxTipo $substantivo $indekso $kazo $nombro]
            }
        }
    }
    set formoj [lsort -unique $formoj]
    set eblajFormoj [my testuEblajPolVortoj $formoj]
    set rezFGrupoj $eblajIndeksoj
    foreach indekso $eblajIndeksoj {
        set isBreak 0
        foreach nombro $nombroj {
            foreach kazo $kazoj {
                set tformo [PolaFleksio prenuSubstantivonLauxTipo $substantivo $indekso $kazo $nombro]
                if {[lsearch $eblajFormoj $tformo]<0} {
                    ide::lremove rezFGrupoj $indekso
                    set isBreak 1
                    break
                }
            }
            if {$isBreak} break
        }
    }
    set rez [list]
    set dekIndeksoj [PolaFleksio prenuDeklIndeksoj]
    foreach f $rezFGrupoj {
        if {$f in $dekIndeksoj} {
            lappend rez $f
        }
    }
    return $rez
}
ImportoIlo proc sercxuFGrupoPorSubstantivoBLP substantivo {
    PolaFleksio instvar dekltabloIndekso

    set eblajIndeksoj [list]
    set kazoj {M D B C Ms N}
    set nombroj pluralo

    set eblajIndeksoj [list]

    foreach e {68 71 96' 112* 90 98 114 115 119 123} {
        if {[PolaFleksio prenuSubstantivonLauxTipo $substantivo $e M pluralo] eq $substantivo} {
            lappend eblajIndeksoj $e
        }
    }

    set formoj [list]
    foreach indekso $eblajIndeksoj {
        foreach nombro $nombroj {
            foreach kazo $kazoj {
                lappend formoj [PolaFleksio prenuSubstantivonLauxTipo $substantivo $indekso $kazo $nombro]
            }
        }
    }
    set formoj [lsort -unique $formoj]
    set eblajFormoj [my testuEblajPolVortoj $formoj]

    set rezFGrupoj $eblajIndeksoj
    foreach indekso $eblajIndeksoj {
        set isBreak 0
        foreach nombro $nombroj {
            foreach kazo $kazoj {
                set tformo [PolaFleksio prenuSubstantivonLauxTipo $substantivo $indekso $kazo $nombro]
                if {[lsearch $eblajFormoj $tformo]<0} {
                    ide::lremove rezFGrupoj $indekso
                    set isBreak 1
                    break
                }
            }
            if {$isBreak} break
        }
    }
    set rez [list]
    set dekIndeksoj [PolaFleksio prenuDeklIndeksoj]
    foreach f $rezFGrupoj {
        if {$f in $dekIndeksoj} {
            lappend rez $f
        }
    }
    # majtki -
    # 68 D - majtkow
    # 112* D - majtek
    #if {"68" in $rez && "112*" in $rez} {
    #    ide::lremove rez 68
    #}
    return $rez
}
ImportoIlo proc sercxuFGrupoPorSubstantivoDeGrupoj {substantivo espvorto fgrupoj mgenroj_ref} {
    upvar $mgenroj_ref mgenroj
    set rez ""
    set uGrupoj [my elektuFGrupo $substantivo $fgrupoj]
    set trovita 0
    if {[llength $fgrupoj]!= [llength $uGrupoj]} {
        if {[llength $uGrupoj]==1} {
            set fgrupo [lindex $uGrupoj 0]
            return $fgrupo
        } else {
            append rez "# !!! $uGrupoj\n"
        }
    }
    if {!$trovita} {
        set dfgrupo [PolaFleksio divenuTiponDeSubstantivo $substantivo]
        if {$dfgrupo ne "" && [lsearch $uGrupoj $dfgrupo]>=0} {
            append rez "# HA HA $dfgrupo\n"
            append rez "#DBVortaro modifuTradukonDeVorto $espvorto [list $substantivo] [list [list fgrupo $dfgrupo]] pl\n"
            set artoj [list]
            foreach a $uGrupoj {
                lappend artoj [PolaFleksio prenuArtoDeTipo $a]
            }
            if {[llength [lsort -unique $artoj]]==1} {
                append rez "# sama arto [lindex $artoj 0]\n"
                #append rez "DBVortaro modifuTradukonDeVorto $espvorto [list $substantivo] [list [list fgrupo $dfgrupo]] pl\n"
                return $dfgrupo
                set trovita 1
            }
        }
    }
    if {!$trovita} {
        set genro [my prenuArtoPorSubstantivo $espvorto $substantivo]
        if {$genro ne ""} {
            set kGrupoj [list]
            foreach a $uGrupoj {
                if {$genro eq [PolaFleksio prenuArtoDeTipo $a]} {
                    lappend kGrupoj $a
                }
            }
            if {[llength $kGrupoj]==1} {
                set trovita 1
                append rez "# genro $genro\n"
                set fgrupo [lindex $kGrupoj 0]
                #append rez "DBVortaro modifuTradukonDeVorto $espvorto [list $substantivo] [list [list fgrupo $fgrupo]] pl\n"
                return $fgrupo
            }
        } else {
            lappend mgenroj $substantivo
        }
    }
    if {!$trovita} {
        set formoj [my prenuFleksionDeWictionary $substantivo]
        if {$formoj ne ""} {

            foreach fgrupo [my elektuFGrupo $substantivo $fgrupoj 0 0] {
                set ok 1
                foreach n {singularo pluralo} {
                    foreach k {M D C B N Ms W} {
                        if {[dict exists $formoj $n $k]} {
                            if {[dict get $formoj $n $k] ne [PolaFleksio prenuSubstantivonLauxTipo $substantivo $fgrupo $k $n]} {
                                set ok 0
                                break
                            }
                        }
                    }
                }
                if {$ok} {
                    break
                }
            }
            if {$ok} {
                set trovita 1
                #append rez "DBVortaro modifuTradukonDeVorto $espvorto [list $substantivo] [list [list fgrupo $fgrupo]] pl\n"
                return $fgrupo
            } else {
                append rez "# victionary $substantivo $formoj\n"
            }
        }
    }
    #return $rez
    return
}
ImportoIlo proc sercxuFGrupoPorSubstantivoKompleksa {substantivo espvorto} {
    if {[llength $substantivo]>1} {
        set substantivo [lindex $substantivo 0]
    }
    set fgrupo [my divenuFGrupojPorSubstantivoDeKonataj $substantivo]
    if {$fgrupo ne ""} {
        return $fgrupo
    }
    set fgrupoj [my sercxuFGrupoPorSubstantivo $substantivo]
    if {[llength $fgrupoj] == 1} {
        return [lindex $fgrupoj 0]
    } elseif {[llength $fgrupoj]>0} {
        return [my sercxuFGrupoPorSubstantivoDeGrupoj $substantivo $espvorto $fgrupoj mgenroj]
    }
    return
}
ImportoIlo proc sercxuFGrupoPorSubstantivoj {{estasInteraktiva 0}} {
    set sql "select t.traduko,d.derivo,t.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.derivo like '%o' order by t.id desc"
    if {$estasInteraktiva} {
        set progreso ""
    } else {
        set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por substantivoj}]
    }

    set senRespondo 0
    set mgenroj [list]

    set rez ""
    # set progreso ""
    set connection [my getVortaroConnection]
    set query [$connection query $sql]
    set i 0

    set cNeTrovita 0
    set cMultaj 0

    set plVortaro [HunspellTestilo prenuInstancoPorLingvo pl]
    
    set tagger [PLTagger prenuTagger]

    set rows [$query rows]
    while {[llength [set row [$query fetch]]]>0} {
        update
        set substantivo [lindex $row 0]
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {"ndm" in [lindex $row 2]} {
            append rez "# ndm - $substantivo\n"
            continue
        }
        
        #append rez "# $row\n"
        set psubstantivo $substantivo
        if {[llength $substantivo]>1} {
            set substantivo [lindex $substantivo 0]
            continue
            if {[llength $psubstantivo]==2} {
                lassign [split $psubstantivo] s1 s2
                set t1 [lindex [$tagger prenuTag [string tolower $s1]] 1]
                set t2 [lindex [$tagger prenuTag [string tolower $s2]] 1]
                if {[regexp {^adj:} $t1] && [regexp {^subst:} $t2]} {
                    set fgrupo [my sercxuFGrupoPorSubstantivoKompleksa $s2 [lindex $row 1]]
                    if {$fgrupo ne ""} {
                        append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo [list $fgrupo adjsub]]] pl\n"
                    } else {
                        append rez "# fgrupo ne trovita $s2 - [lindex $row 1] = $s1 $s2\n"
                    }
                } elseif {[regexp {^adj:} $t2] && [regexp {^subst:} $t1]} {
                    set fgrupo [my sercxuFGrupoPorSubstantivoKompleksa $s1 [lindex $row 1]]
                    if {$fgrupo ne ""} {
                        append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
                    } else {
                        append rez "# fgrupo ne trovita $s2 - [lindex $row 1] = $s1 $s2\n"
                    }
                } elseif {[regexp {^subst:.+gen} $t1] && [regexp {^subst:} $t2]} {
                    set fgrupo [my sercxuFGrupoPorSubstantivoKompleksa $s2 [lindex $row 1]]
                    if {$fgrupo ne ""} {
                        append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo traduko [list $s2 $s1]]] pl\n"
                    } else {
                        append rez "# fgrupo2 ne trovita $s2 - [lindex $row 1] = $s1 $s2\n"
                    }
                }  elseif {0 && [regexp {^subst:.+gen} $t2] && [regexp {^subst:.+nom} $t1]} {
                    set fgrupo [my sercxuFGrupoPorSubstantivoKompleksa $s1 [lindex $row 1]]
                    if {$fgrupo ne ""} {
                        append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
                    } else {
                        append rez "# fgrupo2 ne trovita $s2 - [lindex $row 1] = $s1 $s2\n"
                    }
                } else {
                    append rez "# ne rekonata [lindex $row 1] $s1 $s2\n"
                    continue
                }
            }
            continue
        }
        
        if {![catch {set fgrupoArr($substantivo)} fgrupo]} {
            append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
            continue
        }
        set fgrupoj [my sercxuFGrupoPorSubstantivo $substantivo]
        if {[llength $fgrupoj] == 0} {
            append rez "# fgrupo por substantivo $substantivo ([lindex $row 1]) ne trovita\n"
            if {[$plVortaro estasVorto $substantivo]!=2} {
                append rez "# vorto ne en literumilo ($substantivo)\n"
                if {[$plVortaro estasVorto [string toupper $substantivo]]==2} {
                    append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list traduko [esp::grandskribi $substantivo]]] pl\n"
                } else {
                    incr cNeTrovita
                }
            } else {
                #append rez "# fgrupo por substantivo $substantivo ([lindex $row 1]) ne trovita\n"
                set fgrupoj [my sercxuFGrupoPorSubstantivoBLP $substantivo]
                if {[llength $fgrupoj]>0} {
                    set fgrupo [lindex $fgrupoj 0]
                    if {$fgrupoj>1} {
                        append rez "# multaj $fgrupoj\n"
                        foreach f $fgrupoj {
                            append rez "# $f - [PolaFleksio prenuSubstantivonLauxTipo $substantivo $f D pluralo]\n"
                        }
                    }
                    append rez "#DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo gramatiko blp]] pl\n"
                } else {
                    if {0 && [my prenuFleksionDeWictionary $substantivo] eq "ndm"} {
                        append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list gramatiko ndm]] pl\n"
                    }
                }
            }
        } elseif {[llength $fgrupoj]>1} {
            append rez "# multaj fgrupoj por substantivo $substantivo = $fgrupoj\n"
            incr cMultaj
            set fgrupo [my sercxuFGrupoPorSubstantivoDeGrupoj $substantivo [lindex $row 1] $fgrupoj mgenroj]
            if {$fgrupo ne ""} {
                set fgrupoArr($substantivo) $fgrupo
                append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
            } else {
               if {$estasInteraktiva} {
                   set fgrupo [GramFiniloMontriloDialogoMix prenuFGruponDev pl $substantivo Substantivo]
                   if {$fgrupo ne ""} {
                       append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
                       set senRespondo 0
                       set fgrupoArr($substantivo) $fgrupo
                   } else {
                       incr senRespondo
                       if {$senRespondo>=10} {
                           break
                       }
                   }
               }
            }
       } else {
            #my changxuFGrupoPorDerivo [lindex $fgrupoj 0] $substantivo Substantivo
            # eble blp
            
            
            set fgrupo [lindex $fgrupoj 0]
            append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $psubstantivo] [list [list fgrupo $fgrupo]] pl\n"
        }
        if {$i>5000} {
            break
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
    }
    append rez "# ne trovita " $cNeTrovita " multaj " $cMultaj "\n"
    append rez #[join $mgenroj \n#]\n
    return $rez
}
ImportoIlo proc sercxuFGrupoPorSubstantivojSpeciala {} {
    set sql "select t.traduko,d.derivo from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.derivo like '%o' and t.traduko like '%ek'"
    set estasInteraktiva 0
    if {$estasInteraktiva} {
        set progreso ""
    } else {
        set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por substantivoj}]
    }

    set senRespondo 0
    set mgenroj [list]

    set rez ""
    # set progreso ""
    set connection [my getVortaroConnection]
    set query [$connection query $sql]
    set i 0

    set cNeTrovita 0
    set cMultaj 0

    set plVortaro [HunspellTestilo prenuInstancoPorLingvo pl]

    set rows [$query rows]
    while {[llength [set row [$query fetch]]]>0} {
        update
        set substantivo [lindex $row 0]
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        append rez "# $row\n"
        if {[llength $substantivo]>1} {
            continue
        }

        set fgrupoj [my sercxuFGrupoPorSubstantivo $substantivo]
        if {[llength $fgrupoj] == 0} {
            append rez "# fgrupo por substantivo $substantivo ne trovita\n"
            if {[$plVortaro estasVorto $substantivo]!=2} {
                append rez "# vorto ne en literumilo\n"
            }
            incr cNeTrovita
        } elseif {[llength $fgrupoj]>1} {
            if {"80" in $fgrupoj} {
                append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $substantivo] [list [list fgrupo 80]] pl\n"
            }
       } else {
            #my changxuFGrupoPorDerivo [lindex $fgrupoj 0] $substantivo Substantivo
            set fgrupo [lindex $fgrupoj 0]
            append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $substantivo] [list [list fgrupo $fgrupo]] pl\n"
        }
        if {$i>5000} {
            break
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
    }
    append rez "# ne trovita " $cNeTrovita " multaj " $cMultaj "\n"
    append rez [join $mgenroj \n]
    return $rez
}
ImportoIlo proc sercxuFGrupoPorVerbo verbo {
    set konIndeksoj [PolaFleksio prenuKonjIndeksoj]
    set eblajIndeksoj [list]
    PolaFleksio instvar konjtabloIndekso
    set testFormoj {1 2 3 4 5 6 12 13 14 15 16}
    foreach indekso $konIndeksoj {
        set listo $konjtabloIndekso($indekso)
        set komenco [lindex $listo 0]
        if {[string match *$komenco $verbo]} {
            lappend eblajIndeksoj $indekso
        }
    }
    set def {
        1 ms singularo as {}
        2 ms singularo as {}
        3 ms singularo as {}
        1 ms pluralo as {}
        2 ms pluralo as {}
        3 ms pluralo as {}
        1 ms singularo is {}
        1 ze singularo is {}
        2 ms singularo is {}
        2 ze singularo is {}
        3 ms singularo is {}
        3 ze singularo is {}
        3 ni singularo is {}
        1 ms pluralo is {}
        1 ze pluralo is {}
        2 ms pluralo is {}
        2 ze pluralo is {}
        3 ms pluralo is {}
        3 ze pluralo is {}
        2 ms singularo u {}
        2 ms pluaro u {}
    }

    set formoj [list]
    foreach fgrupo $eblajIndeksoj {
        foreach {persono arto nombro tempo gram} $def {
            set vorto [PolaFleksio prenuVerbon $verbo $fgrupo $persono $arto $nombro $tempo]
            if {$vorto eq ""} {
                continue
            }
            lappend formoj $vorto
        }
    }
    set formoj [lsort -unique $formoj]
    set eblajFormoj [my testuEblajPolVortoj $formoj]
    set rezFGrupoj $eblajIndeksoj
    foreach fgrupo $eblajIndeksoj {
        foreach {persono arto nombro tempo gram} $def {
            set vorto [PolaFleksio prenuVerbon $verbo $fgrupo $persono $arto $nombro $tempo]
            if {$vorto eq ""} {
                continue
            }
            if {[lsearch $eblajFormoj $vorto]<0} {
                ide::lremove rezFGrupoj $fgrupo
                break
            }
        }
    }
    return $rezFGrupoj
}
ImportoIlo proc sercxuFGrupoPorVerboKompleksa verbo {
    set fgrupo [my sercxuFGruponDeSimilaj $verbo]
    if {$fgrupo eq ""} {
        set fgrupo [my sercxuFGrupoPorVerbo $verbo]
    }
    return $fgrupo
}
ImportoIlo proc sercxuFGrupoPorVerboj {} {
    set sql "select t.traduko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='verbo'"
    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    while {[llength [set row [$query fetch]]]>0} {
        update
        set overbo [lindex $row 0]
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {[llength $overbo]>1} {
            set verbo [lindex $overbo 0]
        } else {
            set verbo $overbo
        }
        set fgrupoj [my sercxuFGrupoPorVerbo $verbo]
        if {[llength $fgrupoj] == 0} {
            puts "fgrupo por verbo $verbo ne trovita"
        } elseif {[llength $fgrupoj]>1} {
            if {$fgrupoj eq "I IX"} {
                puts " trovita por $verbo [lindex $fgrupoj 0]"
                my changxuFGrupoPorDerivo I $verbo Verbo
            } elseif {$fgrupoj eq "I Xa"} {
                puts " trovita por $verbo [lindex $fgrupoj 0]"
                my changxuFGrupoPorDerivo I $verbo Verbo
            } elseif {$fgrupoj eq "I VIIIa"} {
                puts " trovita por $verbo [lindex $fgrupoj 0]"
                my changxuFGrupoPorDerivo VIIIa $verbo Verbo
            } else {
                puts "multahj fgrupoj por verbo $verbo = $fgrupoj"
            }
        } else {
            puts " trovita por $verbo [lindex $fgrupoj 0]"
            my changxuFGrupoPorDerivo [lindex $fgrupoj 0] $overbo Verbo
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
ImportoIlo proc sercxuFGrupoPorVerbojKunDialogo {} {
    set sql "select t.traduko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='verbo'"
    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    set senOK 0
    while {[llength [set row [$query fetch]]]>0} {
        update
        set overbo [lindex $row 0]
        incr i
        if {$senOK>5} {
            break
        }
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {[llength $overbo]>1} {
            set verbo [lindex $overbo 0]
        } else {
            set verbo $overbo
        }
        set fgrupoj [GramFiniloMontriloDialogoMix prenuFGrupon pl $verbo Verbo]
        if {[llength $fgrupoj] == 0} {
            puts "fgrupo por verbo $verbo ne trovita"
            incr senOK
        } elseif {[llength $fgrupoj]>1} {
            puts " trovita por $verbo [lindex $fgrupoj 0]"
            my changxuFGrupoPorDerivo [lindex $fgrupoj 0] $overbo Verbo
            set senOK 0
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
ImportoIlo proc sercxuFGrupoPorVerbojNova {} {
    set sql "select t.traduko,d.derivo from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.derivo  like '%i'"

    #set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set progreso ""
    #set connection [SQLDBVortaro getVortaroConnection]
    set connection [my getVortaroConnection]

    set query [$connection query $sql]
    set i 0
    set rows [$query rows]
    set rez ""
    while {[llength [set row [$query fetch]]]>0} {
        update
        set overbo [lindex $row 0]
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {[llength $overbo]>1} {
            set verbo [lindex $overbo 0]
        } else {
            set verbo $overbo
        }
        set fgrupo [my sercxuFGrupoPorVerboKompleksa $verbo]
        if {[llength $fgrupo] == 0} {
            append rez "# fgrupo por verbo $verbo ([lindex $row 1]) ne trovita\n"
        } else {
            append rez "DBVortaro modifuTradukonDeVorto [lindex $row 1] [list $overbo] [list [list fgrupo $fgrupo]] pl\n"
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
    }
    return $rez
}
ImportoIlo proc sercxuFGruponDeSimilaj verbo {
    # Se la verboj malsimilas nur per prefikso ili havas la saman fgrupon
    
    set pre {przy prze po zy na o ob od wy we ze z w roz nad u za ze do s pod}
    
    # trovu la bazon
    foreach p $pre {
        if {[regexp ^${p}(.+)$ $verbo _ postvorto]} {
            lappend bvortoj $postvorto $p
        }
    }
    lappend bvortoj $verbo {}

    set vortaro [SQLDBVortaro getSQLDBVortaron]
    foreach {b bprefix} $bvortoj {
        foreach p [linsert $pre 0 [list]] {
            set avorto $p$b
            #puts $avorto
            foreach t [$vortaro sxercxuRezListoPorTraduko $avorto pl] {
                if {[dict get $t fgrupo] ne "" && [string index [dict get $t vorto] end] eq "i"} {
                    set fgrupo [dict get $t fgrupo]
                    puts "laux $avorto <- $b $bprefix"
                    set nfgrupo [list [lindex $fgrupo 0]]
                    foreach v [lrange $fgrupo 1 end] {
                        if {[regexp ^${p}(.+)$ [lindex $v 1] _ bfvorto]} {
                            lappend nfgrupo [list [lindex $v 0] $bprefix$bfvorto]
                        }
                    }
                    return $nfgrupo
                }
            }
        }
    }
    return
}
@ ImportoIlo proc sercxuNekonatajGramVerboj {} {
description {Sxercxas verboj sen gramatiko "ndk" "dk"
duopoj
budzic - dk
zbudzic - ndk}
}
ImportoIlo proc sercxuNekonatajGramVerboj {{mustero %}} {
    # ImportoIlo sercxuNekonatajGramVerboj bandaĝi
    # ImportoIlo sercxuNekonatajGramVerboj %
    set sql "select d.derivo from derivo d where d.typo='verbo' and derivo like '$mustero'"
    # set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set pre {przy prze po zy na o ob od wy we ze z w}
    set dbvortaro [DBVortaro prenuDepVortaron]
    set rez ""
    while {[llength [set row [$query fetch]]]>0} {
        set vorto [lindex $row 0]
        set tradukojArrList [$dbvortaro sxercxuRezListo $vorto pl]
        set tradukoj [list]
        set gramatikoj [list]
        set jusNdk [list]
        foreach t $tradukojArrList {
             array set tradArr $t
             lappend tradukoj $tradArr(traduko)
             lappend gramatikoj $tradArr(gramatiko)
        }
        set i 0
        foreach t $tradukoj {
            foreach p $pre {
                if {[regexp ^${p}(.+)$ $t _ postvorto]} {
                    if {[set indekso [lsearch $tradukoj $postvorto]]>=0} {
                        if {[lsearch [lindex $gramatikoj $indekso] ndk]<0} {
                            if {[lsearch $jusNdk $postvorto]<0} {
                                append rez "DBVortaro modifuTradukonDeVorto $vorto [list $postvorto] {gramatiko ndk} pl\n"
                                lappend jusNdk $postvorto
                            }
                        }
                        if {[lsearch [lindex $gramatikoj $i] dk]<0} {
                            append rez "DBVortaro modifuTradukonDeVorto $vorto [list $t] {gramatiko dk} pl\n"
                        }
                    }
                }
            }
            incr i
        }
    }
    IDE::ResultBrowser newBrowser $rez
}
ImportoIlo proc sercxuNekonatajTradukoj {{mustero *}} {
    # ImportoIlo sercxuNekonatajTradukoj *e
    # ImportoIlo sercxuNekonatajTradukoj *eco
    # ImportoIlo sercxuNekonatajTradukoj pra*
    # ImportoIlo sercxuNekonatajTradukoj tra*i
    # ImportoIlo sercxuNekonatajTradukoj trans*i
    # ImportoIlo sercxuNekonatajTradukoj el*i
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    if {$spell eq ""} {
        error "nenio Hunspell por pola lingvo"
    }

    set dbvortaro [DBVortaro prenuDepVortaron]
    set rez ""
    set vortlisto [list]
    set plVortoj [list]
    foreach v [$dbvortaro sercxuSenTraduko $mustero pl] {
        foreach t [PolaVortFarado prenuMorfVortfaradoj $v] {
            if {[llength $t]>1} continue
            if {[$spell estasVorto $t]==2} {
                lappend vortlisto $v $t
            }
        }
    }
    foreach {espVorto plVorto} $vortlisto {
        append rez "$espVorto; $plVorto\n"
    }
    IDE::ResultBrowser newBrowser $rez
}
ImportoIlo proc sqlDemandoj {} {
    # brakujace rzeczowniki odczasownikowe
    select r.radiko,d.derivo,t.traduko,d1.derivo,t1.traduko from radiko r,traduko_pl t1,derivo d1, derivo d left outer join traduko_pl t on (d.id=t.derivoid) where d.prefikso = '' and d.sufikso='o' and t.derivoid is null and r.id=d.radikoid and r.id=d1.radikoid and d1.prefikso='' and d1.sufikso='i' and t1.derivoid=d1.id;
    # brakujace przymiotniki odrzeczownikowe
    select r.radiko,d.derivo,t.traduko,d1.derivo,t1.traduko from radiko r,traduko_pl t1,derivo d1, derivo d left outer join traduko_pl t on (d.id=t.derivoid) where d.prefikso = '' and d.sufikso='a' and t.derivoid is null and r.id=d.radikoid and r.id=d1.radikoid and d1.prefikso='' and d1.sufikso='o' and t1.derivoid=d1.id; 
}
ImportoIlo proc sqlQuery {} {
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo = '' and t.traduko like '% %'"
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo = '97*' "
    #set sql "select t.id,t.traduko,d.derivo,t.fgrupo from traduko_pl t,derivo d where t.derivoid=d.id and d.derivo like '%o' and t.fgrupo <> '' and t.gramatiko like '%blp%' "

    set sql "select t1.id as t1id,t2.id as t2id,d1.derivo as d1d,t1.traduko as t1t,t1.fgrupo as t1f,d2.derivo as d2d,t2.traduko as t2t,t2.fgrupo  as t2f from traduko_pl t1,traduko_pl t2,derivo d1,derivo d2 where  t1.id<t2.id and d1.id<>d2.id and t1.derivoid=d1.id and d1.derivo like '%o' and d2.derivo like '%o'  and t2.derivoid=d2.id and t1.traduko=t2.traduko and t1.fgrupo<>t2.fgrupo"

    #set sql "select t1.id as t1id,t2.id as t2id,d1.derivo as d1d,t1.traduko as t1t,t1.gramatiko as t1f,d2.derivo as d2d,t2.traduko as t2t,t2.gramatiko as t2f from traduko_pl t1,traduko_pl t2,derivo d1,derivo d2 where  t1.id<t2.id and d1.id<>d2.id and t1.derivoid=d1.id and d1.derivo like '%o' and d2.derivo like '%o'  and t2.derivoid=d2.id and t1.traduko=t2.traduko and t1.gramatiko<>t2.gramatiko"


    set connection [my getVortaroConnection]
    set query [$connection query $sql]

    set rows [$query rows]
    set rez ""
    while {[llength [set row [$query fetch]]]>0} {
        append rez [join $row \t]\n
        #$connection execute "update traduko_pl set fgrupo='' where id=[lindex $row 0]"
    }
    $query destroy
    return $rez
}
ImportoIlo proc sxercxuAspektojPorVerboj {} {
    # zrobiwszy - ite - dk
    # robiąć - ate - ndk

    set sql "select t.traduko,fgrupo,t.gramatiko,d.derivo from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is not null and fgrupo<>'') and d.typo='verbo' and (t.gramatiko is null or t.gramatiko='')"
    set aspell [HunspellTestilo prenuInstancoPorLingvo pl]

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set vortaro [DBVortaro prenuDepVortaron]

    set i 0
    set rows [$query rows]
    set rezulto ""

    while {[llength [set row [$query fetch]]]>0} {
        update
        lassign $row verbo fgrupo gramatiko derivo
        puts "# testi $verbo"
        set uverbo [lindex $verbo 0]
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        if {$uverbo eq "być"} {
            append rezulto "DBVortaro modifuTradukonDeVorto $derivo [list $verbo] {gramatiko dk} pl\n"
            continue
        }
        # zrobiwszy
        set imUprzedni [PolaFleksio prenuVerbon $uverbo $fgrupo 1 ms singularo ite]
        # robiąć
        set imWspol [PolaFleksio prenuVerbon $uverbo $fgrupo 1 ms singularo ate]
        if {$imUprzedni eq "" || $imWspol eq ""} {
            continue
        }
        set eraroj [$aspell testuVortoj [list $imUprzedni $imWspol]]
        if {[lsearch $eraroj $imUprzedni]<0 && [lsearch $eraroj $imWspol]>=0} {
            append rezulto "DBVortaro modifuTradukonDeVorto $derivo [list $verbo] {gramatiko dk} pl\n"
            set trovita 1
        } elseif {[lsearch $eraroj $imWspol]<0 && [lsearch $eraroj $imUprzedni]>=0} {
            append rezulto "DBVortaro modifuTradukonDeVorto $derivo [list $verbo] {gramatiko ndk} pl\n"
        } else {
            foreach t [$vortaro sxercxuRezListoPorTraduko $uverbo pl] {
                set gramatiko [dict get $t gramatiko]
                if {$gramatiko in {dk ndk}} {
                    append rezulto "DBVortaro modifuTradukonDeVorto $derivo [list $verbo] [list [list gramatiko $gramatiko]] pl\n"
                    break
                }
            }

        }
        incr i
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston $rezulto
}
@ ImportoIlo proc sxhangxuVorboOrdo {} {
description {kopias fgrupoj de konstaj verboj al du vortaj verboj
znać - znać się}
}
ImportoIlo proc sxhangxuVorboOrdo {} {
    set sql "select t.id,t.fgrupo,t.traduko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is null or fgrupo='') and d.typo='verbo' and traduko like '% %'"
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set dbvortaro [DBVortaro prenuDepVortaron]
    while {[llength [set row [$query fetch]]]>0} {
        foreach {id grupo vorto} $row {}
        if {[lindex $vorto 0] eq "się"} {
            continue
        }
        if {[llength $vorto]!=2} {
            continue
        }
        if {[string index [lindex $vorto 0] end] ne "ć" && [string index [lindex $vorto 1] end] eq "ć"} {
            set bvorto "[lindex $vorto 1] [lindex $vorto 0]"
            puts "$vorto -> $bvorto"
            $connection execute "update traduko_pl set traduko='$bvorto' where id=$id"
        }
    }
}
ImportoIlo proc testuDeklinacjaTabloj {} {
    set tablo ""
    set eraroj 0
    foreach d [list deklin1.html deklin2.html deklin3.html] {
        set r [my leguHTMLTabloj [file join /home/artur/polski/polskagramatyka/ $d]]
        set t [lindex $r 1]
        foreach arto $t {
            set tipo [lindex $arto 0]
            set bazaformo [lindex $arto 1]
            foreach vorto [lrange $arto 1 end] kazo {M D C B N Ms W M D C B N Ms W Mx} nombro {singularo singularo singularo singularo singularo singularo singularo pluralo pluralo pluralo pluralo pluralo pluralo pluralo pluralo} {
                if {$vorto eq "Mx"} continue
                set int [PolaFleksio prenuSubstantivonLauxTipo $bazaformo $tipo $kazo $nombro]
                if {$vorto ne $int} {
                    incr eraroj
                    append tablo "$bazaformo - $tipo $kazo $nombro - $int <> $vorto\n"
                }
            }
        }
    }
    return "$eraroj\n$tablo"
}
@ ImportoIlo proc testuEblajPolVortoj {} {
description {La metodo uzas ASpell por testi liston kun polaj vortoj.
Nur ekzistantaj vortoj estas redonotaj}
}
ImportoIlo proc testuEblajPolVortoj listo {
    set rezulto $listo
    foreach v [my testuFalsajPolVortoj $listo] {
        ide::lremoveAll rezulto $v
    }
    return $rezulto
}
ImportoIlo proc testuFGrupoPorSubstantivo {substantivo fgrupo gramatiko {spell {}}} {
    if {$spell eq ""} {
        set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    }
    set vortoj [list]
    foreach nombro {singularo pluralo} {
        if {$nombro eq "singularo" && [lsearch $gramatiko blp]>=0} {
            continue
        }
        if {$nombro eq "pluralo" && [lsearch $gramatiko blm]>=0} {
            continue
        }
        foreach kazo {M D B C N Ms W} {
            set key "$kazo $nombro <$fgrupo>"
            set vorto [PolaFleksio prenuSubstantivonLauxTipo $substantivo $fgrupo $kazo $nombro]
            if {$vorto eq ""} {
                continue
            }
            lappend vortoj $vorto
            if {![info exists vArr($vorto)]} {
                set vArr($vorto) $key
            }
        }
    }
    set vortoj [lsort -unique $vortoj]
    set eraroj [$spell testuVortoj $vortoj]
    set rez [list]
    foreach e $eraroj {
        if {[info exists vArr($e)]} {
            lappend rez $e $vArr($e)
        } else {
            lappend rez $e ?
        }

    }
    return $rez
}
ImportoIlo proc testuFGrupoPorSubstantivoj {} {
    set sql "select t.traduko,fgrupo,t.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is not null and fgrupo<>'') and d.typo='substantivo'"
    set aspell [AspellTestilo prenuInstancoPorLingvo pl]

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set i 0
    set rows [$query rows]
    set rezulto ""
    set countOK 0
    set countErr 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        set verbo [lindex [lindex $row 0] 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        puts "# testi $verbo"
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set eraroj [my testuFGrupoPorSubstantivo $verbo $fgrupo $gramatiko $aspell]
        puts "eraroj $eraroj"
        if {[llength $eraroj]>0} {
            incr countErr
        } else {
            incr countOK
        }
        foreach {e disk} $eraroj {
            set e [string trim $e]
            if {$e eq ""} continue
            append rezulto "[lindex $row 0] - $verbo $disk $e\n"
        }
        incr i
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston "$rezulto\neraroj=$countErr ([expr round(100.0*$countErr/$i)]) ok=$countOK"
}
ImportoIlo proc testuFGrupoPorVerbo {verbo fgrupo {gramatiko {}} {aspell {}}} {
    if {$aspell eq ""} {
        set aspell [AspellTestilo prenuInstancoPorLingvo pl]
    }
    #1 ms singularo as {}
    #2 ms singularo as {}
    #3 ms singularo as {}
    #1 ms pluralo as {}
    #2 ms pluralo as {}
    #3 ms pluralo as {}
    #1 ms singularo is {}
    #1 ze singularo is {}
    #2 ms singularo is {}
    #2 ze singularo is {}
    #3 ms singularo is {}
    #3 ze singularo is {}
    #3 ni singularo is {}
    #1 ms pluralo is {}
    #1 ze pluralo is {}
    #2 ms pluralo is {}
    #2 ze pluralo is {}
    #3 ms pluralo is {}
    #3 ze pluralo is {}
    #2 ms singularo u {}
    #2 ms pluaro u {}
    #1 ms pluaro u {}
    #1 ms singularo it {}
    #1 ms singularo ate ndk
    #1 ms singularo ite dk
    #1 ms singular ois {}
    #1 ms singularo o {}

    #set def {
        #1 ms singularo as {}
        #2 ms singularo as {}
        #3 ms singularo as {}
        #1 ms pluralo as {}
        #2 ms pluralo as {}
        #3 ms pluralo as {}
        #1 ms singularo is {}
        #1 ze singularo is {}
        #2 ms singularo is {}
        #2 ze singularo is {}
        #3 ms singularo is {}
        #3 ze singularo is {}
        #3 ni singularo is {}
        #1 ms pluralo is {}
        #1 ze pluralo is {}
        #2 ms pluralo is {}
        #2 ze pluralo is {}
        #3 ms pluralo is {}
        #3 ze pluralo is {}
    #}

    set def {
        1 ms singular ois {}
        1 ms singularo o {}
    }


    set vortoj [list]
    foreach {persono arto nombro tempo gram} $def {
        set key "$persono $arto $nombro $tempo <$fgrupo>"
        if {$gram ne ""} {
            if {[lsearch $gramatiko $gram]<=0} {
                continue
            }
        }
        set vorto [PolaFleksio prenuVerbon $verbo $fgrupo $persono $arto $nombro $tempo]
        if {$vorto eq ""} {
            continue
        }
        lappend vortoj $vorto
        set vArr($vorto) $key
    }
    set eraroj [$aspell testuVortoj $vortoj]
    set rez [list]
    foreach e $eraroj {
        if {[info exists vArr($e)]} {
            lappend rez $e $vArr($e)
        } else {
            lappend rez $e ?
        }

    }
    return $rez
}
ImportoIlo proc testuFGrupoPorVerboj {} {
    set sql "select t.traduko,fgrupo,t.gramatiko,d.gramatiko from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is not null and fgrupo<>'') and d.typo='verbo'"
    set aspell [AspellTestilo prenuInstancoPorLingvo pl]

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set i 0
    set rows [$query rows]
    set rezulto ""
    set countOK 0
    set countErr 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        set verbo [lindex [lindex $row 0] 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        set egramatiko [lindex $row 3]
        puts "# testi $verbo"
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set eraroj [my testuFGrupoPorVerbo $verbo $fgrupo [concat $gramatiko $egramatiko] $aspell]
        puts "eraroj $eraroj"
        if {[llength $eraroj]>0} {
            incr countErr
        } else {
            incr countOK
        }
        foreach {e disk} $eraroj {
            set e [string trim $e]
            if {$e eq ""} continue
            append rezulto "[lindex $row 0] - $verbo $disk $e\n"
        }
        incr i
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
   EsperantoBrowser redaktoTekston "$rezulto\neraroj=$countErr ([expr round(100.0*$countErr/$i)]) ok=$countOK"
}
ImportoIlo proc testuFGrupoPorVerbojKunDialogo {} {
    set sql "select t.traduko,fgrupo,t.gramatiko,d.derivo from traduko_pl t,derivo d where t.derivoid=d.id and (fgrupo is not null and fgrupo<>'') and d.typo='verbo'"
    set aspell [AspellTestilo new -volatile -lingvo pl]

    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]

    set i 0
    set rows [$query rows]
    set rezulto ""
    set countOK 0
    set countErr 0
    set cancelNombro 0

    while {[llength [set row [$query fetch]]]>0} {
        update
        set basaVerbo [lindex $row 0]
        set verbo [lindex $basaVerbo 0]
        set fgrupo [lindex $row 1]
        set gramatiko [lindex $row 2]
        set derivo [lindex $row 3]
        puts "# testi $verbo"
        if {$cancelNombro>5} {
           break
        }
        set eraroj [my testuFGrupoPorVerbo $verbo $fgrupo $gramatiko $aspell]
        incr i
        if {[llength $eraroj]>0} {
            set erarajVortoj [list]
            foreach {eraro disk} $eraroj {
                lappend erarajVortoj $eraro
            }
            set rez [PlGramFiniloMontriloDialogo prenuFGruponKunEraroj $verbo Verbo $fgrupo $erarajVortoj]
            if {$rez ne $fgrupo} {
                if {$rez ne ""} {
                    set cancelNombro 0
                    my changxuFGrupoPorDerivo $rez $basaVerbo Verbo "" 1
                } else {
                    incr cancelNombro
                }
            }
        }
    }
    $query destroy
}
ImportoIlo proc testuFalsajPolVortoj listo {
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set err [list]
    foreach v $listo {
        if {[$spell estasVorto $v]!=2} {
            lappend err $v
        }
    }
    return $err
}
ImportoIlo proc vortaroCz2Pl {} {
    set in [open ~/esperanto/fontoj/nekonataj-pl-eo-cz2.txt]
    set spell [HunspellTestilo prenuInstancoPorLingvo pl]
    set out ""

    while {[gets $in line]>=0} {
        set line [string trim $line]
        foreach {radiko vorto disc1 disc2 traduko sinonimo d1 d2 d3 d4} [split $line \t] {}
        if {$vorto eq ""} continue
        set pltraduko $traduko
        foreach {from to} {vit$ wić dit$ dzić ne$ nie ce$ ca gie$ gia we$ wo [mn]ický miczny icky$ yczny ^čl czł ně nie ač$ ać vl wł} {
            if {[regsub $from $pltraduko $to pltraduko]} {
                break
            }
        }
        set pltraduko [string map [list sti sty při przy inský iński kér kier] $pltraduko]
        set pltraduko [string map [list v w ř rz š sz č cz á a ě e é e ž ż] $pltraduko]

        if {[$spell estasVorto $pltraduko]} {
            append out "$vorto; $pltraduko\n"
        }
    }
    EsperantoBrowser redaktoTekston $out
    close $in
    $spell destroy

}
ImportoIlo proc vortaroFremdSkriptoj {} {
    set v [open ~/esperanto/fontoj/german-polish-2007-03-15.txt]
    
    while {[gets $v line]>=0} {
        set line [string trim $line]
        if {[string index $line 0] eq "#"} continue
        foreach {flisto tlisto} [split $line \t] {
            foreach f [split $flisto \;] {
                set f [string trim $f]
                foreach t [split $tlisto \;] {
                    set t [string trim $t]
                    ide::addToValueForKey vortaroArr $f $t
                }
            }
        }
    }
    close $v
    
    
    set in [open ~/esperanto/fontoj/nekonataj-pl-pur.txt r]
    set out [open ~/esperanto/fontoj/konataj-eo-de-pl.txt w]
    
    set vortaro [DBVortaro prenuDepVortaron]
    
    while {[gets $in line]>=0} {
        set vorto [string trim $line]
        foreach trad [$vortaro sxercxuVortoListo $vorto de] {
            if {[info exists vortaroArr($trad)]} {
                puts $out "$vorto; [join $vortaroArr($trad) ", "]"
            }
        }
        
    }
    close $in
    close $out

}
ImportoIlo proc vortaroFremdSkriptoj2 {} {
    # konvertu vortaron pl-de al eo-pl per eo-de
    set v [open ~/esperanto/pl_fontoj/vortaro-pl-de.csv]
    
    while {[gets $v line]>=0} {
        set line [string trim $line]
        if {[string index $line 0] eq "#"} continue
        foreach {flisto tlisto} [split $line \;] {
            foreach f [split $flisto ,] {
                set f [string trim $f]
                foreach t [split $tlisto ,] {
                    set t [string trim $t]
                    ide::addToValueForKey vortaroArr $t $f
                }
            }
        }
    }
    close $v
    
    
    set in [open ~/esperanto/fontoj/nekonataj-pl-pur.txt r]
    set out [open ~/esperanto/pl_fontoj/konataj-eo-de-pl.txt w]
    
    set vortaro [DBVortaro prenuDepVortaron]
    
    while {[gets $in line]>=0} {
        set vorto [string trim $line]
        foreach trad [$vortaro sxercxuVortoListo $vorto de] {
            if {[info exists vortaroArr($trad)]} {
                puts $out "$vorto; [join $vortaroArr($trad) ", "]"
            }
        }
        
    }
    close $in
    close $out

}
ImportoIlo proc vortaroKreuCzNekonataj {} {
    set v [open ~/esperanto/fontoj/nekonataj-pl-pur.txt r]
    set vortaro [DBVortaro prenuDepVortaron]

    while {[gets $v line]>=0} {
        set vorto [string trim $line]
        if {[llength [$vortaro sxercxuRezListo $vorto pl]]>0} {
            puts "v $vorto"
            continue
        }
        lappend vortoj $vorto
    }
    close $v

    set vortoj [lsort $vortoj]

    set in [open ~/esperanto/fontoj/nekonataj-pl-eo-cz.txt r]
    set out [open ~/esperanto/fontoj/nekonataj-pl-eo-cz2.txt w]
    while {[gets $in line]>=0} {
        foreach {radiko vorto disc1 disc2 traduko sinonimo d1 d2 d3 d4} [split $line \t] {}
        if {$vorto eq ""} {
            puts "c $line"
            #my halt
            continue
        }
        if {[lsearch $vortoj $vorto]>=0} {
            puts $out $line
        } else {
            puts "trovita $vorto"
        }
    }
    close $in
    close $out

}
ImportoIlo proc vortaroNekonatajRadikoj {} {
    set in [open ~/esperanto/fontoj/vortaro-eo-cz.txt r]
    set ret ""
    while {[gets $in line]>=0} {
        foreach {radiko vorto disc1 disc2 traduko priskribo sinonimo d1 d2 d3 d4} [split $line \t] {}
        if {[string length $radiko]<=2 || ![regexp {^\w+[^oae]$} $radiko]} continue
        if {![Object isobject Radiko::$radiko]} {
            append ret $line\n
        }
    }
    close $in
    EsperantoBrowser redaktoTekston $ret
}
ImportoIlo proc vortaroSinonimojDeCz {} {
    set in [open ~/esperanto/fontoj/vortaro-eo-cz.txt r]
    set out [open ~/esperanto/fontoj/cz-sinonimoj.txt w]
    while {[gets $in line]>=0} {
        foreach {radiko vorto disc1 disc2 traduko priskribo sinonimo d1 d2 d3 d4} [split $line \t] {}
        if {$sinonimo eq ""} continue
        puts $out "$vorto : $sinonimo"
    }
    close $in
    close $out

}
ImportoIlo proc vortaroSkriptoj {} {
    # purigas la nekontajn vortojn je vortor kreieblaj per vortfarado
    set in [open ~/esperanto/fontoj/nekonataj-pl.txt r]
    set out [open ~/esperanto/fontoj/nekonataj-pl-pur.txt w]
    set fontolingvo pl
    set vortaro [DBVortaro prenuDepVortaron]
    set espReVortfarado [EspVortfaradoEco new -childof [self]]

    while {[gets $in line]>=0} {
        set vorto [string trim $line]
        if {[llength [$vortaro sxercxuRezListoPorTraduko $vorto pl]]>0} {
            continue
        }
        if {[PolaVortFarado prenuVortfaradoj $vorto $vortaro] ne ""} {
            continue
        } elseif {[$espReVortfarado remorfiguVorton $vorto $vortaro $fontolingvo] ne ""} {
            continue
        }
        puts $out $line
    }
    $espReVortfarado destroy
    close $in
    close $out

}
Object KorpusoBazitaPlibonigilo
@ ::KorpusoBazitaPlibonigilo idemeta categoriesMethodsProcs {{prenuVerboKazoDosieron modifiuVerboj estasVerboEnKazo trovuVerbojKazo testuKazojnPorVerboj testuVerbojNdkDk} {testuKazojnPorVerbo testuPrepoziciojPorSubstantivo testuAdjektivoSubstantivo} {trovuSinonimojAdjektivoSenKunteksto kreuDosieronSinonimojAdjSenKunteksto kreuSinonimojAdjPlibonigo testuAdjektivoSinonimoj} {trovuSinonimojAdjektivoSenDef trovuDefKandidatoj}}
@ ::KorpusoBazitaPlibonigilo idemeta categoriesProcs {verbo testo-unuopa adjektivo adjektivo-def}
@ ::KorpusoBazitaPlibonigilo idemeta component EspPlTradukilo
KorpusoBazitaPlibonigilo proc estasVerboEnKazo {pverbo kazoj {kazo gen}} {
    if {[dict exists $kazoj $kazo]} {
        set gen [dict get $kazoj $kazo]
    } else {
        return 0
    }
    if {[dict exists $kazoj acc]} {
        set acc [dict get $kazoj acc]
    } else {
        set acc 0
    }
    set max -1
    set maxkey ""
    dict for {key num} $kazoj {
        if {$num>$max} {
            set max $num
            set maxkey $key
        }
    }
    if {$maxkey eq $kazo && $gen>$acc*4 && $gen>2} {
        return 1
    } else {
        return 0
    }
}
KorpusoBazitaPlibonigilo proc kreuDosieronSinonimojAdjSenKunteksto {} {
    set f [open [my prenuDosieron sinonim-adj.txt] w]
    foreach r [my trovuSinonimojAdjektivoSenKunteksto] {
        puts $f $r
    }
    close $f
}
KorpusoBazitaPlibonigilo proc kreuSinonimojAdjPlibonigo {} {
    set f [open [my prenuDosieron sinonim-adj.txt] r]
    set o [open [my prenuDosieron sinonim-adj-plibonigo] a]
    fconfigure $o -buffering line

    while {[gets $f line]>=0} {
        lassign $line espadjektivo pltradukoj
        my testuAdjektivoSinonimoj $espadjektivo $pltradukoj $o
    }
    close $f
    close $o
}
KorpusoBazitaPlibonigilo proc modifiuVerboj {{kazo gen}} {
    set vortaro [DBVortaro prenuVortaron]
    set ret ""
    if {$kazo eq "gen"} {
        set ad [list A D]
    } elseif {$kazo eq "inst"} {
        set ad [list A N]
    }
    foreach pverbo [my trovuVerbojKazo $kazo] {
        foreach tradukod [$vortaro sxercxuRezListoPorTraduko $pverbo pl] {
            set derivo [dict get $tradukod vorto]
            set gramatiko [dict get $tradukod gramatiko]
            if {$ad in $gramatiko} continue
            lappend gramatiko $ad
            append ret "DBVortaro modifuTradukonDeVorto $derivo [list $pverbo] [list [list gramatiko $gramatiko]] pl\n"
        }
    }
    return $ret
}
KorpusoBazitaPlibonigilo proc prenuDosieron nomo {
    file join [Esperantilozentro prenuFontoDosieron] pl_fontoj {*}$nomo
}
KorpusoBazitaPlibonigilo proc prenuVerboKazoDosieron {} {
    file join [Esperantilozentro prenuFontoDosieron] pl_fontoj verboj-kazoj-nombro.txt
}
KorpusoBazitaPlibonigilo proc testuAdjektivoSinonimoj {espadjetivo pltradukoj {out stdout}} {
    set parto [MKFrazpartoFrekBazo prenuBazon]
    set vortaro [DBVortaro prenuDepVortaron]
    set poli [PoliqarpKliento prenuKlienton]

    set rezultoj [dict create]
    set plejofta [dict create]
    
    foreach t $pltradukoj {
        dict set plejofta $t 0
        if {[string first " " $t]>0} {
            puts $out "#ignoru $espadjetivo $pltradukoj - '$t'"
            return
        }
    }

    set i 0
    foreach v [lrange [$parto trovuVortoj $espadjetivo adj {np adj}] 0 30] {
        set v [lindex $v 0]
        if {$i>20 && [lindex $v 1]<2} continue
        if {[llength [set tradukoj [$vortaro sxercxuRezListo $v pl]]]>0} {
            set traddic [lindex $tradukoj 0]
            set traduko [dict get $traddic traduko]
            if {[string first " " $traduko]<0} {
                dict set rezultoj $v traduko $traduko
            }
        }
        incr i
    }

    dict for {k v} $rezultoj {
        set polrezulto [my testuAdjektivoSubstantivo [dict get $v traduko] $pltradukoj $poli $out]
        set pofta 0
        set poftaSinonimo ""
        dict for {k2 v2} $polrezulto {
            if {$v2>$pofta} {
                set poftaSinonimo $k2
                set pofta $v2
            }
        }
        if {$poftaSinonimo ne ""} {
            dict incr plejofta $poftaSinonimo
        }
        dict set rezultoj $k rezulto $polrezulto
        dict set rezultoj $k plejofta $poftaSinonimo
    }
    
    set pofta 0
    set poftaSinonimo ""
    dict for {k v} $plejofta {
        if {$v>$pofta} {
            set poftaSinonimo $k
            set pofta $v
        }
    }
    
    if {$poftaSinonimo ne ""} {
        if {$poftaSinonimo ne [lindex $pltradukoj 0]} {
            puts $out "# la plej ofta sinonimo por $espadjetivo estas $poftaSinonimo"
            puts $out "DBVortaro modifuTradukonDeVorto $espadjetivo [list $poftaSinonimo] {ordo 0} pl"
        }
        dict for {k v} $rezultoj {
            if {[dict get $v plejofta] ne "" && [dict get $v plejofta] ne $poftaSinonimo} {
                dict lappend kunteksto [dict get $v plejofta] $k
            }
        }
        if {[info exists kunteksto]} {
            dict for {k v} $kunteksto {
                puts $out "# kunteksto por traduko $k - (kun $v)"
                puts $out "DBVortaro modifuTradukonDeVorto $espadjetivo [list $k] {sento {{kun $v}}} pl"
            }
        }
    }
    return $rezultoj
}
KorpusoBazitaPlibonigilo proc testuAdjektivoSubstantivo {substantivo adjektivoj {poli {}} {out stdout}} {
    if {$poli eq ""} {
        set poli [PoliqarpKliento prenuKlienton]
    }
    set arez [dict create]
    set abazoj [list]
    foreach a $adjektivoj {
        dict set arez $a 0
        lappend abazoj base=$a
    }
    set query "\[pos=adj & ([join $abazoj { | }])\] \[base=$substantivo & pos=subst\]"
    puts $query
    if {[catch {$poli makeRunQuery $query 80} rez]} {
        puts $out "# erroro cxe $query"
        return $arez
    }
    foreach urezulto $rez  {
        lassign $urezulto lcontext tags rcontext
        foreach {baza tag} [lrange [lindex $tags 0] 1 end] {
            lassign [split $tag :] type nombro kazo genro
            if {$type eq "adj"} {
                dict incr arez $baza
            }
        }
    }
    return $arez
}
KorpusoBazitaPlibonigilo proc testuKazojnPorVerbo {verbo {poli {}}} {
    if {$poli eq ""} {
        set poli [PoliqarpKliento prenuKlienton]
    }
    set kazoj [dict create]
    set rez [$poli makeRunQuery "\[base=$verbo & pos=verb & pos!=ppas & pos!=ger & pos!=fin\] \[pos=subst\]" 40]
    foreach urezulto $rez  {
        lassign $urezulto lcontext tags rcontext
        foreach {baza tag} [lrange [lindex $tags 1] 1 end] {
            lassign [split $tag :] type nombro kazo genro
            if {$type eq "subst"} {
                dict incr kazoj $kazo
            }
        }
    }
    return $kazoj
}
KorpusoBazitaPlibonigilo proc testuKazojnPorVerboj {} {
    set poli [PoliqarpKliento prenuKlienton]
    set fileName [my prenuVerboKazoDosieron]
    set in [open $fileName r]
    while {[gets $in line]>=0} {
        set traduko [lindex $line 0]
        puts "konata $traduko"
        set tradukoArr($traduko) 1
    }
    close $in
    set out [open $fileName a]
    fconfigure $out -buffering line
    set connection [ImportoIlo getVortaroConnection]
    set sql "select traduko,d.derivo,t.gramatiko from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' and t.gramatiko not like '%\{A%'"

    set query [$connection query $sql]
    set vortaro [Vortaro prenuVortaron]

    set i 0
    while {[llength [set row [$query fetch]]]>0} {
         lassign $row traduko derivo gramatiko
         if {[string first " " $traduko]>0} continue
         if {[info exists tradukoArr($traduko)]} continue
         set tradukoArr($traduko) 1
         if {[$vortaro estasVorto $derivo]==2} {
             set elem [$vortaro prenuGramElemento [self] $derivo]
             if {[$elem istype GP::Verbo] && [$elem eblasObjekto]} {
                 puts "testu $traduko"
                 if {![catch {my testuKazojnPorVerbo $traduko $poli} res]} {
                     puts $out "$traduko $res"
                 } else {
                     puts "error by $traduko"
                 }
             }
         }
         if {$i%100} {
             puts "verboj $i"
         }
         incr i
    }
    $query destroy
    close $out
}
KorpusoBazitaPlibonigilo proc testuPrepoziciojPorSubstantivo {substantivo {kandidatoj {}} {poli {}}} {
    if {$poli eq ""} {
        set poli [PoliqarpKliento prenuKlienton]
    }
    set preps [dict create]
    set rez [$poli makeRunQuery "\[pos=prep\] \[base=$substantivo & pos=subst\]" 40]
    foreach urezulto $rez  {
        lassign $urezulto lcontext tags rcontext
        foreach {baza tag} [lrange [lindex $tags 0] 1 end] {
            lassign [split $tag :] type nombro kazo genro
            if {$type eq "prep"} {
                dict incr preps $baza
            }
        }
    }
    return $preps
}
KorpusoBazitaPlibonigilo proc testuVerbojNdkDk {} {
    set if [open [my prenuDosieron {slowniki.org.pl niedok-dokona.txt}] r]
    set adjdesubj [list]
    for {set i 0} {$i<4} {incr i} {gets $if}
    while {[gets $if line]>=0} {
        lassign [split $line =] vndk vdk
        set vndk [string trim $vndk]
        set vdk [string trim $vdk]
        set dk2ndk($vdk) $vndk
        set ndk2dk($vndk) $vdk
    }
    close $if

    set sql {select d.derivo,t.traduko,t.fgrupo,t.gramatiko from traduko_pl t,derivo d where d.id=t.derivoid and d.typo='verbo' order by d.id}

    set connection [ImportoIlo getVortaroConnection]
    set query [$connection query $sql]

    set ret ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row derivo traduko fgrupo gramatiko
        set aspekto ""
        set verbo [lindex $traduko 0]
        if {"dk" in $gramatiko} {
            set aspekto dk
            if {[info exists ndk2dk($verbo)]} {
               append ret "#$traduko - dk ndk2dk $verbo $ndk2dk($verbo)\n"
               append ret "DBVortaro modifuTradukonDeVorto $derivo [list $traduko] [list [list gramatiko ndk]] pl\n"
            }
        } elseif {"ndk" in $gramatiko} {
            set aspekto ndk
            if {[info exists dk2ndk($verbo)]} {
               append ret "#$traduko - ndk dk2ndk $verbo $dk2ndk($verbo)\n"
               append ret "DBVortaro modifuTradukonDeVorto $derivo [list $traduko] [list [list gramatiko dk]] pl\n"
            }
        }
    }
    $query destroy
    return $ret
}
KorpusoBazitaPlibonigilo proc trovuDefKandidatoj {} {
    set if [open [my prenuDosieron {slowniki.org.pl przymodrzecz.txt}] r]
    set adjdesubj [list]
    for {set i 0} {$i<4} {incr i} {gets $if}
    while {[gets $if line]>=0} {
        lassign [split $line =] subst adj
        if {[string range $subst end-1 end] ne "ść"} {
            lappend adjdesubj [string trim $adj]
        }
    }
    close $if

    set if [open [my prenuDosieron {polaj-fontoj-stat frazeologiczny-pl.txt}] r]
    gets $if
    gets $if
    set unua [dict create]
    set dua [dict create]
    while {[gets $if line]>=0} {
        lassign [split $line] uvorto dvorto
        if {$uvorto ne "" && $dvorto ne ""} {
            dict incr unua $uvorto
            dict incr dua $dvorto
        }
    }

    close $if

    set ret ""
    foreach l [my trovuSinonimojAdjektivoSenDef] {
        lassign $l derivo adjektivoj
        foreach adj $adjektivoj {
            set unombro 0
            if {[dict exists $unua $adj]} {
                set unombro [dict get $unua $adj]
            }
            set dnombro 0
            if {[dict exists $dua $adj]} {
                set dnombro [dict get $dua $adj]
            }
            if {$dnombro>$unombro*3 && $unombro<=2 && $adj in $adjdesubj} {
                append ret "DBVortaro modifuTradukonDeVorto $derivo [list $adj] [list [list gramatiko def]] pl\n"
            }
        }
    }
    return $ret
}
KorpusoBazitaPlibonigilo proc trovuSinonimojAdjektivoSenDef {} {

    set connection [ImportoIlo getVortaroConnection]
    set sql "select d.derivo,t.traduko from derivo d,traduko_pl t where d.derivo like '%a' and t.derivoid=d.id and (t.gramatiko is null || t.gramatiko not like '%def%') && traduko not like '% %' order by d.id"

    set query [$connection query $sql]

    set rez [list]

    set adjektivoj [list]
    set lastaderivo ""
    while {[llength [set row [$query fetch]]]>0} {
        lassign $row derivo traduko
        if {$lastaderivo ne $derivo} {
            if {$lastaderivo ne ""} {
                lappend rez [list $lastaderivo $adjektivoj]
                set adjektivoj [list]
                set lastaderivo $derivo
            }
            set lastaderivo $derivo
        }
        lappend adjektivoj $traduko
    }

    $query destroy

    return $rez
}
KorpusoBazitaPlibonigilo proc trovuSinonimojAdjektivoSenKunteksto {} {
    set poli [PoliqarpKliento prenuKlienton]

    set connection [ImportoIlo getVortaroConnection]
    set sql "select d.id from derivo d,traduko_pl t where d.derivo like '%a' and t.derivoid=d.id and (t.sento is null || t.sento = '') group by d.id having count(t.id)>1"

    set rez [list]

    foreach did [$connection queryList $sql] {
        set did [lindex $did 0]
        set sql "select d.derivo,t.traduko from derivo d,traduko_pl t where t.derivoid=d.id and d.id=$did order by t.ordo"
        set query [$connection query $sql]
        set tradukoj [list]
        while {[llength [set row [$query fetch]]]>0} {
             lassign $row derivo traduko
             lappend tradukoj $traduko

        }
        lappend rez [list $derivo $tradukoj]
        $query destroy
    }
    return $rez
}
KorpusoBazitaPlibonigilo proc trovuVerbojKazo kazo {
    set fileName [my prenuVerboKazoDosieron]
    set in [open $fileName r]
    set ret [list]
    while {[gets $in linio]>=0} {
        set pverbo [lindex $linio 0]
        set kazoj [dict create {*}[lrange $linio 1 end]]
        if {[my estasVerboEnKazo $pverbo $kazoj $kazo]} {
            if {![catch {my testuKazojnPorVerbo $pverbo} kazoj]} {
                if {[my estasVerboEnKazo $pverbo $kazoj $kazo]} {
                    lappend ret $pverbo
                }
            } else {
                puts "erroro cxe $pverbo"
            }
        }
    }
    close $in
    return $ret
}
@ Object PolaFleksio {
description {Tiu objekto enhavas funkcio pri pola fleksio kaj vortfarado}
}
Object PolaFleksio
@ ::PolaFleksio idemeta categoriesMethodsProcs {{prenuKonjIndeksoj prenuDeklIndeksoj prenuVerboEsceptoj prenuKazojn prenuAdverboEsceptoj prenuAdjektivoEsceptoj prenuSubstantivoEsceptoj metaPriskribojPor} {initNumeralojn prenuNumeroGis1000 prenuNumeroLauKazoArtoGis1000 prenuBazaNumeroLauKazoArto} {prenuNumero prenuArtoDeTipo prenuSubstantivon sxercxuFGrupoPorVerbo prenuAdjektivon prenuVerbon prenuSubstantivonLauxTipo divenuTiponDeSubstantivo prenuKompleksanSubstantivonLauxTipo prenuPosesivPronomon prenuPersonPronomon} estasVovel {prenuLastanFonemon konstruuTemon vokalAlternacja prenuEstVerbon kunmetuFinilon prenuBazanVerboFormon prenuSubstantivanTemon} {prenuEblajnAdjDeSub divenuEtoFormon} {initializeAfterLoad initKonjugacja initDeklinacja}}
@ ::PolaFleksio idemeta categoriesProcs {admin-api numeraloj api base-functions private vortfarado initialize}
@ ::PolaFleksio idemeta component EspPlTradukilo
PolaFleksio proc divenuEtoFormon substantivo {
    switch -glob -- $substantivo {
        *ło {
            # krzesło
            return [string range $substantivo 0 end-1]ełko
        }
        *ór -
        *ar -
        *er -
        *az {
            # obraz
            return ${substantivo}ek
        }
        *owka -
        *ówka {
            # lodówka
            return [string range $substantivo 0 end-2]óweczka
        }
        *owa -
        *ówa {
            return [string range $substantivo 0 end-2]ówka
        }
        *uk -
        *yk -
        *ak -
        *ik -
        *ek {
            # budynek
            return [string range $substantivo 0 end-1]czek
        }
        *ża {
            # wieża
            return [string range $substantivo 0 end-1]ynka
        }
        *no -
        *wo {
            # drzewo
            return [string range $substantivo 0 end-1]ko
        }
        *da -
        *ła -
        *sa {
            # kiełbasa
            return [string range $substantivo 0 end-1]ka
        }
        *na -
        *ma -
        *ka {
            # książka
            return [string range $substantivo 0 end-2]eczka
        }
        *ko {
            # jajko
            return [string range $substantivo 0 end-2]eczko
        }
        *oga {
            # noga
            return [string range $substantivo 0 end-3]óżka
        }
        *uga -
        *yga {
            # łodyga
            return [string range $substantivo 0 end-2]żka
        }
        *ot -
        *yt -
        *ut -
        *at -
        *et {
            # taboret
            return [string range $substantivo 0 end-1]cik
        }
        *ót {
            # przewrót
            return [string range $substantivo 0 end-2]ocik
        }
        *yd -
        *ud -
        *ad -
        *ed -
        *od {
            # trud
            return ${substantivo}zik
        }
        *ód {
            # samochód
            return [string range $substantivo 0 end-2]odzik
        }
        *do -
        *to {
            # złoto
            return [string range $substantivo 0 end-1]tko
        }
        *ys -
        *as -
        *ąs -
        *um {
            # akwarium
            return ${substantivo}ik
        }
        *szcz {
            return ${substantivo}yk
        }
        *two {
            return [string range $substantivo 0 end-2]ewko
        }
    }
    return
}
PolaFleksio proc divenuTiponDeSubstantivo bazaformo {
    set vovel "aeiuoyęą"
    switch -glob $bazaformo {
        *nie {
            if {[string first [string index $bazaformo end-3] $vovel]!=-1} {
                return 89
            } else {
                return 90
            }
        }
        *ek {
            return 75*
        }
        *ęk {
            return 85
        }
        *ek -
        *atek {
            return 85*
        }
        *y {
            # adjektiva deklinacio
            # biegly, ogolony
            return 53
        }
        *tum -
        *ium {
            return 101
        }
        *isko {
            return 97
        }
        *ysta -
        *ista {
            # kominista, esperantysta
            return 35
        }
        *sie -
        *zie {
            return 90
        }
        *cie {
            if {[string first [string index $bazaformo end-3] $vovel]!=-1 || [string index $bazaformo end-3] eq "ę"} {
                return 89
            } else {
                return 90
            }
        }
        *arz {
            return 11
        }
        *po -
        *bo -
        *wo -
        *mo -
        *to -
        *do -
        *so -
        *zo -
        *no -
        *ło -
        *ro -
        *sto -
        *zdo {
            return 96
        }
        *ał -
        *ór -
        *ar -
        *ur -
        *st -
        *zd {
            return 80
        }
        *cja {
            return 115
        }
        *zja {
            return 124
        }
        *sja {
            return 115
        }
        *yka -
        *ika -
        *oka -
        *eka -
        *ąka -
        *ęka -
        *aka {
            return 112
        }
        *ka {
            return 112*
        }
        *ela -
        *ala -
        *nia {
            return 114
        }
        *ia {
            return 115
        }
        *a {
            return 119
        }
        *ie {
            return 90
        }
        *ość {
            return 105
        }
        *ść {
            return 105
        }
        *ysz -
        *esz {
            return 107
        }
        *oń {
            return 102
        }
        *o {
            return 96
        }
        *nin {
            return 1A
        }
        *ik {
            return 74
        }
        *k {
            return 68
        }
        default {
            # meski niezywotny
            return 80
        }
    }
}
PolaFleksio proc estasVovel char {
    set vovel "aeiuoyęą"
    expr {[string first $char $vovel]>=0}
}
PolaFleksio proc initDeklinacja {} {
    my instvar kazojIndekso dekltabloIndekso
    set i 0
    foreach k {M D C B N Ms W Mx} {
        set kazojIndekso($k) $i
        incr i
    }
    set dekltablo [list]
    # kazoj M D C B N Ms W M D C B N Ms W Mx
    lappend dekltablo {1 {} a owi a em e e e {} om {} ami ach e y}
    lappend dekltablo {2 {} a owi a em e e e ów om ów ami ach e y}
    lappend dekltablo {3 {} a owi a em e e i ów om ów ami ach i y}
    lappend dekltablo {4 {} a owi a em e e owie ów om ów ami ach owie y}
    lappend dekltablo {5 {} a owi a em e e *y ów om ów ami ach *y y}
    lappend dekltablo {6 {} a owi a em u e y ów om ów ami ach y e}
    lappend dekltablo {7 {} a owi a em u u e {} om {} mi ach e e}
    lappend dekltablo {8 {} a owi a em u u e i om i ami ach e e}
    lappend dekltablo {9 {} a owi a em u u e i om i mi ach e e}
    lappend dekltablo {10 {} a owi a em u u e ów om ów ami ach e e}
    lappend dekltablo {11 {} a owi a em u u e y om y ami ach e e}
    lappend dekltablo {12 {} a owi a em u u i ów om ów ami ach i y}
    lappend dekltablo {13 {} a owi a em u u owie ów om ów ami ach owie e}
    lappend dekltablo {14 {} a owi a em u u owie ów om ów ami ach owie i}
    lappend dekltablo {15 {} a owi a em u u owie ów om ów ami ach owie y}
    lappend dekltablo {16 {} a owi a em u u y ów om ów ami ach y e}
    lappend dekltablo {17 {} a owi a em u u *y ów om ów ami ach *y i}
    lappend dekltablo {18 {} a u a em e e a i om i mi ach a y}
    lappend dekltablo {19 {} a u a em e e i ów om ów ami ach i y}
    lappend dekltablo {20 {} a u a em u e a y om y mi ach a a}
    lappend dekltablo {21 {} a u a em u e owie ów om ów ami ach owie e}
    lappend dekltablo {22 {} a u a em u e owie ów om ów ami ach owie i}
    lappend dekltablo {23 {} a u a em u e owie ów om ów ami ach owie y}
    lappend dekltablo {24 {} a u a em u e y ów om ów ami ach y e}
    lappend dekltablo {25 {} i i i ą i i owie ów om ów ami ach owie e}
    lappend dekltablo {26 a ego emu ego ą im o owie ów om ów ami ach owie e}
    lappend dekltablo {27 a i e ę ą e o owie ów om ów ami ach owie i}
    lappend dekltablo {28 a i e ę ą e o *y {} om {} ami ach *y i}
    lappend dekltablo {29 a i e ę ą e o *y ów om ów ami ach *y i}
    lappend dekltablo {30 a i i ę ą i o e i om i ami ach e e}
    lappend dekltablo {31 a i i ę ą i o e ów om ów ami ach e e}
    lappend dekltablo {32 a i i ę ą i o owie ów om ów ami ach owie e}
    lappend dekltablo {33 a i i ę ą i u owie ów om ów ami ach owie e}
    lappend dekltablo {34 a y e ę ą e o i {} om {} ami ach i y}
    lappend dekltablo {35 a y e ę ą e o i ów om ów ami ach i y}
    lappend dekltablo {36 a y e ę ą e o owie ów om ów ami ach owie y}
    lappend dekltablo {37 a y e ę ą e o *y ów om ów ami ach *y y}
    lappend dekltablo {38 a y y ę ą y o e ów om ów ami ach e e}
    lappend dekltablo {39 a y y ę ą y o owie ów om ów ami ach owie e}
    lappend dekltablo {40 a y y ę ą y o y ów om ów ami ach y e}
    lappend dekltablo {41 e ego emu ego em em e owie ów om ów ami ach owie y}
    lappend dekltablo {42 ę a u a em u ę a {} om {} ami ach a a}
    lappend dekltablo {43 i ego emu ego im im i i ich im ich imi ich i e}
    lappend dekltablo {44 i ego emu ego im im i owie ich im ich imi ich owie e}
    lappend dekltablo {45 i ego emu ego im im i *y ich im ich imi ich *y e}
    lappend dekltablo {46 o a owi a em e o owie ów om ów ami ach owie a}
    lappend dekltablo {47 o a owi a em u u e ów om ów ami ach e e}
    lappend dekltablo {48 o a owi a em u u owie ów om ów ami ach owie e}
    lappend dekltablo {49 o a owi a em u u owie ów om ów ami ach owie i}
    lappend dekltablo {50 o i e ę ą e o owie ów om ów ami ach owie i}
    lappend dekltablo {51 o y e ę ą e o owie ów om ów ami ach owie y}
    lappend dekltablo {52 y ego emu ego ym ym y i ych ym ych ymi ych i e}
    lappend dekltablo {53 y ego emu ego ym ym y owie ych ym ych ymi ych owie e}
    lappend dekltablo {54 y ego emu ego ym ym y y ych ym ych ymi ych y e}
    lappend dekltablo {55 y ego emu ego ym ym y *y ych ym ych ymi ych y e}
    lappend dekltablo {56 {} {} {} {} {} {} {} o a u a em e o o}
    lappend dekltablo {57 {} a owi a em e e y ów om y ami ach y Mx}
    lappend dekltablo {58 {} a owi a em u u e i om e ami ach e Mx}
    lappend dekltablo {59 {} a owi a em u u e i om e mi ach e Mx}
    lappend dekltablo {60 {} a owi a em u u e ów om e ami ach e Mx}
    lappend dekltablo {61 {} a owi a em u u e y om e ami ach e Mx}
    lappend dekltablo {62 {} a owi a em u u i ów om i ami ach i Mx}
    lappend dekltablo {63 {} a owi a em u u y ów om y ami ach y Mx}
    lappend dekltablo {64 {} a u a em e e y ów om y ami ach y Mx}
    lappend dekltablo {65 {} u owi u em e e y ów om y ami ach y Mx}
    lappend dekltablo {66 o a owi a em u u e ów om e ami ach e Mx}
    lappend dekltablo {67 y ego emu ego ym ym y e ych ym e ymi ych e Mx}
    lappend dekltablo {68 {} a owi {} em e e y ów om y ami ach y Mx}
    lappend dekltablo {69 {} a owi {} em u u e i om e ami ach e Mx}
    lappend dekltablo {70 {} a owi {} em u u e i om e mi ach e Mx}
    lappend dekltablo {71 {} a owi {} em u u e ów om e ami ach e Mx}
    lappend dekltablo {72 {} a owi {} em u u e y om e ami ach e Mx}
    lappend dekltablo {73 {} a owi {} em u u e y om e mi ach e Mx}
    lappend dekltablo {74 {} a owi {} em u u i i om i ami ach i Mx}
    lappend dekltablo {75 {} a owi {} em u u i ów om i ami ach i Mx}
    lappend dekltablo {76 {} a owi {} em u u y ów om y ami ach y Mx}
    lappend dekltablo {77 {} a u {} em e e y ów om y ami ach y Mx}
    lappend dekltablo {78 {} u e {} em e e a ów om a ami ach a Mx}
    lappend dekltablo {79 o a owi o em e o e ów om e ami ach e Mx}
    lappend dekltablo {80 {} u owi {} em e e y ów om y ami ach y Mx}
    lappend dekltablo {81 {} u owi {} em e u y ów om y ami ach y Mx}
    lappend dekltablo {82 {} u owi {} em u u e i om e ami ach e Mx}
    lappend dekltablo {83 {} u owi {} em u u e ów om e ami ach e Mx}
    lappend dekltablo {84 {} u owi {} em u u e y om e ami ach e Mx}
    lappend dekltablo {85 {} u owi {} em u u i ów om i ami ach i Mx}
    lappend dekltablo {86 {} u owi {} em u u y ów om y ami ach y Mx}
    lappend dekltablo {87 o a owi o em u u e ów om e ami ach e Mx}
    lappend dekltablo {88 y ego emu y ym ym y e ych ym e ymi ych e Mx}
    lappend dekltablo {89 e a u e em u e a {} om a ami ach a Mx}
    lappend dekltablo {90 e a u e em u e a i om a ami ach a Mx}
    lappend dekltablo {91 e a u e em u e a y om a ami ach a Mx}
    lappend dekltablo {92 e ego emu e em em e {} {} {} {} {} {} {} Mx}
    lappend dekltablo {93 e ego emu e em em e {} {} {} {} {} {} {} Mx}
    lappend dekltablo {94 e ego emu e ym ym e e ych ym e ymi ych e Mx}
    lappend dekltablo {95 ę a u ę em u ę a {} om a ami ach a Mx}
    lappend dekltablo {96 o a u o em e o a {} om a ami ach a Mx}
    lappend dekltablo {97 o a u o em u o a {} om a ami ach a Mx}
    lappend dekltablo {98 o a u o em u o a ów om a ami ach a Mx}
    lappend dekltablo {99 o a u o em u o i i om i mi ach i Mx}
    lappend dekltablo {100 o a u o em u o y u om y ami ach y Mx}
    lappend dekltablo {101 um um um um um um um a ów om a ami ach a Mx}
    lappend dekltablo {102 {} i i {} ą i i e i om e ami ach e Mx}
    lappend dekltablo {103 {} i i {} ą i i e i om e mi ach e Mx}
    lappend dekltablo {104 {} i i {} ą i i i i om i ami ach i Mx}
    lappend dekltablo {105 {} i i {} ą i i i i om i mi ach i Mx}
    lappend dekltablo {106 {} y y {} ą y y e y om e ami ach e Mx}
    lappend dekltablo {107 {} y y {} ą y y y y om y ami ach y Mx}
    lappend dekltablo {108 a ej ej ą ą ej a e ich im e imi ich e Mx}
    lappend dekltablo {109 a ej ej ą ą ej a e ych ym e ymi ych e Mx}
    lappend dekltablo {110 a ej ej ą ą ej o e ych ym e ymi ych e Mx}
    lappend dekltablo {111 a i e ę ą e o e {} om e ami ach e Mx}
    lappend dekltablo {112 a i e ę ą e o i {} om i ami ach i Mx}
    lappend dekltablo {113 a i e ę ą e u i {} om i ami ach i Mx}
    lappend dekltablo {114 a i i ę ą i o e {} om e ami ach e Mx}
    lappend dekltablo {115 a i i ę ą i o e i om e ami ach e Mx}
    lappend dekltablo {116 a i i ę ą i u e {} om e ami ach e Mx}
    lappend dekltablo {117 a i i ę ą i u e i om e ami ach e Mx}
    lappend dekltablo {118 a y e ę ą e o e {} om e ami ach e Mx}
    lappend dekltablo {119 a y e ę ą e o y {} om y ami ach y Mx}
    lappend dekltablo {120 {} {} {} {} {} {} {} y {} om y ami ech y Mx}
    lappend dekltablo {121 a y i ę ą i o y i om y ami ach y Mx}
    lappend dekltablo {122 a y y ę ą y o e {} om e ami ach e Mx}
    lappend dekltablo {123 a y y ę ą y o e y om e ami ach e Mx}
    lappend dekltablo {124 i i i ą ą i i e {} om e ami ach e Mx}
    lappend dekltablo {125 i i i ę ą i i e {} om e ami ach e Mx}

    foreach d $dekltablo {
        set dekltabloIndekso([lindex $d 0]) [lrange $d 1 end]
    }
}
PolaFleksio proc initKonjugacja {} {
  my instvar konjtabloIndekso
  # 1 bezokolicznik
  # 2 terazniejszy albo przyszły prosty 1lp
  # 3 terazniejszy albo przyszły prosty 2lp
  # 4 terazniejszy albo przyszły prosty 3lp
  # 5 terazniejszy albo przyszły prosty 1lm
  # 6 terazniejszy albo przyszły prosty 1lm
  # 7 terazniejszy albo przyszły prosty 1lm
  # 8 tryb rozkazujący 2lp
  # 9 tryb rozkazujący 1lm
  # 10 tryb rozkazujący 2lm
  # 11 imiesłów współczesny przymiotnikowy
  # 12 imiesłów współczesny przysłówkowy
  # 13 imiesłów przeszły lp męski
  # 14 imiesłów przeszły lp żeński
  # 15 imiesłów przeszły lp nijaki
  # 16 imiesłów przeszły lm męskoosobowy
  # 17 imiesłów przeszły lm niemęskoosobowy
  # 18 imiesłów przeszły przymiotnikowy lp
  # 19 imiesłów przeszły przymiotnikowy lm
  # 20 imiesłów uprzedni
  # 21 imiesłów bierny lp
  # 22 imiesłów bierny lm
  # 23 forma nieosobowa czasu przesłego
  # 24 rzeczownik odsłowny

  set konjtabloIndekso(I) {ać am asz a amy acie ają aj ajmy ajcie ający ając ał ała ało ali ały {} {} awszy any ani ano anie}
  set konjtabloIndekso(I) {ać am asz a amy acie ają aj ajmy ajcie ający ając ał ała ało ali ały {} {} awszy any ani ano anie}
  set konjtabloIndekso(II) {eć em esz e emy ecie eją ej ejmy ejcie ejący ejąc ał ała ało eli ały {} {} awszy any ani ano enie}
  set konjtabloIndekso(III) {eć eję ejesz eje ejemy ejecie eją ej ejmy ejcie ejący ejąc ał ała ało eli ały ały ali awszy {} {} ano enie}
  set konjtabloIndekso(IV) {ować uję ujesz uje ujemy ujecie ują uj ujmy ujcie ujący ując ował owała owało owali owały {} {} owawszy owany owani owano owanie}
  set konjtabloIndekso(Va) {nąć nę niesz nie niemy niecie ną nij nijmy nijcie nący nąc nął nęła nęło nęli nęły {} {} nąwszy nięty nięci nięto nięcie}
  set konjtabloIndekso(Vb) {nąć nę niesz nie niemy niecie ną ń ńmy ńcie nący nąc nął nęła nęło nęli nęły {} {} nąwszy nięty nięci nięto nięcie}
  set konjtabloIndekso(Vc) {nąć nę niesz nie niemy niecie ną nij nijmy nijcie nący nąc ł ła ło li ły ły li łszy nięty nięci nięto nięcie}
  set konjtabloIndekso(VIa) {ić ę isz i imy icie ą {} my cie ący ąc ił iła iło ili iły {} {} iwszy ony eni ono enie}
  set konjtabloIndekso(VIaj) {ić ę isz i imy icie ą ij ijmy ijcie ący ąc ił iła iło ili iły {} {} iwszy ony eni ono enie}
  set konjtabloIndekso(VIb) {yć ę ysz y ymy ycie ą {} my cie ący ąc ył yła yło yli yły {} {} ywszy ony eni ono enie}
  set konjtabloIndekso(VIIa) {eć ę isz i imy icie ą {} my cie ący ąc ał ała ało eli ały {} {} awszy any ani ano enie}
  set konjtabloIndekso(VIIb) {eć ę ysz y ymy ycie ą {} my cie ący ąc ał ała ało eli ały {} {} awszy any ani ano enie}
  set konjtabloIndekso(VIIIa) {ywać uję ujesz uje ujemy ujecie ują uj ujmy ujcie ujący ując ywał ywała ywało ywali ywały  {} {} ywawszy ywany ywani ywano ywanie}
  set konjtabloIndekso(VIIIb) {iwać uję ujesz uje ujemy ujecie ują uj ujmy ujcie ujący ując iwał iwała iwało iwali iwały {} {} iwawszy iwany iwani iwano iwanie}
  set konjtabloIndekso(IX) {ać ę esz e emy ecie ą {} my cie ący ąc ał ała ało ali ały {} {} awszy any ani ano anie}
  set konjtabloIndekso(Xa) {ć ję jesz je jemy jecie ją j jmy jcie jący jąc ł ła ło li ły {} {} wszy ty ci to cie}
  set konjtabloIndekso(Xb) {ać eję ejesz eje ejemy ejecie eją ej ejmy ejcie ejący ejąc ał ała ało ali ały {} {} awszy any ani ano anie}
  set konjtabloIndekso(Xc) {ąć mę miesz mie miemy miecie mą mij mijmy mijcie mący mąc ął ęła ęło ęli ęły {} {} ąwszy ęty ęci ęto ęcie}
  set konjtabloIndekso(Xcn) {ąć nę niesz nie niemy niecie ną nij nijmy nijcie nący nąc ął ęła ęło ęli ęły {} {} ąwszy ęty ęci ęto ęcie}
  set konjtabloIndekso(XI) {ć ę esz e emy ecie ą {} my cie ący ąc ł ła ło li ły {} {} łszy ony eni ono enie}
  set konjtabloIndekso(XIb) {ć ę esz e emy ecie ą {} my cie ący ąc ł ła ło li ły {} {} łszy ty ci to cie}
}
PolaFleksio proc initNumeralojn {} {
    my instvar  cxefNumeraloj ordoNumeraloj subsNumeraloj opoNumeraloj

    array set cxefNumeraloj {0 zero 1 jeden 2 dwa 3 trzy 4 cztery 5 pi\u0119\u0107 6 sze\u015b\u0107 7 siedem 8 osiem 9 dziewi\u0119\u0107 10 dziesi\u0119\u0107 11 jedena\u015bcie 12 dwana\u015bcie 13 trzyna\u015bcie 14 czterna\u015bcie 15 pi\u0119tna\u015bcie 16 szesna\u015bcie 17 siedemna\u015bcie 18 osiemna\u015bcie 19 dziewi\u0119tna\u015bcie 20 dwadzie\u015bcia 30 trzydzie\u015bci 40 czterdzie\u015bci 50 pi\u0119\u0107dziesi\u0105t 60 sze\u015b\u0107dziesi\u0105t 70 siedemdziesi\u0105t 80 osiemdziesi\u0105t 90 dziewi\u0119\u0107dziesi\u0105t 100 sto 200 dwie\u015bcie 300 trzysta 400 czterysta 500 pi\u0119\u0107set 600 sze\u015b\u0107set 700 siedemset 800 osiemset 900 dziewi\u0119\u0107set 1000 tysi\u0105c 1000000 milion 1000000000 miliard 1000000000000 bilion}

    array set ordoNumeraloj {0 zerowy 1 pierwszy 2 drugi 3 trzeci 4 czwarty 5 pi\u0105ty 6 sz\u00f3sty 7 si\u00f3dmy 8 \u00f3smy 9 dziewi\u0105ty 10 dziesi\u0105ty 11 jedenasty 12 dwunasty 13 trzynasty 14 czternasty 15 pi\u0119tnasty 16 szesnasty 17 siedemnasty 18 osiemnasty 19 dziewi\u0119tnasty 20 dwudziesty 30 trzydziesty 40 czterdziesty 50 pi\u0119\u0107dziesi\u0105ty 60 sze\u015b\u0107dziesi\u0105ty 70 siedemdziesi\u0105ty 80 osiemdziesi\u0105ty 90 dziewi\u0119\u0107dziesi\u0105ty 100 setny 200 dwusetny 300 trzechsetny 400 czterechsetny 500 pi\u0119\u0107setny 600 sze\u015b\u0107setny 700 siedemsetny 800 osiemsetny 900 dziewi\u0119\u0107setny 1000 tysi\u0119czny 1000000 milionowy 1000000000 miliardowy 1000000000000 bilionowy}

    array set opoNumeraloj {1 pojedynczy 2 podw\u00f3jny 3 potr\u00f3jny 4 poczw\u00f3rny 5 pi\u0119ciokrotny 6 sze\u015bciokrotny 7 siedmiokrotny 8 o\u015bmiokrotny 9 dziewi\u0119ciokrotny 10 dziesi\u0119ciokrotny 11 jedenastokrotny 12 dwunastokrotny 13 trzynastokrotny 14 czternastokrotny 15 pi\u0119tnastokrotny 16 szesnastokrotny 17 siedemnastokrotny 18 osiemnastokrotny 19 dziewi\u0119tnastokrotny 20 dwudziestokrotny 30 trzydziestokrotny 40 czterdziestokrotny 50 pi\u0119\u0107dziesi\u0119ciokrotny 60 sze\u015b\u0107dziesi\u0119ciokrotny 70 siedemdziesi\u0119ciokrotny 80 osiemdziesi\u0119ciokrotny 90 dziewi\u0119\u0107dziesi\u0119ciokrotny 100 stokrotny 200 dwustukrotny 300 trzystukrotny 400 czterystukrotny 500 pi\u0119\u0107setkrotny 600 sze\u015b\u0107setkrotny 700 siedemsetkrotny 800 osiemsetkrotny 900 dziewi\u0119\u0107setkrotny 1000 tysi\u0105ckrotny 1000000 milionkrotny 1000000000 miliardkrotny 1000000000000 biliokrotny}

    array set subsNumeraloj {1 jedynka 2 dw\u00f3jka 3 tr\u00f3jka 4 czw\u00f3rka 5 pi\u0105tka 6 sz\u00f3stka 7 si\u00f3demka 8 \u00f3semka 9 dziewi\u0105tka 10 dziesi\u0105tka 11 jedenastka 12 dwunastka 13 trzynastka 14 czternastka 15 pi\u0119tnastka 16 szesnastka 17 siedemnastka 18 osiemnastka 19 dziewi\u0119tnastka 20 dwudziestka 30 trzydziestka 40 czterdziestka 50 pi\u0119\u0107dziesi\u0105tka 60 sze\u015b\u0107dziesi\u0105tka 70 siedemdziesi\u0105tka 80 osiemdziesi\u0105tka 90 dziewi\u0119\u0107dziesi\u0105tka 100 setka 200 dwusetka 300 trzysetka 400 czterysetka 500 pi\u0119\u0107setka 600 sze\u015b\u0107setka 700 siedemsetka 800 osiemsetka 900 dziewi\u0119\u0107setka}

    #foreach c {ę ą ć ś ó} {
    #   lappend map $c \\u[format %04x [scan $c %c]]
    #}
}
PolaFleksio proc initializeAfterLoad {} {
    my instvar adjektivoTablo adjPluralo3 adjPluralo2 kompAdjArr
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazoj: M D C B N Ms W
    # por 'i'-grupo sxangxu ciujn 'y' al 'i'
    set adj {
     {{y y y e a}
      {ego ego ego ego ej}
      {emu emu emu emu ej}
      {ego ego y e ą}
      {ym ym ym ym ą}
      {ym ym ym ym ej}
      {y y y e a}}
     {{y e e e e}
      {ych ych ych ych ych}
      {ym ym ym ym ym}
      {ych e e e e}
      {ymi ymi ymi ymi ymi}
      {ych ych ych ych ych}
      {y e e e e}}
    }
    foreach nombro {singularo pluralo} nombrotab $adj {
        foreach kazo {M D C B N Ms W} kazotab $nombrotab {
            foreach persono {ms mz mn ni ze} finilo $kazotab {
                set sxlosilo "$persono $kazo $nombro"
                set adjektivoTablo($sxlosilo) $finilo
            }
        }
    }
    foreach {bazo pluralo} {sty ści sny śni zny źni sły śli zły źli dzi dzi dzy dzy czy czy  rzy rzy szy si chy si} {
        set adjPluralo3($bazo) $pluralo
    }
    foreach {bazo pluralo} {py pi by bi wy wi my mi sy si ny ni ty ci dy dzi ły li ry rzy ki cy gi dzy ci ci si si zi zi ni ni yi yi pi pi bi bi fi fi wi wi mi mi li li cy cy ży ży ży zi} {
        set adjPluralo2($bazo) $pluralo
    }
    array set kompAdjArr {bielszy biały słodszy słodki zieleńszy zielony większy wielki mniejszy mały świeższy świeży wyższy wysoki szybszy szybki dłuższy długi krótszy krótki lepszy dobry gorętszy gorący odpowiedniejszy odpowiedni mniejszy mały lżejszy lekki wcześniejszy wczesny weselszy wesoły odpowiedniejszy odpowiedni droższy drogi odpowiedniejszy odpowiedni bliższy bliski szerszy szeroki niższy niski brzydszy brzydki bledszy blady cięższy ciężki cięższy ciężki głębszy głęboki bliższy bliski większy duży dalszy daleki krótszy krótki droższy drogi prędszy prędki lżejszy lekki tańszy tani świeższy świeży weselszy wesoły starszy stary rzadszy rzadki dłuższy długi}

    my initDeklinacja
    my initKonjugacja
    my initNumeralojn
}
PolaFleksio proc konstruuTemon vorto {
    set map {si ś ci ć ni ń zi ź}
    foreach {f z} $map {
        if {[string range $vorto end-1 end] eq $f} {
            return [string range $vorto 0 end-2]$z
        }
    }
    if {[string index $vorto end] eq "i"} {
        set vorto [string range $vorto 0 end-1]
    }
    return $vorto
}
PolaFleksio proc kunmetuFinilon {vorto finilo bazaFormo} {
    set porMoligo {z s b w n m p w f}
    set molVokaloj {oąęe}
    if {[string range $bazaFormo end-2 end] eq "ieć"} {
        append molVokaloj a
        lappend porMoligo dz
    }
    set unuaLitero [string index $finilo 0]
    if {[string first $unuaLitero $molVokaloj]>=0} {
        set l [my prenuLastanFonemon $vorto]
        if {$unuaLitero eq "o" && $l eq "dz" && [string range $vorto end-3 end-2] eq "ie"} {
            append vorto i
        } elseif {[lsearch $porMoligo $l]>=0} {
            append vorto i
        }
    }
    return $vorto$finilo
}
PolaFleksio proc metaPriskribojPor vortarto {
    set p {}
    switch -- $vortarto {
        Substantivo {
            set p {
                {ndm {(ndm - nieodmienny) senfleksia}}
                {blp {(blp - bez liczby pojedynczej) sen singularo} blm}
                {blm {(blm - bez liczby mnogiej) sen pluralo} blp}
            }
        }
        Verbo {
            set p {
                {trans {transitiva verbo} ntrans}
                {ntrans {netransitiva verbo} trans}
                {dk {(dk - dokonany) finita} ndk}
                {ndk {(ndk - niedokonany) nefinita} dk}
                {inf {kun infinita frazparto} {}}
                {sensubj {sen subjekto} {}}
                {ref {refleksiva verbo} {}}
            }
        }
        Adjektivo {
            set p {
                {def {post la substantivo (substantivo post adjektivigo)} gen}
                {sub {kiel sola substantivo}}
                {gen {kiel substantivo en genitivo} def}
                {last {adjektivo estas lasta vorto}}
            }
        }
        Adverbo {

        }
    }
    return $p
}
PolaFleksio proc prenuAdjektivoEsceptoj {} {
    return {
        komp komperativo
        sup superlativo
    }
}
PolaFleksio proc prenuAdjektivon {bazaformo arto kazo nombro} {
    # arto: ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    my instvar adjektivoTablo adjPluralo3 adjPluralo2
    set sxlosilo "$arto $kazo $nombro"
    if {![info exists adjektivoTablo($sxlosilo)]} {
        if {[lsearch {ms mz mn ze ni} $arto]<0} {
            error "arto $arto ne konata"
        }
        if {[lsearch {singularo pluralo} $nombro]<0} {
            error "nombro $nombro ne konata"
        }
        if {[lsearch {M D C B N Ms W} $kazo]<0} {
            error "kazo $kazo ne konata"
        }
        error "$sxlosilo ne ekzistas en adjektivo-tablo"
    }
    if {$kazo eq "W"} {
        set kazo M
    }
    # maskulin pluralo nominativo
    if {$kazo eq "M" && $nombro eq "pluralo" && $arto eq "ms"} {
        set fino [string range $bazaformo end-2 end]
        if {[info exists adjPluralo3($fino)]} {
            if {$fino eq "zły" && [string first [string index $bazaformo end-3] "crs"]>0} {
                return [string range $bazaformo 0 end-3]zli
            } elseif {$fino ne "zny" || [string first [string index $bazaformo end-3] "crs"]<0} {
                return [string range $bazaformo 0 end-3]$adjPluralo3($fino)
            }

        }
        set fino [my prenuLastanFonemon [string range $bazaformo 0 end-1]][string index $bazaformo end]
        if {[info exists adjPluralo2($fino)]} {
            return [string range $bazaformo 0 end-2]$adjPluralo2($fino)
        }
        return $bazaformo
    }
    set finilo [string index $bazaformo end]
    set gramFinilo $adjektivoTablo($sxlosilo)
    set temo [string range $bazaformo 0 end-1]
    if {$finilo eq "i"} {
        set gramFinilo [string map {y i} $gramFinilo]
        if {[string index $gramFinilo 0] ne "i"} {
            # zmiękczyć temat
            # w przypadku rodzaju zenskiego
            # przypadek B N i liczba pojedyncza
            # tylo gdy nie grupa 5 (koncowkwi g i k)
            if {($kazo eq "B" || $kazo eq "N") &&
                $arto eq "ze" &&
                $nombro eq "singularo"} {
            } else {
                if {[string first [string index $temo end] "gk"]>=0
                    && [string index $gramFinilo 0] eq "e"} {
                    append temo i
                }
            }
            if {[string first [string index $temo end] "zwpcnms"]>=0 && [string index $temo end] ne "i"} {
                append temo i
            }
        }
    }
    return $temo$gramFinilo
}
PolaFleksio proc prenuAdverboEsceptoj {} {
    return {
        komp komperativo
        sup superlativo
    }
}
PolaFleksio proc prenuArtoDeTipo tipo {
    if {[regexp {([0-9]+)(.*)} $tipo _ tiponombro alt]} {
        if {$tiponombro<=56} {
            set arto ms
        } elseif {$tiponombro>=57 && $tiponombro<=67} {
            set arto mz
        } elseif {$tiponombro>=68 && $tiponombro<=88} {
            set arto mn
        } elseif {$tiponombro>=89 && $tiponombro<=101} {
            set arto ni
        } else {
            # 102-125
            set arto ze
        }
    } else {
        set arto ze
    }
    return $arto
}
PolaFleksio proc prenuBasanAdjDeComp compvorto {
    my instvar kompAdjArr

    if {![catch {set kompAdjArr($compvorto)} bazo]} {
        return $bazo
    }
    if {[string match *iejszy $compvorto]} {
        return [string range $compvorto 0 end-6]y
    } elseif {[regexp {[tdwhb]szy$} $compvorto]} {
        return [string range $compvorto 0 end-3]y
    } elseif {[string match *lszy $compvorto]} {
        return [string range $compvorto 0 end-4]ły
    } elseif {[regexp {[kpn]szy$} $compvorto]} {
        return [string range $compvorto 0 end-3]i
    } elseif {[string match *ślejszy $compvorto]} {
        return [string range $compvorto 0 end-7]sły
    } elseif {[string match *lejszy $compvorto]} {
        return [string range $compvorto 0 end-6]ły
    } elseif {[string match *rzejszy $compvorto]} {
        return [string range $compvorto 0 end-7]ry
    } elseif {[string match *ieńszy $compvorto]} {
        return [string range $compvorto 0 end-6]ony
    } else {
        #my halt
    }
    return $compvorto
}
@ PolaFleksio proc prenuBazaNumeroLauKazoArto {} {
description {bazaj numeroj sed nur por bazaj cifroj!
}
}
PolaFleksio proc prenuBazaNumeroLauKazoArto {numero kazo arto} {
    # tipoj cxef ordo subs opo
    my instvar cxefNumeraloj

    if {$kazo eq "W"} {set kazo M}
    set indeks -1
    set kazoj {M D C B N Ms}
    set artoj {mo mz mn ni ze}
    if {$numero==0} {
        return zero
    }
    if {$numero==1} {
        set indeks [expr {[lsearch $kazoj $kazo]*7+[lsearch $artoj $arto]}]
        set listo {jeden   jeden   jeden   jedno   jedna   jedni   jedne
  jednego jednego jednego jednego jednej  jednych jednych
  jednemu jednemu jednemu jednemu jednej  jednym  jednym
  jednego jednego jeden  jedno  jedn\u0105  jednych jedne
  jednym  jednym  jednym  jednym  jedn\u0105  jednymi jednymi
  jednym  jednym  jednym  jednym  jednej  jednych jednych}
    }
    if {$arto eq "mn" || $arto eq "ni"} {
        set arto "mz"
    }
   if {$numero==2} {
        set artoj {ms mz ze zb}
        set indeks [expr {[lsearch $kazoj $kazo]*4+[lsearch $artoj $arto]}]
        set listo {dwóch dwa dwie dwoje dwóch dwóch dwóch dwojga dwom dwom dwom dwojgu dwóch dwa dwie dwoje dwoma dwoma dwiema dwojgiem dwóch dwóch dwóch dwojgu}
    }
    if {$arto eq "ze"} {
        set arto "mz"
    }
    if {$numero==3 || $numero==4} {
        set artoj {mo mz zb}
        set indeks [expr {[lsearch $kazoj $kazo]*3+[lsearch $artoj $arto]}]
        if {$numero==3} {
            set listo {trzej trzy troje trzech trzech trojga trzem trzem trojgu trzech trzy troje trzema trzema trojgiem trzech trzech trojgu}
        } else {
            set listo {czterej cztery czworo czterech czterech czworga czterem czterem czworgu czterech cztery czworo czterema czterema czworgiem czterech czterech czworgu}
        }
    }
    if {$indeks>=0} {
        return [lindex $listo $indeks]
    }
    if {$arto eq "zb"} {
        error "arto zb ne subtenata"
    }
    set indeks 0
    if {($kazo eq "B" || $kazo eq "M") && $arto ne "mo"} {
       return [my prenuNumero $numero]
    } elseif {$kazo eq "N"} {
        set indeks 1
    }
    if {$numero>4 && $numero<11} {
        switch $numero {
            5 {
                set listo {pięciu pięcioma}
            }
            6 {
                set listo {sześciu sześcioma}
            }
            7 {
                set listo {siedmiu siedmioma}
            }
            8 {
                set listo {ośmiu ośmioma}
            }
            9 {
                set listo {dziewięciu dziewięcioma}
            }
            10 {
                set listo {dziesięciu dziesięcioma}
            }
        }
        return [lindex $listo $indeks]
    }
    switch $numero {
        12 {
            set listo {dwunastu	dwunastoma}
        }
        11 -
        13 -
        14 -
        15 -
        16 -
        17 -
        18 -
        19 {
            set b [string range [my prenuNumero $numero] 0 end-6]
            set listo [list ${b}nastu ${b}nastoma]
        }
        20 {
            set listo {dwudziestu dwudziestoma}
        }
        30 {
            set listo {trzydziestu trzydziestoma}
        }
        40 {
            set listo {czterdziesto czterdziestoma}
        }
        100 {
            set listo {stu stoma}
        }
        200 {
            set listo {dwusto dwustoma}
        }
        300 {
            set listo {trzystu trzystoma}
        }
        400 {
            set listo {czterystu czterystoma}
        }
        1000 {
            set listo {tysiącem tysiącoma}
        }
        default {
            if {$numero>=500 && $numero<1000} {
                 set rnombro [expr {round($numero/100)}]
                 return [my prenuBazaNumeroLauKazoArto $rnombro M mo]set
            }
            if {$numero>40 && $numero<100} {
                set baza [string range [my prenuNumeroGis1000 $numero] 0 end-2]
                if {$indeks==0} {
                    return ${baza}ęciu
                } else {
                    return ${baza}ęcioma
                }
            }
            return $numero
        }
    }
    lindex $listo $indeks
}
PolaFleksio proc prenuBazanVerboFormon {bazaformo def_ref bazo esceptoj fleksGrupo persono arto nombro tempo esceptoArr_ref} {
    upvar $def_ref def
    upvar $esceptoArr_ref esceptoArr

    if {[llength $esceptoj]>0} {
        foreach escepto $esceptoj {
            set esceptoArr([lindex $escepto 0]) [lindex $escepto 1]
        }
        if {$tempo eq "as"} {
            if {$nombro eq "pluralo" && $persono eq "3" && [info exists esceptoArr(3lm)]} {
                set def {}
                return $esceptoArr(3lm)
            }
            if {[info exists esceptoArr(3lp)] && ($persono eq 2 || ($persono eq 3 && $nombro eq "singularo") || ($persono eq 1 && $nombro eq "pluralo"))} {
                set len [string length [lindex $def 3]]
                set bazo [string range $esceptoArr(3lp) 0 end-$len]
                return $bazo
            } elseif {[info exists esceptoArr(1lp)]} {
                set 1prAsSingularo [lindex $def 1]
                set len [string length $1prAsSingularo]
                set bazo [string range $esceptoArr(1lp) 0 end-$len]
                return $bazo
            }
        } elseif {$tempo eq "is"} {
            if {[info exists esceptoArr(p3lp)] && $nombro eq "singularo"} {
                set bazo $esceptoArr(p3lp)
                if {($persono eq "1" || $persono eq "2")} {
                    if {$arto eq "ms" && [info exists esceptoArr(p1lp)] && ($persono eq "1" || $persono eq "2")} {
                        set bazo [string range $esceptoArr(p1lp) 0 end-2]
                    } elseif {[info exists esceptoArr(p3lpze)]} {
                        set bazo [string range $esceptoArr(p3lpze) 0 end-1]
                    } else {
                        set bazo $esceptoArr(p3lp)
                    }
                }
                if {$arto eq "ze"} {
                    if {[info exists esceptoArr(p3lpze)]} {
                        set bazo $esceptoArr(p3lpze)
                    } else {
                        append bazo a
                    }
                } elseif {$arto eq "ni"} {
                    if {[info exists esceptoArr(p3lpze)]} {
                        set bazo [string range $esceptoArr(p3lpze) 0 end-1]o
                    } else {
                        append bazo o
                    }
                }
                set def {{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}}
                return $bazo
            } elseif {[info exists esceptoArr(p3lm)] && $nombro eq "pluralo" && $arto eq "ms"} {
                set bazo $esceptoArr(p3lm)
                set def {{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}}
                return $bazo
            } elseif {[info exists esceptoArr(p3lmze)] && $nombro eq "pluralo" && $arto ne "ms"} {
                set bazo $esceptoArr(p3lmze)
                set def {{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}}
                return $bazo
            } elseif {$arto ne "ms" && [info exists esceptoArr(p3lp)]} {
                set bazo $esceptoArr(p3lp)y
                set def {{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {}}
                return $bazo
            }
        } elseif {[lsearch {at ata it ita ote ate} $tempo]>=0} {
            if {[info exists esceptoArr(3lp)]} {
                set len [string length [lindex $def 3]]
                set bazo [string range $esceptoArr(3lp) 0 end-$len]
            }
            if {$fleksGrupo in {VIa VIaj} && [string first [string index $bazo end] "bnw"]>=0} {
                append bazo i
            }
        }
    }

    if {$fleksGrupo in {VIa VIaj VIIa}} {
       if {($persono eq "1" && $tempo eq "as" && $nombro eq "singularo") ||
            ($persono eq "3" && $tempo eq "as" && $nombro eq "pluralo") ||
            [lsearch {at it ata ita ot ita o ois ate} $tempo]>=0} {
           if {[string first [string index $bazo end] "pbnwm"]>=0} {
               append bazo i
               return $bazo
           } elseif {[string first [string index $bazo end] "oea"]>=0} {
               append bazo j
               return $bazo
           } elseif {[string index $bazo end] eq "s" && [my estasVovel [string index $bazo end-1]]} {
               append bazo z
               return $bazo
           } elseif {[string index $bazo end] eq "z" && [string range $bazo end-1 end] ne "dz"} {
               #if {$tempo ne "o" && $tempo ne "ois" && $tempo ne "at" && $tempo ne "ata"} {
                   set bazo [string range $bazo 0 end-1]ż
               #} else {
               #    append bazo i
               #}
               return $bazo
           } elseif {[string range $bazo end-1 end] eq "śc"} {
               set bazo [string replace $bazo end-1 end]szcz
               return $bazo
           }
       }
   } elseif {$fleksGrupo eq "IX"} {
       if {[string first [string index $bazo end] "bpmw"]>=0 &&
            $tempo eq "as"} {
            # kąpać
            if {[string index $bazo end] eq "w"
                && (($nombro eq "singularo" && $persono eq "1")  ||
                    ($nombro eq "pluralo" && $persono eq "3"))} {
                     return $bazo
                    } else {
                append bazo i
                return $bazo
              }
       } elseif {[string index $bazo end] eq "t" && $tempo eq "as"} {
           set bazo [string replace $bazo end end cz]
       } elseif {[my prenuLastanFonemon $bazo] eq "z" && $tempo eq "as"} {
           set bazo [string replace $bazo end end ż]
       }
    }
    if {$fleksGrupo eq "VIIa" && $tempo eq "as" && [string index $bazo end] eq "i"} {
        # śmierdzieć
        set tbazo [string range $bazo 0 end-1]
        if {[my prenuLastanFonemon $tbazo] eq "dz"} {
            set bazo $tbazo
        }
    }
    return $bazo

}
PolaFleksio proc prenuDeklIndeksoj {} {
  return {1A 2 2A 3 3' 3* 3** 3*** 3^ 4 4' 4* 4** 5 5' 5* 5** 5^ 6* 6** 7 8 8* 9 10 10' 10* 10** 11 12 13 13' 13* 13** 14 14' 14* 15 16 16* 16** 17 17* 18 19 19* 20 21* 22' 23 24** 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 52^ 52^^ 53 54 55 56 57 57' 57* 57** 57*** 58 58' 58* 58** 59 60 60' 60* 60** 61 61' 61'' 62 62' 62* 63 64 64* 64** 65' 66 67 68 68' 68* 68** 68*** 68^' 69 69' 69* 69** 69*@ 70 71 71' 71* 71** 71*@ 72 72' 72'' 73'' 74 74** 75 75' 75* 76 77* 77^ 78 79 80 80' 80* 80** 80*@ 80^ 80^' 81 82 82' 82* 82** 83 83' 83* 83** 84 85 85@ 85' 85* 86 86* 87 88 89 89@ 89' 89'@ 90 91 92 93 94 95 96 96@ 96' 96* 96** 96^ 96^* 97 97' 97* 98 99 100 101 102 102' 102* 102** 103 104 104* 104*@ 105 106 106' 107 107* 108 109 110 111'@ 112 112' 112* 113* 114 114' 114* 115 116 117 118 119 119' 119* 119** 119^ 120 120** 121 122 122' 122* 122** 123 124 125}
}
PolaFleksio proc prenuEblajnAdjDeSub substantivo {
    set sufiksoj {owy ski yczny yjny}
    set bazaformo [my prenuSubstantivanTemon $substantivo]
    lappend temoj $bazaformo
    switch -glob -- $bazaformo {
        *ani {
            # zachowanie - zachowawczy
            set temoj [string range $bazaformo 0 end-3]
            lappend sufiksoj awczy
        }
        *eni {
            # podejrzenie - podejrzliwy
            set temoj [string range $bazaformo 0 end-3]
            lappend sufiksoj liwy alny
        }
        *ium {
            lappend temoj [string range $bazaformo 0 end-3]
            lappend sufiksoj yjny
        }
        *um {
            # uniwersum - uniwersalny
            lappend temoj [string range $bazaformo 0 end-2]
            lappend sufiksoj alny ualny
        }
        *j {
            # kreacja - kreacyjny
            lappend temoj [string range $bazaformo 0 end-1]
            lappend sufiksoj yjny
        }
        *f {
            # fotograf - fotograficzny
            lappend sufinksoj iczny
        }
        *b -
        *k {
            # robonik - robotniczy
            # beletrystyka - beletrystyczny
            lappend temoj [string range $bazaformo 0 end-1]cz
            lappend sufiksoj y ny
        }
        *s -
        *n {
            # gowno - gowniany
            lappend sufiksoj iany
        }
        *i {
            # partia - partyjny
            lappend temoj [string range $bazaformo 0 end-1]
        }
    }
    set rez [list]
    foreach temo $temoj {
        foreach suf $sufiksoj {
            lappend rez $temo$suf
        }
    }
    return $rez
}
PolaFleksio proc prenuEstVerbon {persono arto nombro tempo} {
    # persono: 1 2 3
    # arto: ms ze ni
    # nombro: singularo pluralo
    # tempo: as os is u us ata oto ita anta onta inta
    if {($arto eq "mz" || $arto eq "mn") && $nombro ne "pluralo"} {
        set arto ms
    }
    switch $tempo {
        as {
            incr persono -1
            set listo {jestem jesteś jest jesteśmy jesteście są}
            if {$nombro eq "pluralo"} {
                incr persono 3
            }
            return [lindex $listo $persono]
        }
        is {
            incr persono -1
            set listo {byłem byłam byłeś byłaś był była było byliśmy byłyśmy byliście byłyście byli były}
            set indekso 0
            if {$nombro eq "pluralo"} {
                incr indekso 7
            }
            incr indekso [expr {$persono*2}]
            if {$arto ne "ms"} {
                incr indekso 1
            }
            if {$arto eq "ni" && $persono==2 && $nombro eq "singularo"} {
                incr indekso 1
            }
            return [lindex $listo $indekso]
        }
        os {
            set listo {będę będziesz będzie będziemy będziecie będą}
            incr persono -1
            if {$nombro eq "pluralo"} {
                incr persono 3
            }
            return [lindex $listo $persono]
        }
        onta -
        ont {
            # nur onta
            return "przyszły"
        }
        inta -
        int {
            # nur inta
            return "były"
        }
        anta -
        ant {
            # nur anta
            return "obecny"
        }
        u {
            if {$nombro eq "singularo"} {
                return "bądź"
            } else {
                return "bądźcie"
            }
        }
        us {
            incr persono -1
            set listo {byłbym byłabym byłbyś byłbyś byłby byłaby byłoby bylibyśmy byłybyśmy bylibyście byłybyście byliby byłyby}
            set indekso 0
            if {$nombro eq "pluralo"} {
                incr indekso 7
            }
            incr indekso [expr {$persono*2}]
            if {$arto ne "ms"} {
                incr indekso 1
            }
            if {$arto eq "ni" && $persono==2 && $nombro eq "singularo"} {
                incr indekso 1
            }
            return [lindex $listo $indekso]
        }
        i {
            return być
        }
        o {
            return bycie
        }
        ate {
            return będąc
        }
        defualt {
            error "{esti}"
        }
    }
}
PolaFleksio proc prenuFleksgrupojPorSubstantivo {} {
    my prenuDeklIndeksoj
}
PolaFleksio proc prenuFleksgrupojPorVerbo {} {
    my prenuKonjIndeksoj
}
PolaFleksio proc prenuKazojn {} {
    return {
        M {Mianownik - Nominativo}
        D {Dopełniacz - Genetivo}
        C {Celownik - Dativo}
        B {Biernik - Akuzativo}
        N {Nadrzędnik - Instrumentalo}
        Ms {Miejscownik - Lokativo}
        W {Wołacz - Vokativo}
    }
}
PolaFleksio proc prenuKompleksanSubstantivonLauxTipo {bazaformo fleksGrupo kazo nombro} {
    if {[llength $bazaformo]==1} {
        my prenuSubstantivonLauxTipo $bazaformo $fleksGrupo $kazo $nombro
    } elseif {[llength $bazaformo]>2} {
        join [concat [my prenuSubstantivonLauxTipo [lindex $bazaformo 0] $fleksGrupo $kazo $nombro] [lrange $bazaformo 1 end]]
    } else {
        if {"adjsub" in $fleksGrupo} {
            return [join [concat [my prenuAdjektivon [lindex $bazaformo 0] [my prenuArtoDeTipo $fleksGrupo] $kazo $nombro] [my prenuSubstantivonLauxTipo [lindex $bazaformo 1] $fleksGrupo $kazo $nombro]]]
        }
        switch -glob [lindex $bazaformo 1] {
            *owa -
            *owe -
            *owy -
            *ski -
            *ska -
            *skie -
            *ąca -
            *ące -
            *ący -
            *ęca -
            *ęce -
            *ęcy -
            *cza -
            *cze -
            *czy -
            *ckie -
            *cka -
            *cki -
            *na -
            *ne -
            *ny {
                # dua parto sxajnas esti adjektivo
                set adj [lindex $bazaformo 1]
                if {[string range $adj end-1 end] eq "ie"} {
                    set adj [string replace $adj end-1 end i]
                }
                join [concat [my prenuSubstantivonLauxTipo [lindex $bazaformo 0] $fleksGrupo $kazo $nombro] [my prenuAdjektivon $adj [my prenuArtoDeTipo $fleksGrupo] $kazo $nombro]]
            }
            default {
                join [concat [my prenuSubstantivonLauxTipo [lindex $bazaformo 0] $fleksGrupo $kazo $nombro] [lrange $bazaformo 1 end]]
            }
        }
    }
}
PolaFleksio proc prenuKonjIndeksoj {} {
  my instvar konjtabloIndekso
  lsort [array names konjtabloIndekso]
}
PolaFleksio proc prenuLastanFonemon vorto {
    set duliteroj {rz cz dz sz ch dż dź}
    if {[lsearch $duliteroj [string range $vorto end-1 end]]>=0} {
        return [string range $vorto end-1 end]
    }
    string index $vorto end
}
PolaFleksio proc prenuNumero {numero {arto cxef}} {
    # cxef ordo subs opo
    if {[lsearch {cxef ordo subs opo} $arto]<0} {
        error "atendas 'cxef ordo subs opo' kiel arto. estis $arto"
    }
    my instvar cxefNumeraloj
    set rez [list]
    if {$numero==0} {
        return zero
    }
    set seplisto {1000000000000 bilion\u00f3w biliony bilion
                  1000000000    miliard\u00f3w miliardy miliard
                  1000000       milion\u00f3w miliony milion
                  1000          tysi\u0119cy tysi\u0105ce tysi\u0105c}

    foreach {num 5vorto 2vorto 1vorto} $seplisto {
        if {$numero>=$num} {
            set mdlimo [expr {$num/1000}]
            set rnum [expr {round($numero/$num)}]
            if {$rnum==0} continue
            if {$rnum!=1} {
                foreach r [my prenuNumeroGis1000 $rnum] {
                    lappend rez $r
                }
            }
            if {$rnum==1} {
                lappend rez $1vorto
            } elseif {$rnum%10<5 && ($rnum%100>15 || $rnum%100<5)} {
                lappend rez $2vorto
            } else {
                lappend rez $5vorto
            }
            set numero [expr {$numero%$num}]
        }
    }
    if {$numero!=0} {
        foreach r [my prenuNumeroGis1000 $numero $arto] {
            lappend rez $r
        }
    }
    join $rez
}
PolaFleksio proc prenuNumeroGis1000 {numero {arto cxef}} {
    my instvar cxefNumeraloj ordoNumeraloj subsNumeraloj opoNumeraloj
    set rez [list]
    set sparatilo 100
    set num [expr {$numero%$sparatilo}]
    if {$num<20} {
        if {$num>0} {
            lappend rez [set ${arto}Numeraloj($num)]
        }
        set arto cxef
    } else {
        set j [expr {$num%10}]
        set d [expr {$num-$j}]
        if {$j>0} {
            lappend rez [set ${arto}Numeraloj($j)]
        }
        if {$d>0} {
            if {$arto ne "ordo"} {
                set arto cxef
            }
            lappend rez [set ${arto}Numeraloj($d)]
        }
        set arto cxef
    }
    set 100num [expr {round($numero/100)*100}]
    if {$100num>=100} {
        lappend rez [set ${arto}Numeraloj($100num)]
    }
    set rrez [list]
    for {set i [expr {[llength $rez]-1}]} {$i>=0} {incr i -1} {
        lappend rrez [lindex $rez $i]
    }
    return $rrez
}
PolaFleksio proc prenuNumeroLauKazoArtoGis1000 {numero kazo arto} {
    # tipoj cxef ordo subs opo
    set rez [list]
    set sparatilo 100
    set num [expr {$numero%$sparatilo}]
    if {$num<20} {
        if {$num>0} {
            lappend rez [my prenuBazaNumeroLauKazoArto $num $kazo $arto]
        }
    } else {
        set j [expr {$num%10}]
        set d [expr {$num-$j}]
        if {$j>0} {
            if {$j==1} {
                lappend rez jeden
            } else {
                lappend rez [my prenuBazaNumeroLauKazoArto $j $kazo $arto]
            }
        }
        if {$d>0} {
            lappend rez [my prenuBazaNumeroLauKazoArto $d $kazo $arto]
        }
    }
    set 100num [expr {round($numero/100)*100}]
    if {$numero%100!=0} {
        set kazo M
        set arto mn
    }
    if {$100num>=100} {
        lappend rez [my prenuBazaNumeroLauKazoArto $100num $kazo $arto]
    }
    set rrez [list]
    for {set i [expr {[llength $rez]-1}]} {$i>=0} {incr i -1} {
        lappend rrez [lindex $rez $i]
    }
    join $rrez
}
PolaFleksio proc prenuPersonPronomon {bazaformo arto kazo nombro {prepozicia 0}} {
    # arto: ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    my instvar kazojIndekso
    set i $kazojIndekso($kazo)
    # TODO cxangxu kazo laux arto
    switch $bazaformo {
        mi {
           set listo {ja mnie mi mnie mną mnie ja}
        }
        vi {
           if {$nombro ne "pluralo"} {
               # "tobie" por C estas por LangaugeTool eraro
               # ankaux ciebie por B
               # {ty ciebie tobie ciebie tobą tobie ty}
               set listo {ty ciebie ci cię tobą tobie ty}
           } else {
               set listo {wy was wam was was wami wy}
           }
        }
        ŝi {
            if {$prepozicia} {
               set listo {ona niej niej nią nią niej ona}
            } else {
               set listo {ona jej jej ją ją jej ona}
            }
        }
        li {
           if {$prepozicia} {
               set listo {on niego niemu niego nim nim on}
           } else {
               set listo {on jego jemu jego nim nim on}
           }
        }
        ĝi {
           switch $arto {
               ms {
                   return [my prenuPersonPronomon li $arto $kazo $nombro $prepozicia]
               }
               ze {
                   return [my prenuPersonPronomon ŝi $arto $kazo $nombro $prepozicia]
               }
               default {
                   if {$prepozicia} {
                       set listo {ono niego niemu niego nim nim ono}
                   } else {
                       set listo {ono jego jemu jego nim nim ono}
                   }
               }
           }
        }
        ni {
           set listo {my nas nam nas nami nas my}
        }
        ili {
           if {$prepozicia} {
               if {[string index $arto 0] ne "m"} {
                   return [lindex {one nich nim nich nimi nich one} $i]
               } else {
                   return [lindex {oni nich nim nich nimi nich oni} $i]
               }
           } else {
               if {[string index $arto 0] ne "m"} {
                   return [lindex {one ich im ich nimi ich one} $i]
               } else {
                   return [lindex {oni ich im ich nimi ich oni} $i]
               }
          }
        }
        si {
            set listo {sobie siebie sobie siebie sobą sobie sobie}
        }
        kia {
            set listo {jaki jakiego jakiemu jaki jakim jakim jaki}
        }
        kiu {
            set listo {kto kogo komu kogo kim kim kto}
        }
        kio {
            set listo {co czego czemu co czym czym co}
        }
        neniu {
            set listo {nikt nikogo nikomu nikogo nikim nikim nikt}
        }
        nenio {
            set listo {nic niczego niczemu nic niczym niczym nic}
        }
        iu {
            if {$nombro eq "singularo"} {
                set listo {ktoś kogoś komuś kogoś kimś kimś ktoś}
            } else {
                set listo {jedni jednych jednym jednych jednymi jednych jedni}
            }
        }
        ĉiu {
            if {$nombro eq "singularo"} {
                switch $arto {
                    ms -
                    mz {
                        set listo {każdy każdego każdemu każdego każdym każdym każdy}
                    }
                    mn {
                        set listo {każdy każdego każdemu każdy każdym każdym każdy}
                    }
                    ze {
                        set listo {każda każdej każdej każdą każdą każdej każda}
                    }
                    default {
                        set listo {każde każdego każdemu każde każdym każdym każde}
                    }
                }
            } else {
                if {$arto ne "ms"} {
                    set listo {wszystkie wszystkich wszystkim wszystkie wszystkimi wszystkich wszystkie}
                } else {
                    set listo {wszyscy wszystkich wszystkim wszystkich wszystkimi wszystkich wszyscy}
                }
            }
        }
        io {
            set listo {coś czegoś czemuś coś czymś czymś coś}
        }
        tio {
            set listo {to tego temu to tym tym to}
        }
        ĉio {
            set listo {wszystko wszystko wszystkiemu wszystko wszystkim wszystkim wszystko}
        }
        tiu {
            if {$nombro eq "singularo"} {
                switch $arto {
                    ms -
                    mz {
                        set listo {ten tego temu tego tym tym ten}
                    }
                    mn {
                        set listo {ten tego temu ten tym tym ten}
                    }
                    ze {
                        set listo {ta tej tej tę tą tą tej}
                    }
                    default  {
                        set listo {to tego temu to tym tym to}
                    }
                }

            } else {
                if {$arto eq "ms"} {
                    set listo {ci tych tym tych tymi tych ci}
                } else {
                    set listo {te tych tym te tymi tych te}
                }
            }
        }
        tia {
            if {$nombro eq "singularo"} {
                switch $arto {
                    ms -
                    mz {
                        set listo {taki takiego takiemu takiego takim takim taki}
                    }
                    mn {
                        set listo {taki takiego takiemu taki takim takim taki}
                    }
                    ze {
                        set listo {taka takiej takiej taką takiej taką taka}
                    }
                    default  {
                        set listo {takie takie takiemu takiem takim takim takie}
                    }
                }

            } else {
                if {$arto eq "ms"} {
                    set listo {tacy takich takim takich takimi takich tacy}
                } else {
                    set listo {takie takich takim takie takimi takich tekie}
                }
            }
        }
        ĉia {
            if {$nombro eq "singularo"} {
                switch $arto {
                    ms -
                    mz {
                        set listo {wszelaki wszelaiego wszelakiemu wszelakiego wszelakim wszelakim wszelaki}
                    }
                    mn {
                        set listo {wszelaki wszelakiego wszelakiemu wszelaki wszelakim wszelakim wszelaki}
                    }
                    ze {
                        set listo {wszelaka wszelakiej wszelakiej wszelaką wszelakiej wszelaką wszelaka}
                    }
                    default  {
                        set listo {wszelakie wszelakie wszelakiemu wszelakiem wszelakim wszelakim wszelakie}
                    }
                }

            } else {
                if {$arto eq "ms"} {
                    set listo {wszelacy wszelakich wszelakim wszelakich wszelakimi wszelakich wszelacy}
                } else {
                    set listo {wszelakie wszelakich wszelakim wszelakie wszelakimi wszelakich wszelakie}
                }
            }
        }
        kelka {
            if {$arto ne "ms"} {
                set listo {kilka kilku kilku kilka kilkoma kilku kilka}
            } else {
                set listo {kilku kilku kilku kilku kilkoma kilku kilka}
            }
        }
        multe {
            if {$arto ne "ms"} {
                set listo {wiele wielu wielu wiele wieloma wielu wiele}
            } else {
                set listo {wielu wielu wielu wielu wieloma wielu wielu}
            }
        }
        kiom {
            if {$arto ne "ms"} {
                set listo {ile ilu ilu ile iloma ilu ile}
            } else {
                set listo {ilu ilu ilu ilu iloma ilu ilu}
            }
        }
        tiom {
            if {$arto ne "ms"} {
                set listo {tyle tylu tylu tyle tyloma tylu tyle}
            } else {
                set listo {tylu tylu tylu tylu tyloma tylu tylu}
            }
        }
        default {
            return [my prenuPosesivPronomon $bazaformo $arto $kazo $nombro]
        }
    }
    return [lindex $listo $i]
}
PolaFleksio proc prenuPosesivPronomon {bazaformo arto kazo nombro} {
    # arto: ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    # TODO
    my instvar kazojIndekso pronIndekso
    set i $kazojIndekso($kazo)
    # TODO cxangxu kazo laux arto
    # 0 MW m. = B m-nżyw.	
    # 1 MBW n.	
    # 2 MW ż.	
    # 3 D m. n. = B m-os. m-żyw.	
    # 4 DCMs ż.	
    # 5 C m. n.	
    # 6 BN ż.
    # 7 NMs m. n.	
    # 8 liczba mnoga MW m-os.
    # 9 MBW n-m-os.
    # 10 DMs = B m-os.
    # 11 C
    # 12 N
    if {$nombro eq "pluralo"} {
        if {$arto ne "ms"} {
            set arto ze
        }
    }
    if {$arto eq "mz"} {
        set arto ms
    }
    if {![array exists pronIndekso]} {
        array set pronIndekso {
            {singularo ms M} 0
            {singularo ms D} 3
            {singularo ms B} 3
            {singularo ms C} 5
            {singularo ms Ms} 7
            {singularo ms N} 7
            {singularo ms W} 0
            {singularo mn M} 0
            {singularo mn D} 3
            {singularo mn B} 0
            {singularo mn C} 5
            {singularo mn Ms} 7
            {singularo mn N} 7
            {singularo mn W} 0
            {singularo ze M} 2
            {singularo ze D} 4
            {singularo ze B} 6
            {singularo ze C} 4
            {singularo ze Ms} 4
            {singularo ze N} 6
            {singularo ze W} 2
            {singularo ni M} 1
            {singularo ni D} 3
            {singularo ni B} 1
            {singularo ni C} 5
            {singularo ni Ms} 7
            {singularo ni N} 7
            {singularo ni W} 1

            {pluralo ms M} 8
            {pluralo ms D} 10
            {pluralo ms B} 10
            {pluralo ms C} 11
            {pluralo ms Ms} 10
            {pluralo ms N} 12
            {pluralo ms W} 8
            {pluralo ze M} 9
            {pluralo ze D} 10
            {pluralo ze B} 9
            {pluralo ze C} 11
            {pluralo ze Ms} 10
            {pluralo ze N} 12
            {pluralo ze W} 9
        }
    }
    set key "$nombro $arto $kazo"
    if {![info exists pronIndekso($key)]} {
        puts "falsa gramatika disingilo: $key"
        return "(arto? $bazaformo)"
    }
    set indekso $pronIndekso($key)
    switch $bazaformo {
        mia {
           set listo {mój moje moja mojego mojej mojemu	moją moim moi moje moich moim moimi}
        }
        via {
           set listo {twój twoje twoja twojego twojej twojemu twoją twym twoi twoje twoich twoim twoimi}
           # vi en pluralo
           # set listo {wasz wasze wasza waszego waszej waszemu waszą waszym wasi wasze waszych waszym waszymi}
        }
        viaj {
            set listo {wasz wasze wasza waszego waszej waszemu waszą waszym wasi wasze waszych waszym waszymi}
        }
        ĝia {
           return "jego"
        }
        lia {
            return "jego"
        }
        ŝia {
            return "jej"
        }
        nia {
           set listo {nasz nasze nasza naszego naszej naszemu naszą naszym nasi nasze naszych naszym	naszymi}
        }
        ilia {
            return "ich"
        }
        sia {
           set listo {swój swoje swoja swojego swojej swojemu swoją swoim swoje swoje swoich swoim swoimi}
        }
        kiu {
            set listo {który które która którego której któremu którą którym którzy które których którym którymi}
        }
        kia {
            set listo {jaki jakie jaka jakiego jakiej jakiemu jaką jakim jacy jakie jakich jakim jakimi}
        }
        nenia -
        neniu {
            set listo {żaden żadne żadna żadnego żadnej żadnemu żadną żadnym żadni żadne żadnych żadnym żadnymi}
        }
        tiu {
            set listo {ten to ta tego tej temu tę tym ci te tych tym tymi}
        }
        tia {
            set listo {taki takie taka takiego takiej takiemu taką takim tacy takie takich takim takimi}
        }
        ia -
        iu {
            set listo {jakiś jakieś jakaś jakiegoś jakiejś jakiemuś jakąś jakimś jacyś jakieś jakichś jakimś jakimiś}
        }
        ĉiu {
            set listo {każdy każde każda każdego każdej każdemu każdą każdym wszyscy wszystkie wszystkich wszystkim wszystkimi}
        }
        ĉia {
            set listo {wszelaki wszelakie wszelaka wszelakiego wszelakiej wszelakiemu wszelaką wszelakim wszalaczy wszelakie wszelakich wszelakim wszelakimi}
        }
        mem {
            set listo {sam samo sama samego samej samemu samą samym samą sami same samych samym samymi}
        }
        iom {
            # ne estas vara posesiv pronome sed funkcial kial adjektivo
            # iom estas numeralo
            return "ileś"
        }
        tiom {
            return "tyle"
        }
        ĉiom {
            return "wszelaka"
        }
        kiom {
            set listo {który które która którego której któremu którą którym którzy które których którym którymi}
        }
        onia -
        oni -
        kies {
            set listo {czyj czyje czyja czyjego czyjej czyjemu czyją czyim czyji czyje czyich czyim czyimi}
        }
        nenies {
            set listo {niczyj niczyje niczyja niczyjego niczyjej niczyjemu niczyją niczyim niczyji niczyje niczyich niczyim niczyimi}
        }
        ties {
            set listo {tego tego tej tego tej tego jej tego ich ich ich ich ich}
        }
        ies {
            set listo {czyjś czyjeś czyjaś czyjegoś czyjejś czyjemuś czyjąś czyimś czyjiś czyjeś czyichś czyimś czyimiś}
        }
        default {
            #my halt
            error "adj. pronomo $bazaformo ne konata"
        }
    }
    return [lindex $listo $indekso]
}
PolaFleksio proc prenuPseudoNumeralon {bazaformo arto kazo} {
    # arto: ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    my instvar kazojIndekso
    set i $kazojIndekso($kazo)
    # TODO cxangxu kazo laux arto
    switch $bazaformo {
        kelke {
            if {$arto ne "ms"} {
                set listo {kilka kilku kilku kilka kilkoma kilku kilka}
            } else {
                set listo {kilku kilku kilku kilku kilkoma kilku kilka}
            }
        }
        multe {
            if {$arto ne "ms"} {
                set listo {wiele wielu wielu wiele wieloma wielu wiele}
            } else {
                set listo {wielu wielu wielu wielu wieloma wielu wielu}
            }
        }
        kiom {
            if {$arto ne "ms"} {
                set listo {ile ilu ilu ile iloma ilu ile}
            } else {
                set listo {ilu ilu ilu ilu iloma ilu ilu}
            }
        }
        tiom {
            if {$arto ne "ms"} {
                set listo {tyle tylu tylu tyle tyloma tylu tyle}
            } else {
                set listo {tylu tylu tylu tylu tyloma tylu tylu}
            }
        }
        default {
            error "ne konata substantiva pronomo $bazaformo"
        }
    }
    return [lindex $listo $i]
}
PolaFleksio proc prenuSubstantivanTemon bazaformo {
    # sercxu temon
    array set miekkie {ć ci dź dzi ń ni ś si ź zi}
    set k [string index $bazaformo end]
    if {[string first $k "aeęoyi"]>=0} {
        set bazaformo [string range $bazaformo 0 end-1]
    }
    switch -- [string index $bazaformo end] {
        ń {
            set bazaformo [string range $bazaformo 0 end-1]ni
        }
        ź {
            set bazaformo [string range $bazaformo 0 end-1]zi
        }
        ć {
            set bazaformo [string range $bazaformo 0 end-1]ci
        }
        ś {
            set bazaformo [string range $bazaformo 0 end-1]si
        }
    }
    return $bazaformo
}
PolaFleksio proc prenuSubstantivoEsceptoj {} {
    return {
        fb {baza formo}
        fblm {baza formo por pluralo}
        M {Nominativo}
        D {Genetivo}
        C {Dativo}
        B {Akuzativo}
        N {Instrumentalo}
        Ms {Lokativo}
        W {Vokativo}
        Mlm {Nominativo pluralo}
        Dlm {Genetivo pluralo}
        Clm {Dativo pluralo}
        Blm {Akuzativo pluralo}
        Nlm {Instrumentalo pluralo}
        Mslm {Lokativo pluralo}
        Wlm {Vokativo pluralo}
        adjsub {adjektivo + substantivo}
    }
}
PolaFleksio proc prenuSubstantivon {bazaformo arto kazo nombro} {
    # arto: ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    set tipo 10
    switch $arto {
        ms {
            set tipo 10
        }
        mn {
            set tipo 10
        }
        mz {
            set tipo 10
        }
        ze {
            set tipo 119
        }
        ni {
            set tipo 96
        }
    }
    my prenuKompleksanSubstantivonLauxTipo $bazaformo $tipo $kazo $nombro
}
PolaFleksio proc prenuSubstantivonLauxTipo {bazaformo fleksGrupo kazo nombro} {
    # tipo (vidu initDeklinacja)
    # ms mz mn ze ni
    # męski-osobowy męski-żywotny męski-nieżywotny żenski nijaki
    # kazo: M D C B N Ms W
    # nombro: singularo pluralo
    my instvar kazojIndekso dekltabloIndekso
    set tipo [lindex $fleksGrupo 0]
    set esceptoj [lrange $fleksGrupo 1 end]

    if {$kazo eq "M" && $nombro eq "singularo"} {
        return $bazaformo
    }
    set persono [my prenuArtoDeTipo $tipo]
    if {![regexp {([0-9]+)(.*)} $tipo _ tiponombro alt]} {
        return $bazaformo-?
    }
    if {$kazo eq "B" && $nombro eq "singularo" &&  ($persono eq "mn" || $persono eq "ni")} {
        return $bazaformo
    }
    if {$nombro eq "singularo"} {
        set plnombro lp
    } else {
        set plnombro lm
    }
    foreach esc $esceptoj {
        foreach {k v} $esc {}
        if {$k eq "$kazo$plnombro" || ($plnombro eq "lp" && $kazo eq $k)} {
            return $v
        }
    }
    set obazaformo $bazaformo

    # sercxu temon
    set bazaformo [my prenuSubstantivanTemon $bazaformo]

    set i $kazojIndekso($kazo)
    if {$nombro eq "pluralo"} {
        incr i 7
    }
    set tablo $dekltabloIndekso($tiponombro)
    set fino [lindex $tablo $i]
    set vario [lindex $fino 1]
    set finilo [lindex $fino 0]

    if {$kazo eq "B" && $nombro eq "singularo" && $persono eq "ze" && $fino eq ""} {
        return $obazaformo
    }

    switch -exact -- $alt {
        A {
            if {$nombro eq "pluralo"} {
                set bazaformo [string range $bazaformo 0 end-2]
            }
        }
        ' {
            set bazaformo [my vokalAlternacja {ó o ą ę} $bazaformo]
        }
        ^' {
            set bazaformo [my vokalAlternacja {ó o ą ę} $bazaformo]
            if {$nombro eq "singularo" && ($kazo eq "Ms" || $kazo eq "W")} {
                set bazaformo [my vokalAlternacja {o e a e} $bazaformo]
            }
        }
        '' {
            if {$nombro eq "pluralo"} {
                if {$kazo eq "N" || $kazo eq "D"} {
                     set bazaformo [my vokalAlternacja {ą ę} $bazaformo]
                }
            }
        }
        * {
            set i [string last e $bazaformo]
            if {$i>0 && $tiponombro ni {112 96 119 97}} {
                if {[string index $bazaformo [expr {$i-1}]] eq "i"} {
                    incr i -1
                    set bazaformo [my konstruuTemon [string range $bazaformo 0 $i]][string range $bazaformo [expr {$i+2}] end]
                } else {
                    set bazaformo [string replace $bazaformo $i $i]
                }
            }
        }
        ** {
            set i [string last e $bazaformo]
            if {$tiponombro ne "112" && $i>0} {
                if {[string index $bazaformo [expr {$i-1}]] eq "i"} {
                    incr i -1
                    set bazaformo [my konstruuTemon [string range $bazaformo 0 $i]][string range $bazaformo [expr {$i+2}] end]
                } else {
                    set bazaformo [string replace $bazaformo $i $i]
                }
            }
            # jeszcze wymiana spółgłosek
        }
        *** {
            set i [string first io $bazaformo]
            if {$i>0} {
                set bazaformo [string replace $bazaformo $i [expr {$i+1}]]
            } else {
                set i [string first o $bazaformo]
                set bazaformo [string replace $bazaformo $i $i]
            }
        }
    }
    foreach esc $esceptoj {
        foreach {k v} $esc {}
        if {$k eq "fb"} {
            set bazaformo $v
        } elseif {$k eq "fblm" && $nombro eq "pluralo"} {
            set bazaformo $v
        }
    }
    if {$finilo eq "i" || $finilo eq "e" || [string index $finilo 0] eq "*"} {
        if {[string index $finilo 0] eq "*"} {
            set finilo [string range $finilo 1 end]
        }
        switch -exact $alt {
            '' {
                set bazaformo [my vokalAlternacja {ą ę} $bazaformo]
            }
            ^ {
                set bazaformo [my vokalAlternacja {o e a e} $bazaformo]
            }
        }
        set cxuMoligu 1
        if {[string range $bazaformo end-1 end] eq "zn" && [my prenuLastanFonemon [string range $bazaformo 0 end-1]] eq "z"} {
            set bazaformo [string range $bazaformo 0 end-2]źn
        } elseif {[string range $bazaformo end-1 end] eq "zł" && [my prenuLastanFonemon [string range $bazaformo 0 end-1]] eq "z"} {
            set bazaformo [string range $bazaformo 0 end-2]źl
        } elseif {[string range $bazaformo end-1 end] eq "zd" && [my prenuLastanFonemon [string range $bazaformo 0 end-1]] eq "z"} {
            set bazaformo [string range $bazaformo 0 end-2]ździ
        } elseif {[string range $bazaformo end-1 end] eq "sn"} {
            set bazaformo [string range $bazaformo 0 end-2]śn
        } elseif {[string range  $bazaformo end-1 end] eq "st"} {
            set bazaformo [string range $bazaformo 0 end-2]śc
        } elseif {[string index $bazaformo end] eq "ł"} {
            if {[string index $bazaformo end-1] eq "s"} {
                set bazaformo [string range $bazaformo 0 end-2]śl
            } else {
                set bazaformo [string range $bazaformo 0 end-1]l
            }
        } elseif {[string index $bazaformo end] eq "t"} {
            set bazaformo [string range $bazaformo 0 end-1]c
        } elseif {[string index $bazaformo end] eq "r"} {
            set cxuMoligu 0
            set bazaformo [string range $bazaformo 0 end-1]rz
        } elseif {[string index $bazaformo end] eq "d"} {
            set bazaformo [string range $bazaformo 0 end-1]dz
        } elseif {[string index $bazaformo end] eq "k" && ($finilo eq "e" || $finilo eq "y")} {
            set bazaformo [string range $bazaformo 0 end-1]c
            set cxuMoligu 0
        } elseif {[string index $bazaformo end] eq "g" && ($finilo eq "e" || $finilo eq "y")} {
            set bazaformo [string range $bazaformo 0 end-1]dz
            set cxuMoligu 0
        } elseif {[string range $bazaformo end-1 end] eq "ch" && $finilo eq "e"} {
            set bazaformo [string range $bazaformo 0 end-2]sz
            set cxuMoligu 0
        } elseif {[string range $bazaformo end-1 end] eq "ch" && $finilo eq "i"} {
            if {$tiponombro eq "12"} {
                set finilo y
            } else {
                set bazaformo [string range $bazaformo 0 end-2]s
            }
            set cxuMoligu 0
        } elseif {[lsearch {rz cz dz sz} [string range $bazaformo end-1 end]]>=0} {
            set cxuMoligu 0
        } else {
            # "pbgwmszn"
            if {[string first [string index $bazaformo end] "pbfgwmszn"]<0} {
                set cxuMoligu 0
            }
        }
        if {$tipo eq 110} {
            # dana, księżna
            set cxuMoligu 0
        }
        if {$cxuMoligu && $finilo eq "e"} {
            set zmiekczyc "pbfwnzsmc"
            if {[string first [string index $bazaformo end] $zmiekczyc]>=0} {
                append bazaformo i
            }
        }
        # Wołacz z 'c' będzie 'cz' - Młodzieńcze
        if {$kazo eq "W" && $finilo eq "e" && $nombro eq "singularo" && [string index $bazaformo end] eq "c"} {
            append bazaformo z
        }
    } elseif {[string index $finilo 0] eq "e"} {
       if {[string index $bazaformo end] eq "k" || [string index $bazaformo end] eq "g"} {
           append bazaformo i
       }
    } elseif {$finilo eq "mi" && [string index $bazaformo end] eq "i"} {
        set bazaformo [my konstruuTemon $bazaformo]
    } elseif {$finilo eq "" && $kazo eq "D" && $nombro eq "pluralo"} {
        # z 'książk' bedzie 'książek'
        if {$alt eq "*" && ![my estasVovel [string index $bazaformo end]] &&
            ![my estasVovel [string index $bazaformo end-1]]} {
                set bazaformo "[string range $bazaformo 0 end-1]e[string index $bazaformo end]"
        } elseif {$alt eq "'" && [string first ó $bazaformo]<0} {
            # ' signifas o -> ó
            # wodo -> wód, doba -> dób
            set bazaformo [my vokalAlternacja {o ó} $bazaformo]
        }
    } elseif {$finilo eq "y" && [string first [string index $bazaformo end] "gk"]>=0} {
        set finilo i
    }
    if {$fleksGrupo eq "89" && $kazo eq "D" && $nombro eq "pluralo" && $finilo eq ""} {
        if {[string range $bazaformo end-1 end] eq "ni"} {
            set bazaformo [string replace $bazaformo end-1 end ń]
        } elseif {[string range $bazaformo end-1 end] eq "ci"} {
            set bazaformo [string replace $bazaformo end-1 end ć]
        }
    }
    if {$kazo eq "D" && $nombro eq "pluralo"} {
        # zlodziej - zlodziei , administracja - administracji
        if {[string index $finilo 0] eq "i" && [string index $bazaformo end] eq "j" && $persono ne "ze"} {
           set bazaformo [string range $bazaformo 0 end-1]
        } else {
            set last [string range $bazaformo end-1 end]
            if {[string index $finilo 0] eq "i" && ($last eq "ci" || $last eq "zi" || $last eq "ni") && $tiponombro ne "115"} {
               set bazaformo [string range $bazaformo 0 end-1]
            }
        }
    } else {
        # ekonomia - ekonomii - 115
        # ziemia - ziemi - 114
        if {[string index $finilo 0] eq "i" && [string index $bazaformo end] eq "i" && $tiponombro ne "115"} {
           set bazaformo [string range $bazaformo 0 end-1]
        }
    }
    # szyja - szyi , zmija - zmii
    if {[string index $finilo 0] eq "i" && [string index $bazaformo end] eq "j" && [my estasVovel [string index $bazaformo end-1]]} {
        set bazaformo [string range $bazaformo 0 end-1]
    }
    # liceum plenum akwarium
    if {$tiponombro eq "101" && [string range $bazaformo end-1 end] eq "um"} {
        set bazaformo [string range $bazaformo 0 end-2]
    }
    return $bazaformo$finilo
}
PolaFleksio proc prenuVerboEsceptoj {} {
    return {
        1lp {unua persono singularo estanta tempo}
        3lp  {tria persono singularo estanta tempo}
        3lm  {tria persono pluralo estanta tempo}
        p3lp {tria persono singularo pasinta tempo}
        p3lpze {tria persono singularo pasinta tempo (ŝi)}
        p3lm {tria persono pluralo pasinta tempo}
        p3lmze {tria persono pluralo pasinta tempo (ne maskulina)}
        p1lp {unua persono singularo pasinta tempo}
        roz {ordono singularo}
        imlp {adjektiva participo pasinta tempo singularo}
        imlm {adjektiva participo pasinta tempo pluralo}
    }
}
PolaFleksio proc prenuVerbon {bazaformo fleksGrupoPri persono arto nombro tempo} {
    # persono: 1 2 3
    # arto: ms ze ni
    # nombro: singularo pluralo
    # tempo: as os is u us ata oto ita anta onta inta
    # fleksGrupoPri (Priskribo) havas Formon
    # (GrupoLaux Tokarski) esceptoj
    # 3lp 3lm p3lp p3lm p3lpze

    if {$bazaformo eq "być"} {
        return [my prenuEstVerbon $persono $arto $nombro $tempo]
    }
    if {$tempo eq "is" && ($persono==1 || $persono==2) && $arto ne "ze"} {
        set arto ms
    }

    set fleksGrupo [lindex $fleksGrupoPri 0]
    set esceptoj [lrange $fleksGrupoPri 1 end]
    my instvar konjtabloIndekso
    set indekso 0
    if {![info exists konjtabloIndekso($fleksGrupo)]} {
        return $bazaformo-?
    }
    set def $konjtabloIndekso($fleksGrupo)

    set bazo ""
    set kunmetilo 0
    if {[lsearch {ata ita ota ito ato oto ate ois o} $tempo]>=0} {
        foreach escepto $esceptoj {
            set esceptoArr([lindex $escepto 0]) [lindex $escepto 1]
            if {[lindex $escepto 0] eq "imlp"} {
                set bazo [lindex $escepto 1]
                set bazo [string range $bazo 0 end-[string length [lindex $def 20]]]
            }
        }
        if {$bazo eq ""} {
            if {$fleksGrupo in {VIa VIaj VIIa}} {
                set kunmetilo 1
                set bazo [string range [my prenuVerbon $bazaformo $fleksGrupoPri 1 ms singularo as] 0 end-1]
            } elseif {$fleksGrupo eq "XI" || $fleksGrupo eq "Va"} {
                set kunmetilo 1
                set bazo [string range [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms singularo as] 0 end-[string length [lindex $def 3]]]
                set bazo [string trimright $bazo i]
            } elseif {$fleksGrupo eq "Va"} {
                set kunmetilo 1
                set bazo [string range [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms singularo as] 0 end-[string length [lindex $def 3]]]
            } elseif {$fleksGrupo eq "XIb"} {
                set kunmetilo 1
                set bazo [string range [my prenuVerbon $bazaformo $fleksGrupoPri 3 ze singularo is] 0 end-2]
            } elseif {$fleksGrupo eq "Vc"} {
                set kunmetilo 1
                set bazo [string range [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms pluralo is] 0 end-2]
            }
        }
    }
    if {$bazo eq ""} {
        set bazo [string range $bazaformo 0 end-[string length [lindex $def 0]]]
        set bazo [my prenuBazanVerboFormon $bazaformo def $bazo $esceptoj $fleksGrupo $persono $arto $nombro $tempo esceptoArr]
        if {[llength $def]==0} {
            return $bazo
        }
    }

    switch $tempo {
        as {
            set indekso $persono
            if {$nombro eq "pluralo"} {
                incr indekso 3
            }
            set fino [lindex $def $indekso]
            if {[string index $bazo end] eq [string index $fino 0] && [string index $fino 0] eq "i"} {
                set bazo [string range $bazo 0 end-1]
            }
        }
        is {
            switch $nombro {
                singularo {
                    if {$persono==1 && $arto ne "ze"} {
                        set arto ms
                    }
                    switch $arto {
                        mn -
                        mz -
                        ms {
                            set indekso 12
                            set fino [lindex $def $indekso]
                            switch $persono {
                                1 {
                                    append fino em
                                }
                                2 {
                                    append fino eś
                                }
                            }
                        }
                        ze {
                            set indekso 13
                            set fino [lindex $def $indekso]
                            switch $persono {
                                1 {
                                    append fino m
                                }
                                2 {
                                    append fino ś
                                }
                            }
                        }
                        default {
                            set indekso 14
                            set fino [lindex $def $indekso]
                            switch $persono {
                                1 {
                                    set fino [string range $fino 0 end-1]em
                                }
                                2 {
                                    set fino [string range $fino 0 end-1]eś
                                }
                            }
                        }
                    }
                }
                pluralo {
                    switch $arto {
                        ms {
                            set indekso 15
                            set fino [lindex $def $indekso]
                            switch $persono {
                                1 {
                                    append fino śmy
                                }
                                2 {
                                    append fino ście
                                }
                            }
                        }
                        default {
                            set indekso 16
                            set fino [lindex $def $indekso]
                            switch $persono {
                                1 {
                                    append fino śmy
                                }
                                2 {
                                    append fino ście
                                }
                            }
                        }
                    }
                }
            }

        }
        os {
            set svorboj {móc musieć}
            if {[lsearch $svorboj $bazaformo]>=0} {
                set bf [my prenuVerbon $bazaformo $fleksGrupoPri 3 $arto $nombro is]
                return "[my prenuEstVerbon $persono $arto $nombro os] $bf"
            } else {
                return "[my prenuEstVerbon $persono $arto $nombro os] $bazaformo"
            }
        }
        i {
            return $bazaformo
        }
        into -
        inta -
        int {
            return "wcześniej [my prenuVerbon $bazaformo $fleksGrupoPri $persono $arto $nombro ant]"
        }
        anto -
        anta -
        ant {
            # robiący
            set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms pluralo as]
            set fino cy
        }
        onto -
        onta -
        ont {
            return "w przyszłości [my prenuVerbon $bazaformo $fleksGrupoPri $persono $arto $nombro ant]"
        }
        ito -
        ita -
        ata -
        it -
        at {
            # robiony
            if {$nombro eq "singularo"} {
                if {[info exists esceptoArr(imlp)]} {
                    return $esceptoArr(imlp)
                }
                set fino [lindex $def 20]
            } else {
                if {[info exists esceptoArr(imlm)]} {
                    return $esceptoArr(imlm)
                }
                set fino [lindex $def 21]
            }
        }
        oto -
        ota -
        ot {
            return "w przyszłości [my prenuVerbon $bazaformo $fleksGrupoPri $persono $arto $nombro at]"
        }
        u {
            if {[info exists esceptoArr(roz)]} {
                set bazo [lindex $esceptoArr(roz) 0]
                if {$nombro eq "singularo"} {
                    set fino ""
                 } else {
                    if {$persono eq "1"} {
                        set fino my
                    } else {
                        set fino cie
                    }
                }
            } else {
                if {$fleksGrupo ne "Vb" && $fleksGrupo ne "Xb" && $fleksGrupo ne "III"} {
                    set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms singularo as]
                }
                set foro "iyae"
                if {$fleksGrupo eq "Va" || $fleksGrupo eq "Vc" || $fleksGrupo eq "VIIIa" || $fleksGrupo eq "VIIIc" || $fleksGrupo eq "VIIIb"} {
                    set bazo [string range $bazo 0 end-2]
                } elseif {$fleksGrupo eq "IV" || $fleksGrupo eq "Xc" || $fleksGrupo eq "Xcn"} {
                    set bazo [string range $bazo 0 end-2]
                } elseif {[string first [string index $bazo end] $foro]>=0} {
                    set bazo [string range $bazo 0 end-1]
                    if {[string index $bazo end] eq "i" && [lindex $def 7] eq ""} {
                        set imap {z ź c ć s ś n ń}
                        set bazo [string range $bazo 0 end-1]
                        set bazo [string replace $bazo end end [string map $imap [string index $bazo end]]]
                    }
                }
                if {[string first [string index $bazo end] {zcsn}]>=0 && [lindex $def 7] eq ""} {
                    if {[string index $bazo end] ne "z" ||
                    [string first [string index $bazo end-1] {csr}]<0} {
                        set imap {z ź c ć s ś n ń}
                        set bazo [string replace $bazo end end [string map $imap [string index $bazo end]]]
                        }
                }
                if {$nombro eq "singularo"} {
                    if {[string index $bazo end] eq [string index [lindex $def 7] 0]} {
                        set bazo [string range $bazo 0 end-1]
                    }
                    set fino [lindex $def 7]
                } else {
                    if {$persono eq "1"} {
                        if {[string index $bazo end] eq [string index [lindex $def 8] 0]} {
                            set bazo [string range $bazo 0 end-1]
                        }
                        set fino [lindex $def 8]
                    } else {
                        if {[string index $bazo end] eq [string index [lindex $def 9] 0]} {
                            set bazo [string range $bazo 0 end-1]
                        }
                        set fino [lindex $def 9]
                    }
                }
            }
        }
        us {
            # robiłby
            if {$nombro eq "singularo"} {
                switch $persono {
                    1 {
                        set f bym
                    }
                    2 {
                        set f byś
                    }
                    3 {
                        set f by
                    }
                }
            } else {
                switch $persono {
                    1 {
                        set f byśmy
                    }
                    2 {
                        set f byście
                    }
                    3 {
                        set f by
                    }
                }
            }
            return [my prenuVerbon $bazaformo $fleksGrupoPri 3 $arto $nombro is]$f
        }
        inte -
        ite {
            # zrobiwszy
            #set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms pluralo as]
            #set bazo [string range $bazo 0 end-1]
            set fino [lindex $def 19]
        }
        ante -
        ate {
            # robiąc
            set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms pluralo as]
            set fino c
        }
        ois {
            # czytano
            #set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms singularo as]
            #set bazo [string range $bazo 0 end-[string length [lindex $def 3]]]
            set fino [lindex $def 22]
        }
        o {
            # czytanie
            #set bazo [my prenuVerbon $bazaformo $fleksGrupoPri 3 ms singularo as]
            #set bazo [string range $bazo 0 end-[string length [lindex $def 3]]]
            set fino [lindex $def 23]
            if {[string index $fino 0] eq "e" && [string range $bazo end-2 end] eq "dzi"} {
                set bazo [string trimright $bazo i]
            }
        }
        default {
            puts "nekonata tipo $tempo"
            return "???"
        }
    }
    if {$kunmetilo} {
        # wiedzieć, grzmieć
        my kunmetuFinilon $bazo $fino $bazaformo
    } else {
        return ${bazo}$fino
    }
}
PolaFleksio proc sxercxuFGrupoPorVerbo verbo {
    switch -glob $verbo {
        *ować {
            return IV
        }
        *ywać {
            return VIIIa
        }
        *iwać {
            return VIIIb
        }
        *nąć {
            # Vb Vc
            return Va
        }
        *ać {
            # IX Xb Xc Xcn
            return I
        }
        *ić {
            return VIa
        }
        *yć {
            return VIb
        }
        *eć {
            # II VIIb
            return VIIa
        }
        *ć {
            # XI
            return Xa
        }
        default {
            return I
        }
    }
}
PolaFleksio proc vokalAlternacja {listo bazaformo} {
    # listo havas formon {de_vokalo1 al_vokalo1 de_vokalo2 al_vokalo2}
    # ekzemple {o e i y}
    # o->e i->y
    # nur la lasta vokalo estos sxangxita kaj nur unu

    foreach {de_vokalo al_vokalo} $listo {
        # ne tausxu la unuan literon
        if {[set index [string last $de_vokalo $bazaformo]]>0} {
            set bazaformo [string replace $bazaformo $index $index $al_vokalo]
            break
        }
    }
    return $bazaformo
}
@ Object PolaVortFarado {
description {Klaso uzato por pola vortfarado laux esperant morfologio
 neebla = niemożliwy}
}
Object PolaVortFarado
@ ::PolaVortFarado idemeta categoriesMethodsProcs {{adj2adv adj2eco prenuMorfVortfaradoj} {prenuVortfaradoj2 prenuVortfaradoj} divenuSubstantivonDeVerbo}
@ ::PolaVortFarado idemeta categoriesProcs {vortaro-kreado api private}
@ ::PolaVortFarado idemeta component EspPlTradukilo
PolaVortFarado proc adj2adv adjektivo {
    switch -glob $adjektivo {
        *wy -
        *my -
        *ny {
           return [string range $adjektivo 0 end-1]ie
        }
        *cy {
           return [string range $adjektivo 0 end-1]co
        }
        *y {
           return [string range $adjektivo 0 end-1]o
        }
        *i {
           return [string range $adjektivo 0 end-1]o
        }
        default {
            return [string range $adjektivo 0 end-1]o
        }
    }
}
PolaVortFarado proc adj2eco adjektivo {
    return [string range $adjektivo 0 end-1]ość
}
PolaVortFarado proc divenuAdoSubstantivonDeVerbo {verbo fgrupo gramatiko} {
    if {[lsearch $gramatiko dk]>=0} {
        return
    }
    my divenuSubstantivonDeVerbo $verbo $fgrupo
}
PolaVortFarado proc divenuSubstantivonDeVerbo {verbo fgrupo} {
    join [PolaFleksio prenuVerbon [lindex $verbo 0] $fgrupo 1 ns singularo o] [lrange $verbo 1 end]
}
PolaVortFarado proc initializeAfterLoad {} {
    my instvar definoj
    set definoj [list]
    # mustero trodukvorto polavorto
    lappend definoj {ge(.+o) $v $t}
    lappend definoj {ne(.+a) $v nie$t}
    lappend definoj {ĉi(.+[ae]) $v tego$t}
    lappend definoj {ĉi-(.+[ae]) $v tego$t}
    lappend definoj {ne(.+[oae]) $v {nie$t}}
    lappend definoj {ne(.+i) $v {nie $t}}
    lappend definoj {mal(.+) $v {$t inaczej}}
    lappend definoj {(.+)iĝi ${v}i {$t się}}
    lappend definoj {(.+)adi ${v}i $t}
    lappend definoj {eks(.+o) $v eks-$t}
    lappend definoj {pra(.+o) $v pra-$t}
    lappend definoj {re(.+i) $v {$t ponownie}}
    lappend definoj {unu(.+[ae]) $v {jedno$t}}
    lappend definoj {du(.+[ae]) $v {dwu$t}}
    lappend definoj {tri(.+[ae]) $v {trzy$t}}
    lappend definoj {kvar(.+[ae]) $v {cztero$t}}
    lappend definoj {kvin(.+[ae]) $v {pięcio$t}}
    lappend definoj {ses(.+[ae]) $v {sześcio$t}}
    lappend definoj {sep(.+[ae]) $v {siedmio$t}}
    lappend definoj {ok(.+[ae]) $v {ośmio$t}}
    lappend definoj {naŭ(.+[ae]) $v {dziewięcio$t}}
    lappend definoj {dek(.+[ae]) $v {dziesięcio$t}}
    lappend definoj {cent(.+[ae]) $v {stu$t}}
    lappend definoj {mil(.+[ae]) $v {tysiąc$t}}
    lappend definoj {sia(.+e) $v {jego$t}}
    lappend definoj {divers(.+a) $v {różno$t}}
    lappend definoj {kvazaŭ(.+[ae]) $v {niby$t}}
    lappend definoj {inter(.+a) $v {między$t}}
    lappend definoj {plen(.+a) $v {w pełni $t} {dict set rd gramatiko last}}
    lappend definoj {mult(.+a) $v {wielo$t}}
    lappend definoj {duon(.+oea) $v {pół$t}}
    lappend definoj {(.+)simila ${v}o {${t}podobny}}
    lappend definoj {(.+)simile ${v}e {${t}podobnie}}
    lappend definoj {kun(.+o) $v {współ${t}}}
    lappend definoj {(.+)o ${v}i {[my divenuSubstantivonDeVerbo $t $f]} {set g [PolaFleksio divenuTiponDeSubstantivo $r]}}
    # trovado - trovi znajdować - znajdowanie
    lappend definoj {(.+)ado ${v}i {[my divenuAdoSubstantivonDeVerbo $t $f $g]} {set g [PolaFleksio divenuTiponDeSubstantivo $r]}}
    lappend definoj {plur(.+[ae]) $v {wielo${t}}}
    lappend definoj {duon(.+[ae]) $v {pół${t}}}
}
PolaVortFarado proc prenuMorfVortfaradoj espVorto {
    set dbvoraro [DBVortaro prenuDepVortaron]
    set definoj {
        {tra(.+i) $v prze$t}
        {trans(.+i) $v prze$t}
        {el(.+i) $v wy$t}
        {(.+)e ${v}a {[PolaVortFarado adj2adv $t]}}
        {(.+)eco ${v}a {[PolaVortFarado adj2eco $t]}}
        {pra(.+) $v pra$t}
    }
    set proponoj [list]
    foreach def $definoj {
       if {[regexp ^[lindex $def 0]$ $espVorto _ v]} {
            set v [subst [lindex $def 1]]
            set rezListo [$dbvoraro sxercxuRezListo $v pl]
            foreach l $rezListo {
                array set rezArr $l
                set t $rezArr(traduko)
                set r [subst [lindex $def 2]]
                if {$r eq ""} {
                    continue
                }
                set rezArr(traduko) $r
                lappend proponoj $rezArr(traduko)
           }
       }
    }
    return $proponoj
}
PolaVortFarado proc prenuVortfaradoj {espVorto dbvoraro} {
    my instvar definoj
    # 13-jara -> 13-letni
    if {[regexp {^(\d+|[a-z]{1,2})-(.+[aeo])$} $espVorto _ num v]} {
        set rezListo [$dbvoraro sxercxuRezListo $v pl]
        if {[llength $rezListo]==0} return
        set rez [list]
        foreach rd $rezListo {
            set t [dict get $rd traduko]
            set f [dict get $rd fgrupo]
            set g [dict get $rd gramatiko]
            set r $num-$t
            dict set rd traduko $r
            lappend rez $rd
        }
        return $rez
    }
    
    if {[string match *eto $espVorto]} {
        set rez [list]
        foreach rd [$dbvoraro sxercxuRezListo [string range $espVorto 0 end-3]o pl] {
             set t [PolaFleksio divenuEtoFormon [dict get $rd traduko]]
             if {$t eq ""} continue
             dict set rd traduko $t
             dict set rd fgrupo [PolaFleksio divenuTiponDeSubstantivo $t]
             lappend rez $rd
        }
        return $rez       
    }
    foreach def $definoj {
        if {[regexp ^[lindex $def 0]$ $espVorto _ v]} {
            set v [subst [lindex $def 1]]
            set rezListo [$dbvoraro sxercxuRezListo $v pl]
            if {[llength $rezListo]==0} continue
            set rez [list]
            foreach rd $rezListo {
                set t [dict get $rd traduko]
                set g [dict get $rd gramatiko]
                set f [dict get $rd fgrupo]
                set r [subst [lindex $def 2]]
                if {$r eq ""} {
                    continue
                }
                if {[llength $def]>3} {
                    eval [lindex $def 3]
                    dict set rd fgrupo $g
                }
                dict set rd traduko $r
                lappend rez $rd
            }
            return $rez
        }
    }
    return
}
PolaVortFarado proc prenuVortfaradoj2 espVorto {
    my prenuVortfaradoj $espVorto [DBVortaro prenuDepVortaron]
}
Object RusSkriptoj
@ ::RusSkriptoj idemeta component EspPlTradukilo
RusSkriptoj proc aldonuAspektojn {} {
    set d [file join [my prenuRusDosierujon] verboj-aspektoj.txt]
    set tvortaro [DBVortaro prenuDepVortaron]
    set rez ""
    set i [open $d r]
    while {[gets $i linio]>=0} {
        if {[string index $linio 0] eq "#"} continue
        lassign [split $linio /] prog perf
        foreach tradukod [$tvortaro sxercxuRezListoPorTraduko $prog ru] {
            if {"prog" ni [set gramatiko [dict get $tradukod gramatiko]]} {
                lappend gramatiko prog
                append rez "DBVortaro modifuTradukonDeVorto [dict get $tradukod vorto] [list $prog] [list [list gramatiko $gramatiko]] ru\n"
            }
            set trovita 0
            foreach tradukop [$tvortaro sxercxuRezListo [dict get $tradukod vorto] ru] {
                if {[dict get $tradukop traduko] eq $perf} {
                    set trovita 1
                    break
                }
            }
            if {!$trovita} {
                append rez "DBVortaro importuTraduko ru [dict get $tradukod vorto] [list $perf] {} perf {}\n"
            }
        }
        foreach tradukod [$tvortaro sxercxuRezListoPorTraduko $perf ru] {
            if {"perf" ni [set gramatiko [dict get $tradukod gramatiko]]} {
                lappend gramatiko perf
                append rez "DBVortaro modifuTradukonDeVorto [dict get $tradukod vorto] [list $perf] [list [list gramatiko $gramatiko]] ru\n"
            }
            set trovita 0
            foreach tradukop [$tvortaro sxercxuRezListo [dict get $tradukod vorto] ru] {
                if {[dict get $tradukop traduko] eq $prog} {
                    set trovita 1
                    break
                }
            }
            if {!$trovita} {
                append rez "DBVortaro importuTraduko ru [dict get $tradukod vorto] [list $prog] {} prog {}\n"
            }
        }
    }
    close $i
    return $rez
}
RusSkriptoj proc foriguDuopajnTradukojn {} {
    set sql "select t1.id from traduko_ru t1,traduko_ru t2,derivo d where t1.id>t2.id and t1.traduko=t2.traduko and t1.derivoid=t2.derivoid and d.id=t1.derivoid"

    set tvortaro [DBVortaro prenuDepVortaron]
    set connection [$tvortaro set connection]

    foreach id [$connection queryList $sql] {
        $connection execute "delete from traduko_ru where id=$id"
    }
}
RusSkriptoj proc metuGramatikonPorPrepozicioj {} {
    set vortaro [DBVortaro prenuVortaron]
    set rez ""
    foreach {prepozicio v} [my trovuKazojPorPrepozicioj] {
        foreach tradukod [$vortaro sxercxuRezListoPorTraduko $prepozicio ru] {
            set derivo [dict get $tradukod vorto]
            set traduko [dict get $tradukod traduko]
            set rad Radiko::$derivo
            Radiko::pri
            if {[Object isobject $rad] && [$rad hasclass Pronomo] && [$rad prenuTypo] eq "Prepozicio"} {
                set kazo _
                set kazoNum 0
                dict for {k num} $v {
                    if {$num>$kazoNum} {
                        set kazo $k
                        set kazoNum $num
                    }
                }
                if {$kazo ne "_"} {
                    set kazo [string index $kazo 0]
                    append rez "DBVortaro modifuTradukonDeVorto $derivo [list $prepozicio] [list [list gramatiko [list [list N $kazo]]]] ru\n"
                }
            }
        }
    }
    return $rez
}
RusSkriptoj proc prenuRusDosierujon {} {
    return {/home/artur/esperanto/ru_fontoj/}
}
RusSkriptoj proc trovuKazojPorPrepozicioj {} {
    # de xml dosieroj de
    # http://ruscorpora.ru/en/corpora-usage.html
    set d {/home/artur/esperanto/ru_fontoj/shuffled_rnc}
    foreach dnomo [glob -directory $d *.xml] {
        set d [open $dnomo r]
        puts "read $dnomo"
        while {[gets $d linio]>=0} {
            if {[regexp {lex="(\w+)" gr="PR"} $linio _ prep]} {
                if {[gets $d linio]>=0} {
                    if {[regexp {gr="S,.+?,([[:alpha:]]+)\d?"} $linio _ kazo]} {
                        if {[string first = $kazo]>=0} continue
                        if {[info exists prepArr($prep)]} {
                            dict incr prepArr($prep) $kazo
                        } else {
                            set prepArr($prep) [dict create $kazo 1]
                        }
                    }
                }
            }
        }
        close $d
    }
    foreach prep [lsort [array names prepArr]] {
        puts "$prep $prepArr($prep)"
    }
    array get prepArr
}
ETPlPrepozicio initializeAfterLoad
PolaFleksio initializeAfterLoad
PolaVortFarado initializeAfterLoad

