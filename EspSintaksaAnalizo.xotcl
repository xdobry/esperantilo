# automatically generated from XOTclIDE
# script require component EspBazaLingvo
@ Component EspSintaksaAnalizo {
description {Sintaksa analizilo de esperanta lingvo
La sintaksa analizo konstruas subobjektoj sur '''GP::Frazo''' objekto
}
}
package provide EspSintaksaAnalizo 0.993
package require EspBazaLingvo
namespace eval ::esp {}
@ tclproc esp::silaboj idemeta struct EspSintaksaAnalizo esp
proc esp::silaboj vorto {
    set l [string length $vorto]
    set silaboj [list]
    set i 0
    set estisVovalo 0
    set nevovaloj 0
    set kommenco 0
    set duoblaj {bl br dr fj fl fr ft gl gn gr gv hm kl kn kr ks kv mj mn nj pf pl pn pr ps sc sf sk sl sm sn sp st sv tj tr vj ĉj ŝl ŝm ŝn ŝp ŝr ŝt ŝv}
    set fino {or om on er en im em ov}
    set silabo ""
    while {$i<$l} {
        set litero [string index $vorto $i]
        if {[::esp::estasVokalo $litero]} {
            if {$estisVovalo} {
                #if {[lsearch $fino [string range $vorto [expr {$i-1-$nevovaloj}]}
                if {[lsearch $fino [string range $vorto [expr {$i-1-$nevovaloj}] [expr {$i-1}]]]>=0} {
                    lappend silaboj [string range $vorto $kommenco [expr {$i-$nevovaloj}]]
                    set kommenco [expr {$i-$nevovaloj+1}]
                } else {
                    lappend silaboj [string range $vorto $kommenco [expr {$i-1-$nevovaloj}]]
                    set kommenco [expr {$i-$nevovaloj}]
                }
                set estisNevovalo 0
                set estisVovalo 1
                set nevovaloj 0
            } else {
                set estisVovalo 1
            }
        } else {
            if {$estisVovalo} {
                if {$nevovaloj} {
                    if {[lsearch $duoblaj [string range $vorto [expr {$i-1}] $i]]>=0} {
                        #puts "nevovalo post vovalo 2"
                        lappend silaboj [string range $vorto $kommenco [expr {$i-2}]]
                        set kommenco [expr {$i-1}]
                        set nevovaloj 0
                        set estisVovalo 0
                    } else {
                        # testu om em on finoj
                        puts "sil - [string range $vorto [expr {$i-1}] $i]"
                        if {[lsearch $fino [string range $vorto [expr {$i-1}] $i]]>=0} {
                            lappend silaboj [string range $vorto $kommenco $i]
                            set kommenco [expr {$i+1}]
                            set nevovaloj 0
                            set estisVovalo 0
                        } else {
                            lappend silaboj [string range $vorto $kommenco [expr {$i-1}]]
                            set kommenco $i
                            set nevovaloj 0
                            set estisVovalo 0
                        }
                    }
                } else {
                    incr nevovaloj
                }
            }
        }
        append silabo $litero
        incr i
    }
    lappend silaboj [string range $vorto $kommenco end]
    return $silaboj
}
@ tclproc esp::dauroKielString idemeta struct EspSintaksaAnalizo esp
proc esp::dauroKielString dauro {
    set sekundoj [expr {$dauro%60}]
    set minutoj [expr {($dauro/60)%360}]
    set horoj [expr {$dauro/360}]
    format "%i:%02i:%02i" $horoj $minutoj $sekundoj
}
@ tclproc esp::enhavasEsparantajLiteroj idemeta struct EspSintaksaAnalizo esp
proc esp::enhavasEsparantajLiteroj vorto {
    regexp {^[\-a-prstuvzA-PRSTUWZĉŝŭŬĥĵĝĈĜŜĴĤ]+$} $vorto
}
@ tclproc esp::estasVokalo idemeta struct EspSintaksaAnalizo esp
proc esp::estasVokalo c {
    expr {[string first $c "eaoiu"]>=0}
}
@ tclproc esp::frazoAlvortoj idemeta struct EspSintaksaAnalizo esp
@ tclproc esp::frazoAlvortoj idemeta comment {donas helpe de regexp vortoj (pli ol 3 literoj) de frazo}
proc esp::frazoAlvortoj frazo {
    regexp -all -inline {[[:alpha:]]{3,}} $frazo
}
@ tclproc esp::grandskribi idemeta struct EspSintaksaAnalizo esp
proc esp::grandskribi vorto {
   return [string toupper [string index $vorto 0]][string range $vorto 1 end]
}
@ tclproc esp::initCharmap idemeta struct EspSintaksaAnalizo esp
proc esp::initCharmap {} {
    variable characterMap
    if {![info exists characterMap]} {
        set characterMap(c) [format %c 265]
        set characterMap(g) [format %c 285]
        set characterMap(h) [format %c 293]
        set characterMap(j) [format %c 309]
        set characterMap(s) [format %c 349]
        set characterMap(u) [format %c 365]
        set characterMap(C) [format %c 264]
        set characterMap(G) [format %c 284]
        set characterMap(H) [format %c 292]
        set characterMap(J) [format %c 308]
        set characterMap(S) [format %c 348]
        set characterMap(U) [format %c 364]
    }
}
@ tclproc esp::joinFrazo idemeta struct EspSintaksaAnalizo esp
proc esp::joinFrazo listo {
    foreach vorto $listo {
        set space [esp::prenuSeparatilon $vorto]
        append frazo $space$vorto
    }
    return $frazo
}
@ tclproc esp::mapDict idemeta struct EspSintaksaAnalizo esp
proc esp::mapDict {listo args} {
    foreach {k v_ref} $args {
        if {[dict exists $listo $k]} {
            upvar $v_ref v
            set v [dict get $listo $k]
        }
    }
}
@ tclproc esp::mapList idemeta struct EspSintaksaAnalizo esp
proc esp::mapList {listo args} {
    array set arr $listo
    foreach {k v_ref} $args {
        if {[info exists arr($k)]} {
            upvar $v_ref v
            set v $arr($k)
        }
    }
}
@ tclproc esp::metuXEvento idemeta struct EspSintaksaAnalizo esp
proc esp::metuXEvento entry {
    bind $entry <KeyPress> "if {\[esp::xevento %W %K\]} break else continue"
    esp::initCharmap
}
@ tclproc esp::metuXEventoText idemeta struct EspSintaksaAnalizo esp
proc esp::metuXEventoText entry {
    bind $entry <KeyPress> "if {\[esp::xeventoText %W %K\]} break else continue"
    ::esp::initCharmap
}
@ tclproc esp::prenuKazoNombro idemeta struct EspSintaksaAnalizo esp
proc esp::prenuKazoNombro {bazaFormo estasAkuzativo estasPluralo} {
    set ret $bazaFormo
    if {$estasPluralo} {
        append ret j
    }
    if {$estasAkuzativo} {
        append ret n
    }
    return $ret
}
@ tclproc esp::prenuSeparatilon idemeta struct EspSintaksaAnalizo esp
proc esp::prenuSeparatilon vorto {
    upvar _lastElem lastElem
    upvar _enCitajxo enCitajxo
    set finSimboloj ":.,;?!”)"
    set komencSimboloj "„“("
    if {![info exists enCitajxo]} {
        set enCitajxo 0
        set lastElem ""
    }
    if {$vorto eq "\""} {
        if {$enCitajxo} {
            set enCitajxo 0
            set space ""
        } else {
            set enCitajxo 1
            set space " "
        }
    } else {
        if {$lastElem ne "" && [string first $vorto $finSimboloj]<0 && [string first $lastElem $komencSimboloj]<0 && ($lastElem ne "\"" || !$enCitajxo)} {
            set space " "
        } else {
            set space ""
        }
    }
    set lastElem $vorto
    return $space
}
@ tclproc esp::silaboj idemeta struct EspSintaksaAnalizo esp
proc esp::silaboj vorto {
    set l [string length $vorto]
    set silaboj [list]
    set i 0
    set estisVovalo 0
    set nevovaloj 0
    set kommenco 0
    set duoblaj {bl br dr fj fl fr ft gl gn gr gv hm kl kn kr ks kv mj mn nj pf pl pn pr ps sc sf sk sl sm sn sp st sv tj tr vj ĉj ŝl ŝm ŝn ŝp ŝr ŝt ŝv}
    set fino {or om on er en im em ov}
    set silabo ""
    while {$i<$l} {
        set litero [string index $vorto $i]
        if {[::esp::estasVokalo $litero]} {
            if {$estisVovalo} {
                #if {[lsearch $fino [string range $vorto [expr {$i-1-$nevovaloj}]}
                if {[lsearch $fino [string range $vorto [expr {$i-1-$nevovaloj}] [expr {$i-1}]]]>=0} {
                    lappend silaboj [string range $vorto $kommenco [expr {$i-$nevovaloj}]]
                    set kommenco [expr {$i-$nevovaloj+1}]
                } else {
                    lappend silaboj [string range $vorto $kommenco [expr {$i-1-$nevovaloj}]]
                    set kommenco [expr {$i-$nevovaloj}]
                }
                set estisNevovalo 0
                set estisVovalo 1
                set nevovaloj 0
            } else {
                set estisVovalo 1
            }
        } else {
            if {$estisVovalo} {
                if {$nevovaloj} {
                    if {[lsearch $duoblaj [string range $vorto [expr {$i-1}] $i]]>=0} {
                        #puts "nevovalo post vovalo 2"
                        lappend silaboj [string range $vorto $kommenco [expr {$i-2}]]
                        set kommenco [expr {$i-1}]
                        set nevovaloj 0
                        set estisVovalo 0
                    } else {
                        # testu om em on finoj
                        puts "sil - [string range $vorto [expr {$i-1}] $i]"
                        if {[lsearch $fino [string range $vorto [expr {$i-1}] $i]]>=0} {
                            lappend silaboj [string range $vorto $kommenco $i]
                            set kommenco [expr {$i+1}]
                            set nevovaloj 0
                            set estisVovalo 0
                        } else {
                            lappend silaboj [string range $vorto $kommenco [expr {$i-1}]]
                            set kommenco $i
                            set nevovaloj 0
                            set estisVovalo 0
                        }
                    }
                } else {
                    incr nevovaloj
                }
            }
        }
        append silabo $litero
        incr i
    }
    lappend silaboj [string range $vorto $kommenco end]
    return $silaboj
}
@ tclproc esp::xevento idemeta struct EspSintaksaAnalizo esp
proc esp::xevento {entry key} {
   variable lastKey
   variable characterMap
   if {![EsperantoConf set xAnstatuaigo]} {
       return 0
   }
   if {($key eq "x" || $key eq "X") && [info exists lastKey($entry)]} {
       set index [string first $lastKey($entry) {cghjsuCGHJSU}]
       if {$index>-1} {
            set insert [$entry index insert]
            $entry delete [expr {$insert-1}]
            $entry insert [expr {$insert-1}] $characterMap($lastKey($entry))
            set lastKey($entry) $key
            return 1
       }
   } else {
       set lastKey($entry) $key
   }
   return 0
}
@ tclproc esp::xeventoText idemeta struct EspSintaksaAnalizo esp
proc esp::xeventoText {entry key} {
   variable lastKey
   variable characterMap
   if {![EsperantoConf set xAnstatuaigo]} {
       return 0
   }
   if {($key eq "x" || $key eq "X") && [info exists lastKey($entry)]} {
       set index [string first $lastKey($entry) {cghjsuCGHJSU}]
       if {$index>-1} {
           $entry delete {insert - 1c}
           $entry insert insert $characterMap($lastKey($entry))
           set lastKey($entry) $key
           return 1
       }
   } else {
       set lastKey($entry) $key
   }
   return 0
}
@ Class ErarKolektilo {
description {Kolektilo por gramatikaj eraroj uzato kiel ''visitor pattern'' de ''SintaksAsto''-subklasoj}
}
Class ErarKolektilo -parameter sintaksAsto
@ ::ErarKolektilo idemeta component EspSintaksaAnalizo
@ ErarKolektilo instproc aliguEraron {} {
description {Je malpli alta graveco des pli grava la indiko.
 * Graveco 10 signifas - la uzado de vortoj
 * Graveco 1 difenas de ekzemplaj reguloj
 * 2 estas la kutima graveco.}
}
ErarKolektilo instproc aliguEraron {objekto mesagxo {sugestoj {}} {graveco 2}} {
    if {[llength $objekto]==1 && [string first minuskle $mesagxo]<0} {
        # Grandskibi la sugestojn se la antauxa vorto estas grandskribita
        set objekto [lindex $objekto 0]
        if {[$objekto istype GP::Elemento]} {
            set vorto [$objekto vorto]
            if {[string is upper [string index $vorto 0]]} {
                set nsugestoj [list]
                foreach s $sugestoj {
                    lappend nsugestoj [esp::grandskribi $s]
                }
                set sugestoj $nsugestoj
            }
        }
    }
    my lappend eraroj [list $objekto $mesagxo $sugestoj $graveco]
}
ErarKolektilo instproc havasErarojn {} {
    expr {[llength [my set eraroj]]>0}
}
@ ErarKolektilo instproc puriguLauxGraveco {} {
description {La metodo forigas mesagxoj de objekto, se ekzistas mesagxoj kun pli alta graveco
Tio ebligas, ke nur la plej grava mesagxo restas kaj elementoj ne estas priskribitaj plurfoje}
}
ErarKolektilo instproc puriguLauxGraveco {} {
    my instvar eraroj
    foreach eraro $eraroj {
        lassign $eraro objektoj mesagxo sugestoj graveco
        foreach objekto $objektoj {
            if {[info exists objektoArr($objekto)]} {
                if {$graveco < $objektoArr($objekto)} {
                    set objektoArr($objekto) $graveco
                }
            } else {
                set objektoArr($objekto) $graveco
            }
        }
    }
    set novajEraroj [list]
    foreach eraro $eraroj {
        lassign $eraro objektoj mesagxo sugestoj graveco
        foreach objekto $objektoj {
            if {$graveco == $objektoArr($objekto)} {
                lappend novajEraroj $eraro
                break
            }
        }
    }
    set eraroj [lsort -index 3 -integer -decreasing $novajEraroj]
}
ErarKolektilo instproc sxercxiErarojn {} {
    my set eraroj [list]
    if {[EsperantoConf set gramatikaMRegulojKorektado]} {
        set gkorektilo [GramMReguloKorektilo prenuKorektiolon]
        $gkorektilo testuPorErarkolektilo [self] [my sintaksAsto]
    }
    if {[EsperantoConf set gramatikaPliBonajVortoj] || [EsperantoConf set gramatikaFalsajAmikoj]} {
        set gkorektilo [PliBonaVortoKorektilo prenuKorektiolon]
        $gkorektilo testuPorErarkolektilo [self] [my sintaksAsto]
    }
    [my sintaksAsto] sxercxiErarojn [self]
    my puriguLauxGraveco
}
@ Class EspEspVortaro {
description {Esperanto-Esperanto vortaro.
La vortaro estas enlegata de teksta dosiero.
Formato
  * # komentaro
  * vorto : vorto1 vorto2 ...
Tiu vortaro estas uzata cxe inversa esperanta vortfarado
}
}
Class EspEspVortaro
@ ::EspEspVortaro idemeta component EspSintaksaAnalizo
EspEspVortaro instproc leguDeDosiero dosiero {
    my instvar vortojArr sencoaroj
    if {![file isfile $dosiero]} {
        puts "dosiero por eo-eo Vortaro ne trovita $dosiero"
        return
    }
    set dosieroSize [file size $dosiero]
    set f [open $dosiero r]
    fconfigure $f -encoding utf-8
    unset -nocomplain vortojArr
    set indekso 0
    set sencoaroj [list]
    if {[Object isobject ProgresoMontrilo]} {
        set progreso [ProgresoMontrilo startNurProgress "Atendu! Esperantilo legas sinonimojn"]
    } else {
        set progreso ""
    }

    set i 0

    while {[gets $f line]>=0} {
        if {$i%30==0 && $progreso ne ""} {
            set pos [tell $f]
            $progreso setProgress [expr {round(100.0*$pos/$dosieroSize)}]
            $progreso isStopped
        }
        incr i
        set line [string trim $line]
        if {[string index $line 0] eq "#"} {
            continue
        }
        set sj [split $line :]
        if {[llength $sj]<=1} continue
        set aro [list]
        set ivortoj [list]
        foreach s $sj {
            set s [string trim $s]
            if {$s eq ""} continue
            if {[lsearch $aro $s]>=0} {
                continue
            }
            if {[llength $s]==1} {
                lappend ivortoj $s
            }
            lappend aro $s
        }
        if {[llength $ivortoj]>0} {
            lappend sencoaroj $aro
            foreach v $ivortoj {
                set ivorto [string tolower $v]
                lappend vortojArr($ivorto) $indekso
            }
            incr indekso
        } else {
            puts "unuvorta indekso ne trovita en: [join $aro \;]"
        }
    }
    if {$progreso ne ""} {
        $progreso cleanUpAfterSignal
        $progreso destroy
    }
    close $f
}
EspEspVortaro instproc relegu {} {
    my leguDeDosiero [EspEspVortaro prenuDosieron]
}
EspEspVortaro instproc trovuPorVorto vorto {
    my instvar vortojArr sencoaroj
    if {[catch {set vortojArr($vorto)} indekso]} {
        return
    }
    set rez [list]
    foreach i $indekso {
        foreach s [lindex $sencoaroj $i] {
            ide::lappendIfNone rez $s
        }
    }
    ide::lremove rez $vorto
    return $rez
}
EspEspVortaro instproc trovuSinonimojPorVorto vorto {
    set arto [string index $vorto end]
    set list [my trovuPorVorto $vorto]
    if {[llength $list]>10} {
        return $list
    }
    if {[EsperantoConf set sinonimojUzuTradukado]} {
        set tvortaro [DBVortaro prenuDepVortaron]
        foreach t [$tvortaro sxercxuRezListo $vorto de] {
            foreach e [$tvortaro sxercxuRezListoPorTraduko [dict get $t traduko] de] {
                set svorto [dict get $e vorto]
                if {[lsearch $list $svorto]<0 && $vorto ne $svorto && $arto eq [string index $svorto end]} {
                    lappend list $svorto
                }
            }
        }
    }
    return $list
}
EspEspVortaro instproc trovuSinonimojPorVortoFleksio fvorto {
    if {[regexp {(.+?)([aoi]n?t(?:e|o|on|ojn|oj|a|an|ajn|aj))$} $fvorto _ vorto f]} {
        # participo
        set ktg i
    } elseif {[regexp {(.+?)(i|as|os|is|u|us)$} $fvorto _ vorto f]} {
        set vorto ${vorto}i
        set ktg i
    } elseif {[regexp {(.+?)(n|jn|j)$} $fvorto _ vorto f]} {
        set ktg o
    } else {
        set vorto $fvorto
        set ktg ""
    }

    set espvortaro [Vortaro prenuVortaron]
    set ret [list]

    foreach s [my trovuSinonimojPorVorto $vorto] {
        set trovita 1
        set index 0
        foreach v $s {
            # tranformo de gramatiko
            if {$ktg eq "i" && [string index $v end] eq "i"} {
                lset s $index [string range $v 0 end-1]$f
            } elseif {$ktg eq "o" && [string first [string index $v end] "oa"]>=0} {
                lset s $index ${v}$f
            }
            incr index
        }
        lappend ret [join $s]
    }
    return $ret
}
EspEspVortaro proc prenuDosieron {} {
    file join [EsperantoConf prenuVortaroDosierujo] eo-eo.txt
}
EspEspVortaro proc prenuVortaron {} {
    my instvar vortaro
    if {![info exists vortaro] || ![Object isobject $vortaro]} {
        set vortaro [my new]
        $vortaro relegu
    }
    return $vortaro
}
@ Class EspReVortfarado {
description {Tiu klaso provas inversi la esperatan vortvarado.
De unu elemento farigxa struktura, kiun oni povas pli bone traduki

Ekzeploj:
 * knabeto - eta knabo
 * purigi - igi pura
Adentu, ke ofte tiu reversa vortfarado povas rezulti falsan signifon kaj sekve tradukadon.}
}
Class EspReVortfarado
@ ::EspReVortfarado idemeta component EspSintaksaAnalizo
EspReVortfarado instproc reanalizuFrazparton subfrazo {
    set frazo [GP::Frazo new -childof [my info parent]]
    $frazo leguFrazon [Vortaro prenuVortaron] $subfrazo
    set analizilo [SintaksaAnalizo new]
    $analizilo frazo $frazo
    $analizilo analizu
    $analizilo destroy
    set rad [$frazo sintaksoarbo]
    $rad funkcio [my funkcio]
    # metu la originan elementoj en cxiu folio
    foreach e [$rad prenuElementoj] {
        $e set originaElemento [self]
        # bezonato por malebligi infinitive loop
        $e aliguMerkmalon revortvarado
    }
    foreach e [$rad prenuBrancxoj] {
        $e mixin add VortfaradoAstoMix
    }
    [$rad prenuRadiko] funkcio [my funkcio]
    if {[llength [$rad set astoj]]==1} {
        [lindex [$rad set astoj] 0] funkcio [my funkcio]
    }
    return [$rad set astoj]
}
EspReVortfarado instproc remorfigu {vortaro lingvo} {
    # malebligu la "infinitive loop"
    if {[my havasMerkmalon revortvarado]} {
        return
    }
    set def {
        fi(.+o)(n|jn|j)?        $v    {fia $v$f}
        ĉef(.+o)(n|jn|j)?       $v    {ĉefa $v$f}
        fi(.+)(i|as|os|is|u|us) ${v}i {fie $v$f}
        mis(.+)(i|as|os|is|u|us) ${v}i {mise $v$f}
        (.+)ind(i|as|os|is|u|us) ${v}i {ind$f ${v}i}
        (.+)end(i|as|os|is|u|us) ${v}i {end$f ${v}i}
        (.+)ebl(i|as|os|is|u|us) ${v}i {ebl$f ${v}i}
        fi(.+a)(n|jn|j)?        $v    {fie $v$f}
        fi(.+e)                 $v    {fie $v}
        (.+)eto(n|jn|j)?        ${v}o {eta$f ${v}o$f}
        (.+)ego(n|jn|j)?        ${v}o {ega$f ${v}o$f}
        (.+)aĉo(n|jn|j)?        ${v}o {aĉa$f ${v}o$f}
        (.+)ega(n|jn|j)?        ${v}a {ege ${v}a$f}
        (.+)eta(n|jn|j)?        ${v}a {ete ${v}a$f}
        (.+)ege                 ${v}e {ege ${v}e}
        (.+)ete                 ${v}e {ete ${v}e}
        (.+)ig(i|as|os|is|u|us) ${v}a {ig$f ${v}a}
        (.+)iĝ(i|as|os|is|u|us) ${v}a {iĝ$f ${v}a}
        (.+)inda(n|jn|j)?       ${v}o {inda$f de ${v}o}
        (.+)inde                ${v}o {inde de ${v}o}
        (.+)ende                ${v}o {ende de ${v}o}
        (.+)enda(n|jn|j)?       ${v}o {enda$f de ${v}o}
        (.+)(i|as|os|is|u|us)   ${v}a {est${f} ${v}a}
        (.+)ero(n|jn|j)?        ${v}o {ero$f de ${v}o}
        (.+)aro(n|jn|j)?        ${v}o {aro$f de ${v}oj}
        (.+)ujo(n|jn|j)?        ${v}o {ujo$f por ${v}o}
        (.+)ano(n|jn|j)?        ${v}o {ano$f de ${v}o}
        (.+)grupo(n|jn|j)?      ${v}o {grupo$f de ${v}oj}
        (.+)ebla(n|jn|j)?       ${v}o {ebla$f por ${v}o}
        (.+)plena(n|jn|j)?      ${v} {plena$f de ${v}}
        sam(.+)a(n|jn|j)?       ${v}a {same ${v}a$f}
        tut(.+)a(n|jn|j)?       ${v}a {tute ${v}a$f}
        plur(.+)a(n|jn|j)?      ${v}a {plure ${v}a$f}
        (.+)kolora(n|jn|j)?     ${v}o {en la koloro de ${v}o}
        sen(.+)e                ${v}o {sen ${v}o}
        kun(.+)e                ${v}o {kun ${v}o}
        per(.+)e                ${v}o {per ${v}o}
        dum(.+)e                ${v}o {dum ${v}o}
        sen(.+)a(n|jn|j)?       ${v}o {sen ${v}o}
        pri(.+)a(n|jn|j)?       ${v}o {pri ${v}o}
        per(.+)a(n|jn|j)?       ${v}o {per ${v}o}
        dum(.+)a(n|jn|j)?       ${v}o {dum ${v}o}
        plu(.+)(i|as|os|is|u|us)$   ${v}i {plue ${v}i}
        pli(.+)ig(i|as|os|is|u|us)$ ${v}a {ig$f pli ${v}a}
        pli(.+)iĝ(i|as|os|is|u|us)$ ${v}a {iĝ$f pli ${v}a}
        (.+)speco(n|jn|j)?       ${v}o {speco$f de ${v}o}
        (.+)nomo(n|jn|j)?       ${v}o {nomo$f de ${v}o}
        (.+)stilo(n|jn|j)?       ${v}o {stilo$f de ${v}o}
        (.+o)riĉa               $v {riĉa je ${v}j}
        (.+)riĉa                ${v}o {riĉa je ${v}oj}
        (.+o)plena              $v {plena je ${v}j}
        (.+)plena               ${v}o {plena je ${v}oj}
        (.+o)simila             $v {simila je ${v}j}
        (.+)simila              ${v}o {simila je ${v}oj}
    }
    # senkonsila homo -> homo sen konsilo
    set vorto [my prenuVorton]
    
    if {[my hasclass GP::Partizipo]} {
        foreach subfrazo [[EspEspVortaro prenuVortaron] trovuPorVorto [my prenuParticipanBazanFormon]] {
            set espvortaro [Vortaro prenuVortaron]
            set trovita 1
            set index 0
            # transfero de gramatika kategorio
            # debatas -> debati -> oficiale diskuti -> oficiale disktas
            if {[regexp {.+?([aoi]n?t(?:e|o|on|ojn|oj|a|an|ajn|aj))$} $vorto _ f]} {
                # participo
                set ktg i
            } elseif {[regexp {.+?(i|as|os|is|u|us)$} $vorto _ f]} {
                set ktg i
            } elseif {[regexp {.+?(n|jn|j)$} $vorto _ f]} {
                set ktg o
            } else {
                set ktg ""
            }
            foreach v $subfrazo {
                if {[string range $v end-1 end] eq "en"} {
                    set vr $v
                } else {
                    set vr [EORadikilo radikigi $v]
                }
                if {![$espvortaro estasVorteto $v] && [llength [$vortaro sxercxuRezListo $vr $lingvo]]==0} {
                    set trovita 0
                    break
                }
                # tranformo de gramatiko
                if {$ktg eq "i" && [string index $v end] eq "i"} {
                    lset subfrazo $index [string range $v 0 end-1]$f
                } elseif {$ktg eq "o" && [string first [string index $v end] "oa"]>=0} {
                    lset subfrazo $index ${v}$f
                }
                incr index
            }
            if {$trovita} {
                return [my reanalizuFrazparton $subfrazo]
            }
        }
    }
    
    foreach subfrazo [[EspEspVortaro prenuVortaron] trovuPorVorto [my prenuBazanFormon]] {
        set espvortaro [Vortaro prenuVortaron]
        set trovita 1
        set index 0
        # transfero de gramatika kategorio
        # debatas -> debati -> oficiale diskuti -> oficiale disktas
        if {[regexp {.+?([aoi]n?t(?:e|o|on|ojn|oj|a|an|ajn|aj))$} $vorto _ f]} {
            # participo
            set ktg i
        } elseif {[regexp {.+?(i|as|os|is|u|us)$} $vorto _ f]} {
            set ktg i
        } elseif {[regexp {.+?(n|jn|j)$} $vorto _ f]} {
            set ktg o
        } else {
            set ktg ""
        }
        foreach v $subfrazo {
            if {[string range $v end-1 end] eq "en"} {
                set vr $v
            } else {
                set vr [EORadikilo radikigi $v]
            }
            if {![$espvortaro estasVorteto $v] && [llength [$vortaro sxercxuRezListo $vr $lingvo]]==0} {
                set trovita 0
                break
            }
            # tranformo de gramatiko
            if {$ktg eq "i" && [string index $v end] eq "i"} {
                lset subfrazo $index [string range $v 0 end-1]$f
            } elseif {$ktg eq "o" && [string first [string index $v end] "oa"]>=0} {
                lset subfrazo $index ${v}$f
            }
            incr index
        }
        if {$trovita} {
            return [my reanalizuFrazparton $subfrazo]
        }
    }
    
    foreach {mustero tradukvorto strukturo} $def {
        if {[regexp ^${mustero}$ $vorto _ v f]} {
            set tradukvorto [subst $tradukvorto]
            # cxu traduko de subvorto estas konata
            if {[llength [$vortaro sxercxuRezListo $tradukvorto $lingvo]]>0} {
                # remorfigu
                set subfrazo [subst $strukturo]
                return [my reanalizuFrazparton $subfrazo]
            }
        }
    }
    # lingvoinstruigo -> instruigo de lingvo

    if {[regexp {^.+o.+o(n|jn|j)?$} $vorto]} {
        my instvar derivolisto radiko
        if {[info exists derivolisto] && [info exists radiko]} {
            set pre [lindex $derivolisto 0]
            if {$pre ne "" && [string index $pre end] eq "o"} {
                set post "[string range $vorto [string length $pre] end]"
                set postlema [[Radikilaro prenuPorLingvo eo] radikigi $post]
                if {[llength [$vortaro sxercxuRezListo $pre $lingvo]]>0 && [llength [$vortaro sxercxuRezListo $postlema $lingvo]]>0} {
                    set subfrazo "$post de $pre"
                    return [my reanalizuFrazparton $subfrazo]
                }
            }
        }
    }
    # tem-kampo => tema kampo
    # temo-kampo => kampo de temo
    if {[regexp {^(.+)-(.+o)(n|jn|j)?$} $vorto _ pre post fino]} {
        my instvar derivolisto radiko
        if {[info exists derivolisto] && [info exists radiko]} {
            if {[string index $pre end] eq "o"} {
                if {[llength [$vortaro sxercxuRezListo $pre $lingvo]]>0 && [llength [$vortaro sxercxuRezListo $post $lingvo]]>0} {
                    set subfrazo "$post$fino de $pre"
                    return [my reanalizuFrazparton $subfrazo]
                }
            } elseif {[string first [string index $pre end] "iae"]<0} {
                if {[llength [$vortaro sxercxuRezListo ${pre}a $lingvo]]>0 && [llength [$vortaro sxercxuRezListo $post $lingvo]]>0} {
                    set subfrazo "${pre}a $post$fino"
                    return [my reanalizuFrazparton $subfrazo]
                }
            }
        }
    }
    return
}
Class FSAktiva -parameter {elemento difino analizilo}
@ ::FSAktiva idemeta component EspSintaksaAnalizo
FSAktiva instproc faruArbon {} {
    my instvar parenco elemento difino transitions elementoj arbo lastArboIndekso
    if {[llength $elementoj]>1 && [[lindex $transitions end] estasEblaFino]} {
        if {![info exists arbo]} {
            my faruNovanArbon
            return 1
        } else {
            # Cxu arbo devas esti pligrandigita
            if {[llength $elementoj]==$lastArboIndekso} {
                return 0
            } else {
                my pligrandiguArbon
                return 1
            }
        }
    }
    return 0
}
FSAktiva instproc faruNovanArbon {} {
    my instvar parenco elemento difino transitions elementoj arbo lastArboIndekso
    set relementoj [$difino preparuElementojn $elementoj]
    set arbo [$difino kreuNovanArbon [self] $transitions $relementoj]
    set parbo [$elemento set parenco]
    $parbo tausxuAstoj $elemento $arbo
    $arbo initParencon $parbo
    set elementoj $relementoj
    set lastArboIndekso [llength $elementoj]
}
FSAktiva instproc init {} {
    my instvar elemento difino transitions elementoj
    lappend transitions [lindex [$difino set transitions] 0]
    lappend elementoj $elemento
}
FSAktiva instproc pligrandiguArbon {} {
    my instvar parenco elemento difino transitions elementoj arbo lastArboIndekso

    set relementoj [list]
    foreach e [lrange $elementoj $lastArboIndekso end] {
        lappend relementoj [$e miAuxRadikaElemento]
    }
    foreach e $relementoj {
        $e foriguDeParenco
    }
    $difino pligrandiguArbon [self] $arbo [lrange $transitions $lastArboIndekso end] $relementoj
    $arbo initParencon [$arbo set parenco]
    set elementoj [lreplace $elementoj $lastArboIndekso end {*}$relementoj]
    set lastArboIndekso [llength $elementoj]
}
FSAktiva instproc trovuSekvan {} {
    my instvar transitions elementoj
    set rez [[lindex $transitions end] trovuSekvan [lindex $elementoj end] [self]]
    if {[llength $rez]>0} {
        lappend transitions [lindex $rez 0]
        lappend elementoj [lindex $rez 1]
        return 1
    }
    return 0
}
Class FSAktivaProceso -parameter arbo
@ ::FSAktivaProceso idemeta component EspSintaksaAnalizo
FSAktivaProceso instproc aldonuTrans {difino elemento} {
    my instvar tlisto arbo
    puts "addTrans [$difino printString] [$elemento printString]"
    lappend tlisto [FSAktiva new -childof $arbo -elemento $elemento -difino $difino -analizilo [self]]
}
FSAktivaProceso instproc analizu {} {
    my instvar arbo analizo tlisto
    set difinoj [FSDefino set difinoj]
    set tlisto [list]
    foreach e [$arbo astoj] {
        foreach d $difinoj {
            if {[$d estasStarto $e]} {
                my aldonuTrans $d $e
                break
            }
        }
    }
    while 1 {
        set havasLaboron 0
        foreach t $tlisto {
            if {[$t trovuSekvan]} {
                set havasLaboron 1
            }
        }
        if {$havasLaboron} {
            continue
        }
        foreach t $tlisto {
            if {[$t faruArbon]} {
                set havasLaboron 1
            }
        }
        if {$havasLaboron} {
            continue
        }
        break
    }

}
Class FSDefino -parameter {elemento arbo {testo {}}}
@ ::FSDefino idemeta component EspSintaksaAnalizo
FSDefino instproc addTrans {tclass args} {
    my instvar transitions
    puts "addTrans $args"
    foreach a $args {
        puts "=$a"
    }
    set d [$tclass new -childof [self]]
    foreach {k v} $args {
       if {[string index $k 0] ne "-"} {
           error "bad param $k in $args"
       }
       puts "k='$k' v='$v'"
       $d [string range $k 1 end] $v
    }
    lappend transitions $d
    return $d
}
FSDefino instproc estasStarto elem {
    my instvar elemento testo
    expr {[$elem hasclass $elemento] && ($testo eq "" || [$elem {*}$testo])}
}
FSDefino instproc initTransitions {} {
    my instvar transitions
    foreach t $transitions {
        set nomo [$t nomo]
        if {[info exists transArr($nomo)]} {
            error "la trans $nomo estas jam difinita"
        } else {
            set transArr($nomo) $t
        }
    }
    set havasRadiko 0
    foreach t $transitions {
        set sekvajObj [list]
        foreach s [$t sekvaj] {
            if {![info exists transArr($s)]} {
                error "la sekva trans $s en [$t nomo] ne estas difinita"
            } else {
                lappend sekvajObj $transArr($s)
            }
        }
        $t set sekvajObj $sekvajObj
        if {[$t funkcio] eq "radiko"} {
            set havasRadiko 1
        }
    }
    if {!$havasRadiko} {
        [lindex $transitions 0] funkcio radiko
    }
}
FSDefino instproc kreuNovanArbon {aktiva transitions relementoj} {
    my instvar arbo
    set narbo [$arbo new -childof [$aktiva set analizilo] -astoj [lreverse $relementoj]]
    foreach t $transitions e $relementoj {
        $e funkcio [$t funkcio]
    }
    return $narbo
}
FSDefino instproc pligrandiguArbon {aktiva arbo transitions relementoj} {
    set oastoj [$arbo set astoj]
    set oastoj [concat [lreverse $relementoj] $oastoj]
    $arbo set astoj $oastoj
    foreach t $transitions e $relementoj {
        $e funkcio [$t funkcio]
    }
}
FSDefino instproc preparuElementojn elementoj {
    set relementoj [list]
    foreach e $elementoj {
        lappend relementoj [$e miAuxRadikaElemento]
    }
    foreach e [lrange $relementoj 1 end] {
        $e foriguDeParenco
    }
    return $relementoj
}
FSDefino instproc prigrandiguArbon {aktiva arbo transitions relementoj} {
    set oastoj [$arbo set astoj]
    set oastoj [concat [lreverse $relementoj] $oastoj]
    $arbo set astoj $oastoj
    foreach t $transitions e $relementoj {
        $e funkcio [$t funkcio]
    }
}
FSDefino instproc subdef body {
    my instvar subdef
    set subdef [FSDefino defBase {*}$body]
}
FSDefino instproc transitions body {
    my eval $body
    my initTransitions
}
FSDefino proc analizu arbo {
    my instvar difinoj
    set aproceso [FSAktivaProceso new -childof $arbo -arbo $arbo]
    $aproceso analizu
    return $aproceso
}
FSDefino proc def {dclass args} {
    my instvar difinoj
    set d [my defBase $dclass {*}$args]
    lappend difinoj $d
    return $d
}
FSDefino proc defBase {dclass args} {
    set d [$dclass new -childof [self]]
    foreach {k v} $args {
        $d [string range $k 1 end] $v
    }
    return $d
}
FSDefino proc difinuCio {} {
    my purigu
    # Artur Trzewik
    my def FSDefino -elemento GP::Elemento -arbo SintaksAsto::nomo -testo {estasEblaNomo} -transitions {
        my addTrans FSDTransition -nomo n1 -sekvaj {n2}
        my addTrans FSDTransition -nomo n2 -elemento GP::Elemento -testo {estasEblaNomo}
    }
    # tre longa
    my def FSDefino -elemento GP::Adjektivo -arbo SintaksAsto::adjp -transitions {
        my addTrans FSTransition -nomo adj -sekvaj {tre}
        my addTrans FSTransition -nomo tre -elemento GP::PrimitivaAdverbo -testo {estasVorto tre}
    }
    # mia bona libro
    my def FSDefino -elemento GP::Substantivo -arbo SintaksAsto::np -testo estasNePronomo -transitions {
        my addTrans FSTransition -nomo subj -sekvaj {adj la pos}
        my addTrans FSTransition -nomo adj -elemento GP::Adjektivo -sekvaj {la adj pos amb}
        my addTrans FSTransition -nomo la -elemento GP::Difinilo -testo {estasVorto la}
        my addTrans FSTransition -nomo amb -elemento GP::Difinilo -testo {estasVorto ambaŭ} -sekvaj pos
        my addTrans FSTransition -nomo pos -elemento GP::PosesivPronomo -sekvaj amb
    }
    # en mia libro (subdef en mia libro de konata auxtoro)
    my def FSDDifino -elemento GP::Prepozicio -arbo SintaksAsto::pp -transitions {
        my addTrans FSDTransition -nomo pp -sekvaj {subj}
        my addTrans FSDTransition -nomo subj -elemento GP::Substantivo
    } -subdef {
        FSDefino -elemento SintaksAsto::pp -arbo SintaksAsto::subsup -testo {estasPrepozicio de} -transitions {
            my addTrans FSTransition -nomo pp -sekvaj {subj}
            my addTrans FSTransition -nomo subj -elemento GP::Substantivo -funkcio radiko
        }
    }
    # kaj interpunkcio
    my def FSLigDifino -elemento GP::Konjunkcio -arbo SintaksAsto::konj -testo {estasVorto kaj} -transitions {
        my addTrans FSLigTransition -nomo kaj -sekvaj {frat}
        my addTrans FSLigTransition -nomo frat -sekvaj {}
    }
    # nfvp
    my def FSDDifino -elemento GP::Verbo -testo {estasInfinitivo} -arbo SintaksAsto::nfvp -transitions {
        my addTrans FSDTransition -nomo nvfp -sekvaj {obj pp adv}
        my addTrans FSDTransition -nomo obj -elemento GP::Substantivo -testo {estasAkuzativo} -sekvaj {pp adv}
        my addTrans FSDTransition -nomo pp -elemento GP::Prepozicio -sekvaj {pp adv}
        my addTrans FSDTransition -nomo adv -elemento GP::Adverbo -sekvaj {pp adv}
    }
}
FSDefino proc purigu {} {
    my instvar difinoj
    if {[info exists difinoj]} {
        foreach d $difinoj {
            if {[Object isobject $d]} {
                $d destroy
            }
        }
    }
    set difinoj [list]
}
Class FSDDifino -superclass ::FSDefino
@ ::FSDDifino idemeta component EspSintaksaAnalizo
FSDDifino instproc kreuNovanArbon {aktiva transitions relementoj} {
    my instvar arbo subdef
    set narbo [$arbo new -childof [$aktiva set analizilo] -astoj $relementoj]
    foreach t $transitions e $relementoj {
        $e funkcio [$t funkcio]
    }
    if {[info exists subdef]} {
        if {[$subdef estasStarto $narbo]} {
            [$aktiva set analizilo] aldonuTrans $subdef $narbo
        }
    }
    return $narbo
}
FSDDifino instproc pligrandiguArbon {aktiva arbo transitions relementoj} {
    set oastoj [$arbo set astoj]
    set oastoj [concat $oastoj $relementoj]
    $arbo set astoj $oastoj
    foreach t $transitions e $relementoj {
        $e funkcio [$t funkcio]
    }
}
Class FSDTransition
@ ::FSDTransition idemeta component EspSintaksaAnalizo
FSDTransition instproc prenuSekvan elemento {
    my prenuDekstra $elemento
}
Class FSLigDifino
@ ::FSLigDifino idemeta component EspSintaksaAnalizo
FSLigDifino instproc kreuNovanArbon {aktiva transitions relementoj} {
    my instvar arbo subdef
    set pre [list]
    set post [list]
    foreach e [lrange $relementoj 1 end] {
        lappend pre [lindex $e 0]
        lappend post [lindex $e 1]
    }
    set aelementoj [concat $pre [lindex $relementoj 0] $post]
    set narbo [$arbo new -childof [$aktiva set analizilo] -astoj $aelementoj]
    [lindex $relementoj 1 0] funkcio radiko
    return $narbo
}
FSLigDifino instproc preparuElementojn elementoj {
    set relementoj [list]
    lappend relementoj [[lindex $elementoj 0] miAuxRadikaElemento]
    lappend relementoj [list [[lindex $elementoj 1 0] miAuxRadikaElemento] [[lindex $elementoj 1 1] miAuxRadikaElemento]]
    [lindex $relementoj 1 0] foriguDeParenco
    [lindex $relementoj 1 1] foriguDeParenco
    return $relementoj
}
Class FSLigTransition
@ ::FSLigTransition idemeta component EspSintaksaAnalizo
FSLigTransition instproc trovuSekvan {elemento aktiva} {
    my instvar sekvajObj
    if {[llength $sekvajObj]==0} {
        return
    }
    set dekstra [my prenuDekstra $elemento]
    if {$dekstra eq ""} return
    set maldekstra [my prenuMaldekstra $elemento]
    if {$maldekstra eq ""} return
    if {[$dekstra estasKuneblaj $maldekstra [[$aktiva elemento] set vorto]]} {
        return [list [lindex $sekvajObj 0] [list $maldekstra $dekstra]]
    }
    return
}
Class FSTransition -parameter {nomo elemento {sekvaj {}} {testo {}} {funkcio parto} {nefino 0}}
@ ::FSTransition idemeta component EspSintaksaAnalizo
FSTransition instproc eblasElemento elem {
    my instvar elemento testo
    expr {[$elem hasclass $elemento] && ($testo eq "" || [$elem {*}$testo])}
}
FSTransition instproc estasEblaFino {} {
    my instvar sekvaj nefino
    expr {[llength $sekvaj]==0 || !$nefino}
}
FSTransition instproc estasFino {} {
    my instvar sekvaj
    expr {[llength $sekvaj]==0}
}
FSTransition instproc prenuDekstra elemento {
    set sf [$elemento prenuSekvanFraton]
    if {$sf eq ""} {
        set sf [$elemento prenuSekvaElemento]
    }
    if {$sf ne ""} {
        return [$sf prenuRadiko]
    }
    return
}
FSTransition instproc prenuMaldekstra elemento {
    set sf [$elemento prenuAntauxFraton]
    if {$sf eq ""} {
        set sf [$elemento prenuAntauxElemento]
    }
    if {$sf ne ""} {
        return [$sf prenuRadiko]
    }
    return
}
FSTransition instproc prenuSekvan elemento {
    my prenuMaldekstra $elemento
}
FSTransition instproc trovuSekvan {elemento aktiva} {
    my instvar sekvajObj
    if {[llength $sekvajObj]==0} {
        return
    }
    set f [my prenuSekvan $elemento]
    if {$f eq ""} return
    foreach trans $sekvajObj {
          if {[$trans eblasElemento $f]} {
              return [list $trans $f]
          }
    }
    return
}
Object GP
@ ::GP idemeta component EspSintaksaAnalizo
@ Class GP::Elemento {
description {Baza elemento por cxiuj folioj de sintaksa arbo}
}
Class GP::Elemento -superclass {::ArboFolio ::AstoElemento ::EspReVortfarado} -parameter {vorto radiko funkcio komenco fino derivolisto}
@ ::GP::Elemento idemeta categories {convert tests graph-travers}
@ ::GP::Elemento idemeta categoriesMethods {{appendDOM asList asFormatedList asTaggerList asDOM} {havasFunkcion estasVorto estasPartizipo estasPlenaGrandSkribita estasNeTablovorto estasNomo estasEblaNomoAuxNomo estasNeSimbolo estasNeSimboloNeVerbo estasBasaVorto estasViraNomo estasVirinaNomo estasBazajVortoj estasNeParticipo estasUnuaGrandSkribita havasDerivoPriskribon estasNeVerbo estasVortoj estasUnuaElementoEnFrazo estasEblaNomo estasGrandSkribita estasNekonataGrandskribita estasNekonata estasParticipoPasiva estasElemento estasKuneblaj} initParencon}
@ ::GP::Elemento idemeta component EspSintaksaAnalizo
GP::Elemento instproc analizu {} {
}
GP::Elemento instproc appendDOM dom {
    next
}
GP::Elemento instproc asDOM doc {
    set elem [$doc createElement [namespace tail [my info class]]]
    $elem setAttribute funkcio [my prenuFunkcioNomo]
    foreach p [[my info class] info parameter] {
        set pname [lindex $p 0]
        if {$pname eq "vorto" || $pname eq "radiko"} continue
        if {[my exists $pname]} {
            $elem setAttribute $pname [my $pname]
        }
    }
    set vortoDOM [$doc createElement vorto]
    $vortoDOM appendChild [$doc createTextNode [my vorto]]
    $elem appendChild $vortoDOM
    if {[my exists radiko] && [my radiko] ne ""} {
        set radikoDOM [$doc createElement radiko]
        $radikoDOM appendChild [$doc createTextNode [[my radiko] prenuRadiko]]
        $elem appendChild $radikoDOM
    }
    if {[my exists derivolisto] && [llength [my derivolisto]]>0} {
        set drvDOM [$doc createElement derivolisto]
        $drvDOM appendChild [$doc createTextNode [my derivolisto]]
        $elem appendChild $drvDOM
    }
    my appendDOM $elem
    return $elem
}
GP::Elemento instproc asFormatedList {{ident 0}} {
    set identString [string repeat "    " $ident]
    return "$identString[my prenuSimbolo]:[my prenuFunkcioNomo]:[my prenuBazanFormon]:[my prenuVorton]"
}
GP::Elemento instproc asList {} {
    return "[my prenuSimbolo]:[my vorto]"
}
GP::Elemento instproc asTaggerList {} {
    set v [my prenuVorton]
    set bf [my prenuBazanFormon]
    if {$v eq $bf} {
        set bf ""
    }
    set attrs ""
    foreach attr {tempo nombro kazo} {
        if {[my exists $attr]} {
            if {$attrs eq ""} {
                set attrs :(
            } else {
                append attrs ,
            }
            append attrs $attr=[my set $attr]
        }
    }
    if {$attrs ne ""} {
        append attrs )
    }
    return "[my prenuSimbolo]:[my prenuVorton]:$bf$attrs"
}
GP::Elemento instproc estasBasaVorto vorto {
    expr {[my prenuBazanFormon] eq $vorto}
}
@ GP::Elemento instproc estasBazaElemento {} {
description {Testo cxu primitiva elemento (ne strukturo).
SintaksAsto::ignor povas esti ankaux primitiva elemento}
}
GP::Elemento instproc estasBazaElemento {} {
    return 1
}
GP::Elemento instproc estasBazajVortoj vortoj {
    expr {[my prenuBazanFormon] in $vortoj}
}
GP::Elemento instproc estasEblaNomo {} {
    my instvar vorto
    expr {[my estasUnuaGrandSkribita] && [string length $vorto]>1 && ([my hasclass GP::Konstanto] || [my hasclass GP::Nekonata] || [my estasNekonata])}
}
GP::Elemento instproc estasEblaNomoAuxNomo {} {
    expr {[my estasNomo] || [my estasEblaNomo]}
}
GP::Elemento instproc estasElemento elemento {
    expr {[$elemento estasBazaElemento] && ![$elemento istype GP::Simbolo]}
}
GP::Elemento instproc estasGrandSkribita {} {
    my instvar vorto
    expr {[string is alpha [string index $vorto 0]] && [string is upper [string index $vorto 0]]}
}
GP::Elemento instproc estasKuneblaj {elem ligilo stupo} {
    expr {[my prenuNomo] eq [$elem prenuNomo]}
}
GP::Elemento instproc estasNeParticipo {} {
    expr {![my estasPartizipo]}
}
GP::Elemento instproc estasNeSimbolo {} {
    expr {![my istype GP::Simbolo]}
}
GP::Elemento instproc estasNeSimboloNeVerbo {} {
    expr {![my istype GP::Simbolo] && ![my istype GP::Verbo]}
}
GP::Elemento instproc estasNeTablovorto {} {
    return 1
}
GP::Elemento instproc estasNeVerbo {} {
    expr {![my istype GP::Verbo] && ![my istype GP::Simbolo]}
}
GP::Elemento instproc estasNekonata {} {
    expr {[my hasclass GP::NekonataMix] || [my havasMerkmalon nekonataDerivo] || [my hasclass GP::Nekonata]}
}
GP::Elemento instproc estasNekonataGrandskribita {} {
    expr {[my estasNekonata] && [my estasGrandSkribita]}
}
GP::Elemento instproc estasNekonataGrandskribitaAuxNomo {} {
    my instvar vorto
    # Unesco
    # esperanto.net
    # mySolve
    expr {[my estasNekonata] && ([my estasGrandSkribita] || ![esp::enhavasEsparantajLiteroj $vorto] || [regexp {.[A-Z]} $vorto])}
}
GP::Elemento instproc estasNomo {} {
    expr {[my estasUnuaGrandSkribita] && ([my estasViraNomo] || [my estasVirinaNomo])}
}
GP::Elemento instproc estasParticipoPasiva {} {
    expr {[my ismixin GP::Partizipo] && [my estasPasiva]}
}
GP::Elemento instproc estasPartizipo {} {
    my ismixin GP::Partizipo
}
GP::Elemento instproc estasPlenaGrandSkribita {} {
    my instvar vorto
    expr {[string toupper $vorto] eq $vorto}
}
GP::Elemento instproc estasUnuaElementoEnFrazo {} {
    # demando cxu tiu vorto devas esti grandskribita
    # pensu pri : ( "
    # ekz. Li diris: Granda urbo estas tie.
    expr {[set ae [my prenuAntauxElemento]] ne "" && [$ae prenuVorton] ni [list "\"" : ( - > < \[ .]}
}
GP::Elemento instproc estasUnuaGrandSkribita {} {
    my instvar vorto
    expr {[string is alpha [string index $vorto 0]] && [string is upper [string index $vorto 0]] && [string is lower [string index $vorto 1]]}
}
GP::Elemento instproc estasViraNomo {} {
    Vortaro estasViraNomo [my prenuBazanFormon]
}
GP::Elemento instproc estasVirinaNomo {} {
    Vortaro estasVirinaNomo [my prenuBazanFormon]
}
GP::Elemento instproc estasVorto vorto {
    expr {[string tolower [my vorto]] eq $vorto}
}
GP::Elemento instproc estasVortoj vortoj {
    expr {[string tolower [my vorto]] in $vortoj}
}
GP::Elemento instproc generuDiskripto dfrazo {
    set frazo [my info parent]
    set dfunkcio disk
    if {[my exists funkcio]} {
        set dfunkcio [my set funkcio]
    }
    SintaksAsto::disk new -childof $frazo -astoj [list [self] $dfrazo] -funkcio $dfunkcio -relradiko [self]
}
GP::Elemento instproc havasDerivoPriskribon pri {
    my instvar derivolisto
    expr {[info exists derivolisto] && $pri in [lindex $derivolisto 2]}
}
GP::Elemento instproc havasFunkcion {} {
    my exists funkcio
}
GP::Elemento instproc initKunteksto parenco {
    if {![my havasFunkcion]} {
        if {[$parenco exists radiko] && [$parenco radiko] eq [self]} {
            my funkcio radiko
        }
    }
}
GP::Elemento instproc initParencon parenco {
    next
    if {![my exists funkcio]} {
        if {$parenco ne "" && [$parenco exists radiko] && [$parenco set radiko] eq [self]} {
            my funkcio radiko
        } else {
            my funkcio parto
        }
    }
}
GP::Elemento instproc invokeHalt args {
    my halt
    return 1
}
GP::Elemento instproc matchElem {tipo evaluo} {
    switch -exact -- $tipo {
        v {
            set vorto [my prenuVorton]
            if {$evaluo eq $vorto} {
                return 1
            }
        }
        vr {
            set vorto [my prenuVorton]
            if {[regexp ^${evaluo}\$ $vorto]} {
                return 1
            }
        }
        b {
            set vorto [my prenuBazanFormon]
            if {$evaluo eq $vorto} {
                return 1
            }
        }
        br {
            set vorto [my prenuBazanFormon]
            if {[regexp $evaluo $vorto]} {
                return 1
            }
        }
        f {
            set funkcio [my prenuFunkcioNomo]
            if {$funkcio eq $evaluo} {
                return 1
            }
        }
        fr {
            set funkcio [my prenuFunkcioNomo]
            if {[regexp $evaluo $funkcio]} {
                return 1
            }
        }
        s {
            set funkcio [my prenuSimbolo]
            if {$funkcio eq $evaluo} {
                return 1
            }
        }
        sr {
            set funkcio [my prenuSimbolo]
            if {[regexp $evaluo $funkcio]} {
                return 1
            }
        }
        AND {
            foreach {t v} $evaluo {
                if {![my matchElem $t $v]} {
                    return 0
                }
            }
            return 1
        }
        NOT {
           if {[my matchElem [lindex $evaluo 0] [lindex $evaluo 1]]} {
               return 0
           } else {
               return 1
           }
        }
        OR {
            foreach {t v} $evaluo {
                if {[my matchElem $t $v]} {
                    return 1
                }
            }
            return 0
        }
        k {
            if {[my testuKuntekston $evaluo]} {
                return 1
            }
        }
        antauxelemento {
            set ae [my prenuAntauxElemento]
            if {$ae ne ""} {
                return [$ae matchElem [lindex $evaluo 0] [lindex $evaluo 1]]
            } else {
                return 0
            }
        }
        radiko {
            return [[my miAuxRadikaElemento] matchElem [lindex $evaluo 0] [lindex $evaluo 1]]
        }
        parenco {
            return [[my parenco] matchElem [lindex $evaluo 0] [lindex $evaluo 1]]
        }

    }
    return 0
}
@ GP::Elemento instproc miAuxRadikaElemento {} {
description {rezukltas aux la objekto mem aux
la strukturo en kiu la elemento estas "radiko"
la metodo povas ignori priskriboj de elemto kaj trovi la plej alaj struktoron
en kiu la elemento estas radiko}
}
GP::Elemento instproc miAuxRadikaElemento {} {
    my instvar funkcio parenco
    if {![my estasRadiko]} {
       self
    } else {
       $parenco miAuxRadikaElemento
    }
}
GP::Elemento instproc prenuBazanFormon {} {
    my instvar radiko derivolisto vorto
    if {[info exists derivolisto]} {
        if {[string first - $vorto]>0} {
            EORadikilo radikigi [string tolower $vorto]
        } else {
            return [lindex $derivolisto 0][$radiko prenuRadiko][lindex $derivolisto 1]
        }
    } else {
        if {[info exists radiko]} {
            $radiko prenuRadiko
        } else {
            my prenuVorton
        }
    }
}
GP::Elemento instproc prenuBazanFormonKazoNombro {} {
    my prenuBazanFormon
}
@ GP::Elemento instproc prenuCxefFunkcion {} {
description {la plej grava funkcio de elemnto en frazo}
}
GP::Elemento instproc prenuCxefFunkcion {} {
    [my miAuxRadikaElemento] set funkcio
}
GP::Elemento instproc prenuCxefRadiko {} {
    self
}
GP::Elemento instproc prenuDiskribo {} {
    my instvar vorto derivolisto radiko
    set rez $vorto
    if {[info exists radiko]} {
        append rez " : [$radiko prenuRadiko]"
    }
    if {[info exists derivolisto]} {
        append rez " : [join $derivolisto]"
    }
    return $rez
}
GP::Elemento instproc prenuFinon {} {
    my fino
}
GP::Elemento instproc prenuFunkcioNomo {} {
    if {[my exists funkcio]} {
        my funkcio
    } else {
        return parto
    }
}
GP::Elemento instproc prenuGramatikeAnalogan vorto {
    if {[my hasclass GP::NombroKazo]} {
        next
    } else {
        return $vorto
    }
}
GP::Elemento instproc prenuKazon {} {
    # fall back for translation
    set ret [next]
    if {$ret eq ""} {
        return nominativo
    }
    return $ret
}
GP::Elemento instproc prenuKomencon {} {
    my komenco
}
GP::Elemento instproc prenuListon {} {
    list "[my prenuSimbolo]:[my prenuFunkcioNomo]" [my prenuVorton]
}
GP::Elemento instproc prenuNombron {} {
    # fall back for translation
    set ret [next]
    if {$ret eq ""} {
        return singularo
    }
    return $ret
}
GP::Elemento instproc prenuNomo {} {
    namespace tail [my info class]
}
@ GP::Elemento instproc prenuRadiko {} {
description {simila al "prenuRadiko".
Necesas por transparenta pritradktado de ingnro aux priskribo-frazoj
ekzemplo:

se, mi tion opinas, la vortaro malutilas, ...}
}
GP::Elemento instproc prenuRadiko {} {
    self
}
GP::Elemento instproc prenuRelFrazoRadiko {} {
    self
}
GP::Elemento instproc prenuSimbolo {} {
    namespace tail [my info class]
}
GP::Elemento instproc prenuSubsupRadiko {} {
    return
}
GP::Elemento instproc prenuVortoj {} {
    list [my prenuVorton]
}
GP::Elemento instproc prenuVorton {} {
    string tolower [my vorto]
}
GP::Elemento instproc printString {} {
    return "[my prenuNomo]: [my vorto]"
}
GP::Elemento instproc sxercxiErarojn kolektilo {
    next
}
GP::Elemento instproc sxercxiFrazokapon {} {
}
GP::Elemento instproc testuKuntekston priskribo {
    return 0
}
GP::Elemento instproc testuSencon senco {
    if {[string index $senco 0] eq "%"} {
        if {$senco eq "%persono" && [my istype GP::Substantivo]} {
            return [my estasPersono]
        }
        return 0
    } else {
        my estasBasaVorto $senco
    }
}
GP::Elemento instproc testuSintakso elem {
    if {[my prenuNomo] ne [lindex $elem 0] && ![my hasclass ::GP::[lindex $elem 0]]} {
        return 0
    }
    if {[llength $elem]>1} {
        return [my {*}[lrange $elem 1 end]]
    }
    return 1
}
GP::Elemento instproc testuStrukturo elem {
    my testuSintakso $elem
}
GP::Elemento instproc trovuMainVerboAston {} {
    my trovuUnuanPerenconKiu par {[$par hasclass SintaksAsto::main] || [$par hasclass SintaksAsto::nfvp]}
}
@ Class GP::NombroKazo {
description {Parenca klaso por cxiuj elementoj, kiuj havas kazon kaj numeron (substnativoj, adjektivoj, personpronomoj)}
}
Class GP::NombroKazo -parameter {nombro kazo}
@ ::GP::NombroKazo idemeta component EspSintaksaAnalizo
GP::NombroKazo instproc aliguKazoEraro {kolektilo estasAkuzativo teksto} {
    $kolektilo aliguEraron [self] $teksto [esp::prenuKazoNombro [my prenuBazanFormon] $estasAkuzativo [my estasPluralo]] 1
}
GP::NombroKazo instproc appendDOM dom {
    $dom setAttribute kazo [my kazo]
    $dom setAttribute nombro [my nombro]
}
GP::NombroKazo instproc ekkoniFinajxo finajxo {
    if {[string index $finajxo end] eq "n"} {
        my set kazo akuzativo
    } else {
        my set kazo nominativo
    }
    if {[string first j $finajxo]>=0} {
        my set nombro pluralo
    } else {
        my set nombro singularo
    }
}
GP::NombroKazo instproc estasAkuzativo {} {
    expr {[my kazo] eq "akuzativo"}
}
GP::NombroKazo instproc estasNominativo {} {
    expr {[my kazo] eq "nominativo"}
}
GP::NombroKazo instproc estasPluralo {} {
    expr {[my nombro] eq "pluralo"}
}
GP::NombroKazo instproc estasSingularo {} {
    expr {[my nombro] ne "pluralo"}
}
GP::NombroKazo instproc estasSubstantiva {} {
    # la alia
    expr {[my hasclass GP::Substantivo] || [my havasMerkmalon substantivaRolo]}
}
GP::NombroKazo instproc kolektuSubstantivoj {} {
    list [self]
}
GP::NombroKazo instproc prenuFrazpartoKazoNombro {estasAkuzativo estasPluralo} {
    list [self] [self] [esp::prenuKazoNombro [my prenuBazanFormon] $estasAkuzativo $estasPluralo]
}
GP::NombroKazo instproc prenuGramFinilon {} {
    my instvar kazo nombro
    set finilo o
    if {$nombro eq "pluralo"} {
        append finilo j
    }
    if {$kazo eq "akuzativo"} {
        append finilo n
    }
    return $finilo
}
GP::NombroKazo instproc prenuGramatikeAnalogan vorto {
    my instvar kazo nombro
    regexp $vorto {^(.+)j?$} _ vorto
    if {$nombro eq "pluralo"} {
        append vorto j
    }
    if {$kazo eq "akuzativo"} {
        append vorto n
    }
    return $vorto
}
GP::NombroKazo instproc prenuKazon {} {
    my kazo
}
GP::NombroKazo instproc prenuNombron {} {
    my nombro
}
@ Class GP::Adjektivo {
description {Normalaj adjektivoj}
}
Class GP::Adjektivo -superclass {::GP::Elemento ::GP::NombroKazo}
@ ::GP::Adjektivo idemeta component EspSintaksaAnalizo
GP::Adjektivo instproc estasAkuzativoNeParticipo {} {
    expr {![my estasPartizipo] && [my estasAkuzativo]}
}
GP::Adjektivo instproc estasAkuzativoSubRolo {} {
    expr {[my havasMerkmalon substantivaRolo] && [my estasAkuzativo]}
}
GP::Adjektivo instproc estasKuneblaj {elem ligilo stupo} {
    if {$stupo<1} {
        # Mi legas pri tre bona kaj interesa libro.
        return 0
    }
    set radobj [$elem prenuRadiko]
    if {[$radobj hasclass ::GP::Adjektivo] && [my kazo] eq [$radobj kazo]} {
       return 1
    }
    return 0
}
GP::Adjektivo instproc estasNeParticipo {} {
    expr {![my estasPartizipo]}
}
GP::Adjektivo instproc estasNeTranzitivaPartizipo {} {
    if {[my estasPartizipo] && [my estasPasiva]} {
        return 1
    }
    return 0
}
GP::Adjektivo instproc estasNominativoNeParticipo {} {
    expr {![my estasPartizipo] && [my estasNominativo]}
}
GP::Adjektivo instproc estasNominativoSubRolo {} {
    expr {[my havasMerkmalon substantivaRolo] && [my estasNominativo]}
}
GP::Adjektivo instproc estasPseudoNumeralo {} {
    my estasBazajVortoj {kelka multa plura}
}
GP::Adjektivo instproc estasTranzitivaPartizipo {} {
    if {[my estasPartizipo] && [my estasAktiva]} {
        return 1
    }
    return 0
}
GP::Adjektivo instproc prenuDifinilon {} {
    set relemento [my miAuxRadikaElemento]
    if {$relemento ne "" && [set p [$relemento set parenco]] ne "" && [$p istype SintaksAsto::np]} {
        return [$p prenuRadiko]
    }
    return
}
GP::Adjektivo instproc prenuSimbolo {} {
    if {[my ismixin [self class]]} {
         return "ADJ-[next]"
    } else {
         return ADJ
    }
}
GP::Adjektivo instproc sxercxiErarojn kolektilo {
    next
    my instvar parenco radiko kazo vorto funkcio
    set defElemento [my miAuxRadikaElemento]
    set kparenco [$defElemento set parenco]
    if {[my estasUnuaGrandSkribita] && ![my estasEblaNomo] && [my estasUnuaElementoEnFrazo]} {
        if {![my estasNekonata]} {
            # se la sekva vorto estas grandskribita eble temas pri nomo
            # ekz. Esperanta Asocio
            set sekva [my prenuSekvaElemento]
            if {$sekva eq "" || ![$sekva estasUnuaGrandSkribita]} {
                # testu parencon
                # ekz. Radio Polonia
                if {[my selektu {parenco {filtruVeron istype SintaksAsto::np} prenuRadiko estasUnuaGrandSkribita}]!="1"} {
                    $kolektilo aliguEraron [self] "oni skribas adjektivojn minuskle" [string tolower $vorto]
                }
            }
       }
    }
    if {[my havasMerkmalon substantivaRolo]} {
        # substantivaj eraroj ???
        return
    }
    if {$kparenco ne "" && [$kparenco istype SintaksAsto::main] && $funkcio ne "parto"} {
        set funkcio [my selektu {miAuxRadikaElemento prenuFunkcioNomo}]
        if {$funkcio eq "oattr"} {
            set subj [$kparenco trovuKunFunkcio obj]
        } else {
            set subj [$kparenco prenuSubjekton]
        }
        if {$subj eq ""} {
            if {![$kparenco estasOrdonoSenSubjekto] && [$kparenco prenuNeInfVerbo] ne ""} {
                $kolektilo aliguEraron [self] "nur adverboj povas priskribi sensubjektajn frazojn" [string range [my prenuBazanFormonKazoNombro] 0 end-1]e
            } elseif {[my prenuKazon] eq "akuzativo"} {
                $kolektilo aliguEraron [self] "priskriboj nur en nominativo"
            }
            return
        } elseif {[[$subj prenuRadiko] istype GP::Verbo]} {
            $kolektilo aliguEraron [self] "nur adverboj povas priskribi i-verbon" [string range [my prenuBazanFormonKazoNombro] 0 end-1]e
        }
        set kazo [my prenuKazon]
        set subNombro [$subj prenuNombron]
        set subjrad [$subj prenuRadiko]
        if {[$defElemento istype SintaksAsto::konj]} {
            $defElemento sxercxiAdjektivoErarojnNombreco $kolektilo [$subjrad prenuNombron] $kazo
        } else {
            if {[my prenuNombron] ne $subNombro} {
                # vi povas esti samtemp plurala aux singulara
                # nur en kazo "vi cxiuj" vi estas nur plurala
                if {![$subjrad estasBazajVortoj {vi si oni}] || [$subjrad prenuNombron] eq "pluralo"} {
                    if {$funkcio eq "obj"} {
                        set msg "nombro de adjektivo kaj objekto ne similas"
                    } else {
                        set msg "nombro de adjektivo kaj substantivo ne similas"
                    }
                    $kolektilo aliguEraron [self] $msg [esp::prenuKazoNombro [my prenuBazanFormonKazoNombro] 0 [expr {$subNombro eq "pluralo"}]]
                }
            }
        }
        if {$kazo eq "akuzativo"} {
            if {[$kparenco selektu {prenuRadiko estasEst}] eq "1"} {
                $kolektilo aliguEraron [self] "priskriboj de substantivo nur en nominativo" [esp::prenuKazoNombro [my prenuBazanFormonKazoNombro] 0 [my estasPluralo]]
                return
            }
        }
    }
    # Mi farbis la pordon blua
    # Sed ne "Mi trovis ion alian."
    if {[$parenco istype SintaksAsto::np] && [lindex [$parenco set astoj] end] eq [self] && $kazo eq "akuzativo"} {
        if {[$parenco selektu {0 {hasclass GP::TabloVorto}}] ne "1"} {
            set vasto [my trovuMainVerboAston]
            if {$vasto ne ""} {
                set vradiko [$vasto prenuRadiko]
                if {$vradiko ne "" && [$vradiko istype GP::Verbo]} {
                    if {[$vradiko havasDerivoPriskribon aocomp] && [$vasto trovuKunFunkcio oattr] eq ""} {
                        $kolektilo aliguEraron [self] "uzu nominativon, se la adjektivo priskribas la agon '[$vradiko prenuBazanFormon]'" [my prenuBazanFormonKazoNombro]
                    }
                }
            }
        }
    }
    # Mi vidis lastan libron
    if {[my estasBazajVortoj {sekva lasta antaŭa}]} {
        set radElemento [my miAuxRadikaElemento]
        set rparenco [$radElemento set parenco]
        if {$rparenco ne "" && [$rparenco istype SintaksAsto::np] && ![$rparenco estasDifinita]} {
            $kolektilo aliguEraron [self] "la adjektivo difinas la substativon. Difinilo 'la' estas necesa." [list "la $vorto"]
        }
    }
}
GP::Adjektivo instproc testuKuntekston priskribo {
    set kelemento [my prenuDifinilon]
    if {[lindex $priskribo 0] ne "kun" || $kelemento eq ""} {return 0}
    foreach p [lrange $priskribo 1 end] {
        if {[$kelemento testuSencon $p]} {
            return 1
        }
    }
    return 0
}
@ Class GP::Adverbo {
description {Tipaj adverboj (fun e finajxo)}
}
Class GP::Adverbo -superclass ::GP::Elemento -parameter direkto
@ ::GP::Adverbo idemeta component EspSintaksaAnalizo
GP::Adverbo instproc eblasSuplementoPerDe {} {
    my estasVortoj {akompanate aliaflanke aliflanke ambaŭflanke antaŭtage aparte apude baze dekstre depende detempe ekstere ekzemple ende ene enkadre enmane escepte fare fine flanke fone fronte helpe inde inkluzive interne kadre kaze kaŝe kaŭze komence koste laŭlonge lime maldekstre male malproksime manke meze nedepende nome norde nordoriente okaze oriente pere precipe proksime rande rezulte sekve sendepende sojle spite spure sude supre surbaze transe transflanke ĉeborde ĉeflanke ĉirkaŭe}
}
GP::Adverbo instproc ekkoniFinajxo finajxo {
    if {[string index $finajxo end] eq "n"} {
        my set direkto n
    }
}
GP::Adverbo instproc estasAdvAdv args {
    if {[my istype GP::TabloVorto] || [my istype GP::Numeralo]} {
        next
    } else {
        expr {[lsearch [lindex [my derivolisto] 2] mod]>=0}
    }
}
GP::Adverbo instproc estasCerteco {} {
    # gxuste tute sole (nur) funkcias kiel primitivaj adverboj (ekz. ankaux)
    # tie nur simplifigo
    my havasDerivoPriskribon certeco
}
GP::Adverbo instproc estasDaSubj args {
    my estasVortoj {kelke multe malmulte sufiĉe iomete senfine nemulte}
}
GP::Adverbo instproc estasDirekto {} {
    my instvar direkto
    expr {[my exists direkto] && $direkto eq "n"}
}
GP::Adverbo instproc estasKuneblaj {elem ligilo stupo} {
    set rez [next]
    expr {$rez || [$elem istype SintaksAsto::pp]}
}
GP::Adverbo instproc estasPluralo {} {
    return 1
}
GP::Adverbo instproc estasTempa {} {
    my havasDerivoPriskribon tempo
}
GP::Adverbo instproc estasTranzitivaPartizipo {} {
    if {[my estasPartizipo] && [string first n [my set tempo]]>=0} {
        return 1
    }
    return 0
}
GP::Adverbo instproc prenuSimbolo {} {
    if {[my ismixin [self class]]} {
         return "ADV-[next]"
    } else {
         return ADV
    }
}
GP::Adverbo instproc sxercxiErarojn kolektilo {
    next
    # problemoj kun tempaj adjektoj
    # mi estas frue granda
    my instvar parenco radiko vorto
    set defElemento [my miAuxRadikaElemento]
    if {[my estasUnuaGrandSkribita] && ![my estasEblaNomo] && [my estasUnuaElementoEnFrazo]} {
        if {![my estasNekonata]} {
            $kolektilo aliguEraron [self] "oni skribas adverbojn minuskle" [string tolower $vorto]
        }
    }
    set kparenco [$defElemento set parenco]
    if {![my estasTempa] && ![my estasCerteco] && $vorto ni {hejme} && ![my hasclass GP::TabloVorto] && $kparenco ne "" && [$kparenco istype SintaksAsto::main] && !([$defElemento istype SintaksAsto::advsup] && [$defElemento eblasKielSubstantivo])} {
        set verbo [$kparenco prenuNeInfVerbo]
        set subj [$kparenco prenuSubjekton]
        set sekva [my prenuSekvaElemento]
        if {$sekva ne "" && [$sekva istype GP::Adjektivo]} {
            return
        }
        if {$subj ne "" && $verbo ne "" && [$verbo estasEst]} {
            set indekso [lsearch [$kparenco set astoj] $defElemento]
            if {$indekso>0 && [lsearch [$kparenco set astoj] $verbo]+1==$indekso} {
                # problemo kun tempaj adjektoj
                # Mi estas frue tre granda.
                set subjr [$subj prenuRadiko]
                if {[$subjr hasclass GP::NombroKazo]} {
                    $kolektilo aliguEraron [self] "nur adjektivoj povas priskribi subjekton" [esp::prenuKazoNombro [string range $vorto 0 end-1]a  0 [$subjr estasPluralo]]
                }
            }
        }
    }
}
GP::Adverbo instproc testuKuntekston priskribo {
    my instvar parenco
    set tipo [lindex $priskribo 0]
    if {$tipo ni {kun kunadj kunadv kunpp}} {return 0}
    set pelem [my selektu parenco]
    if {$tipo eq "kunpp"} {
        foreach p [lrange $priskribo 1 end] {
            if {[my selektuVero [list parenco {filtruVeron istype SintaksAsto::advsup} 1 {filtruVeron istype SintaksAsto::pp} [list filtruVeron estasPrepozicio $p]]]} {
                return 1
            }
        }
        return 0
    }

    if {$pelem ne "" && ([$pelem istype SintaksAsto::adjp] || [$pelem istype SintaksAsto::advp])} {
        if {$tipo eq "kunadj" || $tipo eq "kunadv"} {
            foreach p [lrange $priskribo 1 end] {
                if {[[$pelem prenuRadiko] testuSencon $p]} {
                    return 1
                }
            }
        }
    } else {
        if {$tipo eq "kun"} {
            set kelemento [my selektu {trovuMainVerboAston prenuRadiko}]
            if {$kelemento ne ""} {
                foreach p [lrange $priskribo 1 end] {
                    if {[$kelemento testuSencon $p]} {
                        return 1
                    }
                }
            }
        }
    }
    return 0
}
GP::Adverbo proc estasSpecialaAdverbo {} {
    return 0
}
Class GP::PrimitivaElemento -superclass ::GP::Elemento
@ ::GP::PrimitivaElemento idemeta component EspSintaksaAnalizo
GP::PrimitivaElemento instproc havasDerivoPriskribon pri {
    return 0
}
@ Class GP::Difinilo {
description {Definiloj: la ambaux}
}
Class GP::Difinilo -superclass ::GP::PrimitivaElemento
@ ::GP::Difinilo idemeta component EspSintaksaAnalizo
GP::Difinilo instproc prenuSimbolo {} {
    return DET
}
GP::Difinilo instproc sxercxiErarojn kolektilo {
    my instvar parenco
    if {[my estasVorto ambaŭ]} {
        if {[$parenco hasclass SintaksAsto::np] && [[set nprad [$parenco prenuRadiko]] hasclass GP::NombroKazo] && ![$nprad estasPluralo]} {
            lassign [$parenco prenuFrazpartoKazoNombro [$nprad estasAkuzativo] 1] k f prop
            if {$k ne ""} {
                $kolektilo aliguEraron [list $k $f] "vorteto 'ambaŭ' postulas pluralon" [list $prop]
            }
        }
    }

}
@ Class GP::Frazo {
description {Ejo por sintaksa analizo de frazoj kaj parenco de cxiuj elementoj de sintaksa asto}
}
Class GP::Frazo -parameter {elementoj sintaksoarbo}
@ ::GP::Frazo idemeta component EspSintaksaAnalizo
GP::Frazo instproc aliguKonstanto {vorto {arto konstanto} {komenco 0} {fino 0}} {
    my lappend elementoj [GP::Konstanto new -childof [self] [list -vorto $vorto] [list -arto konstanto] [list -komenco $komenco] [list -fino $fino]]
}
GP::Frazo instproc aliguNekonatan {tvorto komenco fino} {
    my instvar elementoj havasNekonataj
    set vorto [string tolower $tvorto]
    if {![esp::enhavasEsparantajLiteroj $vorto]} {
        my aliguTypo Nekonata $tvorto $komenco $fino
        return
    }
    if {[regexp {^(.+o)(j?n?)$} $vorto _ bazo finajxo]} {
         set elem [GP::Substantivo new -childof [self] [list -vorto $tvorto] [list -komenco $komenco] [list -fino $fino] -mixin GP::NekonataMix]
         $elem ekkoniFinajxo $finajxo
         $elem set derivolisto {}
         $elem set radiko Radiko::bon
         $elem set bazaFormo $bazo
         my lappend elementoj $elem
    } elseif {[regexp {^(.+a)(j?n?)$} $vorto _ bazo finajxo]} {
         set elem [GP::Adjektivo new -childof [self] [list -vorto $tvorto] [list -komenco $komenco] [list -fino $fino] -mixin GP::NekonataMix]
         $elem ekkoniFinajxo $finajxo
         $elem set derivolisto {}
         $elem set radiko Radiko::dom
         $elem set bazaFormo $bazo
         my lappend elementoj $elem
    } elseif {[regexp {^(.+)(i|[oua]s|u)$} $vorto _ bazo finajxo]} {
         set elem [GP::Verbo new -childof [self] [list -vorto $tvorto] [list -komenco $komenco] [list -fino $fino] -mixin GP::NekonataMix]
         $elem ekkoniFinajxo $finajxo
         $elem set radiko Radiko::dorm
         $elem set derivolisto {}
         $elem set bazaFormo ${bazo}i
         my lappend elementoj $elem
    } elseif {[regexp {^(.+e)$} $vorto _ bazo]} {
         set elem [GP::Adverbo new -childof [self] [list -vorto $tvorto] [list -komenco $komenco] [list -fino $fino] -mixin GP::NekonataMix]
         $elem ekkoniFinajxo ""
         $elem set derivolisto {}
         $elem set radiko Radiko::rapid
         $elem set bazaFormo $bazo
         my lappend elementoj $elem
    } else {
        my aliguTypo Nekonata $tvorto $komenco $fino
    }
}
@ GP::Frazo instproc aliguTestuVorto {} {
description {Resultoj
0 - radiko ne trovita
1 - trovita sed sen derivo
2 - trovita kun derivo
3 - ignorvorto
4 - simbolo
5 - konstanto
}
}
GP::Frazo instproc aliguTestuVorto {vortaro tvorto {komenco 0} {fino 0}} {
    my instvar elementoj havasNekonataj
    set tvorto [my transVorto $tvorto]
    set vorto [string tolower $tvorto]
    if {[string is punct $vorto]} {
        if {$vorto eq "%"} {
            lappend elementoj [::GP::Substantivo new -childof [self] [list -vorto $vorto] [list -komenco $komenco] [list -fino $fino] -radiko Radiko::procent -derivolisto [list {} o] -kazo nominativo -nombro pluralo]
            set rez 2
        } else {
            my aliguTypo Simbolo $tvorto $komenco $fino
            set rez 4
         }
    } elseif {[string index $vorto end] eq "."} {
        my aliguKonstanto $tvorto mallongigo $komenco $fino
        set rez 4
    } elseif {[llength $tvorto]>1} {
        # aux - speciala du elementa vorto {nomo Artur}
        my aliguKonstanto [lrange $tvorto 1 end] [lindex $tvorto 0] $komenco $fino
        set rez 4
    } elseif {[regexp {^[A-ZŜĈĜĴĤ]{1,5}(\-o?j?n?)?$} $tvorto]} {
        # ebla akronimo - ILEI, UEA, KD, ...
        # ankaux KD-oj KD-on
        my aliguKonstanto $tvorto akronimo $komenco $fino
        set rez 4
    } elseif {[regexp {^([\d.]+)-?(aj?n?)$} $vorto _ nombro vortktg]} {
        set num [my aliguTypo Numeralo $tvorto $komenco $fino]
        $num set veraNombro $nombro
        $num estuAdjektiva
        $num ekkoniFinajxo $vortktg
        set rez 2
    } elseif {[string first - $tvorto]>0} {
        set rez [$vortaro estasVorto $vorto]
        if {$rez==2 || $rez==1} {
            set elem [$vortaro prenuGramElemento [self] $tvorto]
            $elem komenco $komenco
            $elem fino $fino
            $elem vorto $tvorto
            lappend elementoj $elem
        }  else {
            set lvorto [lindex [split $vorto -] end]
            set rez [$vortaro estasVorto $lvorto]
            # TODO nur la dua parto estas konata la unua ne
            if {$rez==2 && [lsearch {a aj ajn an} $lvorto]<0 && ![$vortaro estasPrimitivaVorto]} {
                set elem [$vortaro prenuGramElemento [self] $vorto]
                $elem komenco $komenco
                $elem fino $fino
                $elem vorto $tvorto
                lappend elementoj $elem
            } else {
                set havasNekonataj 1
                #my aliguTypo Nekonata $tvorto $komenco $fino
                my aliguNekonatan $tvorto $komenco $fino
            }
        }
    } else {
        if {[string is upper [string index $tvorto 0]] && ([Vortaro estasViraNomo $vorto] || [Vortaro estasVirinaNomo $vorto])} {
            my aliguKonstanto $tvorto anomo $komenco $fino
            set rez 3
        } else {
            set rez [$vortaro estasVorto $vorto]
            switch $rez {
                2 {
                    set elem [$vortaro prenuGramElemento [self] $tvorto]
                    $elem komenco $komenco
                    $elem fino $fino
                    lappend elementoj $elem
                }
                3 {
                    my aliguKonstanto $tvorto ignorvorto $komenco $fino
                }
                4 {
                    my aliguTypo Numeralo $tvorto $komenco $fino
                }
                1 {
                    my set havasNekonataj 1
                    set elem [$vortaro prenuGramElemento [self] $tvorto]
                    $elem aliguMerkmalon nekonataDerivo
                    $elem komenco $komenco
                    $elem fino $fino
                    lappend elementoj $elem
                }
                default {
                    set havasNekonataj 1
                    my aliguNekonatan $tvorto $komenco $fino
                }
            }
        }
    }
    return $rez
}
GP::Frazo instproc aliguTypo {typo vorto {komenco 0} {fino 0}} {
    set typo [GP::$typo new -childof [self] [list -vorto $vorto] [list -komenco $komenco] [list -fino $fino]]
    my lappend elementoj $typo
    return $typo
}
GP::Frazo instproc aliguVorto {vorto rez vortaro} {
    my instvar elementoj
    if {[string length $vorto]==1 && [string is punct $vorto]} {
        lappend elementoj [::GP::Simbolo new -childof [self] [list -vorto $vorto]]
    } else {
        if {$rez==2} {
            lappend elementoj [$vortaro prenuGramElemento [self] $vorto]
        } else {
            lappend elementoj [::GP::Nekonata new -childof [self] [list -vorto $vorto]]
        }
    }
}
GP::Frazo instproc asDOM doc {
    set elem [$doc createElement frazo]
    if {[my exists sintaksoarbo]} {
        set tekstoNode [$doc createElement teksto]
        $tekstoNode appendChild [$doc createTextNode [my prenuTeksto]]
        $elem appendChild $tekstoNode
        set sintakso [$doc createElement sintakso]
        $elem appendChild $sintakso
        foreach e [my sintaksoarbo] {
            $sintakso appendChild [$e asDOM $doc]
        }
    } else {
        foreach e [my elementoj] {
            $elem appendChild [$e asDOM $doc]
        }
    }
    return $elem
}
GP::Frazo instproc asXML {} {
    set docu [dom createDocument frazoj]
    set elem [my asDOM $docu]
    [$docu documentElement] appendChild $elem
    set text [$elem asXML]
    $docu delete
    return $text
}
GP::Frazo instproc drawGraph {} {
    [my set sintaksoarbo] drawGraph
}
GP::Frazo instproc havasNekonataj {} {
    my instvar havasNekonataj
    expr {[info exists havasNekonataj] && $havasNekonataj}
}
GP::Frazo instproc init args {
    next
    my instvar transArr
    array set transArr {dank' danke l' la s-ro sinjoro s-ino sinjorino s-inon sinjorinon s-rino sinjorino s-ron sinjoron s-rinon sinjorinon s-roj sinjoroj e-o Esperanto e-on Esperanton n-ro numero n-ron numeron d-ro doktro d-ron doktoron}
}
GP::Frazo instproc leguFrazon {vortaro frazo} {
    set elem [list]
    set i 0
    foreach vorto $frazo {
        my aliguTestuVorto $vortaro $vorto $i $i
        incr i
    }
}
GP::Frazo instproc leguFrazonPerLegilo {vortaro frazo} {
    set legilo [FrazoLegilo newOn $frazo]
    $legilo komencuFrazon
    for {set vorto [$legilo prenuSVorton]} {$vorto ne ""} {set vorto [$legilo prenuSVorton]} {
        set komenco [[$legilo signoLegilo] vortkomenco]
        set fino [[$legilo signoLegilo] kursoro]
        my aliguTestuVorto $vortaro $vorto $komenco $fino

    }
    $legilo destroy
}
GP::Frazo instproc prenuListon {} {
    if {[my exists sintaksoarbo]} {
        [my sintaksoarbo] prenuListon
    } else {
        return
    }
}
GP::Frazo instproc prenuSimboloj {} {
    set ret [list]
    foreach e [my elementoj] {
        lappend ret [$e prenuSimbolo]
    }
    return $ret
}
GP::Frazo instproc prenuTeksto {} {
    set teksto ""
    if {[my exists elementoj]} {
        foreach e [my elementoj] {
            set vorto [$e vorto]
            append teksto [esp::prenuSeparatilon $vorto]
            append teksto $vorto
        }
    }
    return $teksto
}
GP::Frazo instproc transVorto vorto {
    my instvar transArr
    set tvorto [string map {’ ' — -} [string tolower $vorto]]
    if {[info exists transArr($tvorto)]} {
        if {$tvorto eq $vorto} {
            return $transArr($tvorto)
        } else {
            return [esp::grandskribi $transArr($tvorto)]
        }
    } else {
        return $vorto
    }
}
@ Class GP::Partikolo {
description {Baza klaso por cxiuj vortetoj}
}
Class GP::Partikolo -superclass ::GP::PrimitivaElemento
@ ::GP::Partikolo idemeta component EspSintaksaAnalizo
@ Class GP::Konjunkcio {
description {Konjunkcioj: kaj aux nek ...
Ankaux konjukcioj de subfrazoj: ke cxe ...}
}
Class GP::Konjunkcio -superclass ::GP::Partikolo
@ ::GP::Konjunkcio idemeta component EspSintaksaAnalizo
GP::Konjunkcio instproc estasCertaSubfrazo {} {
   expr {[lsearch {kaj ke ĉu ĉar se sed dum ĝis} [string tolower [my vorto]]]>=0}
}
GP::Konjunkcio instproc estasDuobla {} {
    expr {[lsearch {aŭ kaj nek} [string tolower [my vorto]]]>=0}
}
GP::Konjunkcio instproc estasSimetria {} {
    expr {[lsearch {aŭ plus kaj minus sed} [string tolower [my vorto]]]>=0}
}
GP::Konjunkcio instproc prenuSimbolo {} {
    return CONJ
}
@ Class GP::Interjekcio {
description {Mi false nomigis la klason.
La klaso signifas frazenkondukiloj: kvazaŭ, kvankam, ĉu, ke, ĉar, se
Rimarku ke ''gxis'' kaj ''dum'' povos esti kaj frazenkondukiloj kaj prepozicioj}
}
Class GP::Interjekcio -superclass ::GP::Konjunkcio
@ ::GP::Interjekcio idemeta component EspSintaksaAnalizo
GP::Interjekcio instproc estasCertaSubfrazo {} {
    return 1
}
GP::Interjekcio instproc prenuSimbolo {} {
    return INT
}
GP::Interjekcio instproc sxercxiErarojn kolektilo {
    #if {[my estasVorto ke]} {
        #set ae [my prenuAntauxElemento]
        #if {$ae ne "" && ![$ae estasVorto ,]} {
            #if {![$ae estasVortoj {por por sen krom anstataŭ malgraŭ}]} {
                #$kolektilo aliguEraron [self] "skribu ',' antaŭ 'ke'"
            #} else {
                #set aae [$ae prenuAntauxElemento]
                #if {$aae ne "" && ![$aae estasVorto ,]} {
                    #$kolektilo aliguEraron $aae "skribu ',' antaŭ '[$ae vorto] ke'"
                #}
            #}
        #}
    #}
}
Class GP::KVerboMix
@ ::GP::KVerboMix idemeta component EspSintaksaAnalizo
@ Class GP::Konstanto {
description {Aux vortoj kiuj ne estas rekonataj kiel esperantaj sed sxajnas esti propraj nomoj aux propraj nomoj}
}
Class GP::Konstanto -superclass ::GP::Elemento -parameter arto
@ ::GP::Konstanto idemeta component EspSintaksaAnalizo
GP::Konstanto instproc prenuBazanFormon {} {
    my prenuVorton
}
GP::Konstanto instproc prenuKazon {} {
    return nominativo
}
GP::Konstanto instproc prenuSimbolo {} {
    return CONST
}
GP::Konstanto instproc printString {} {
    return "[my prenuNomo]: [my vorto]"
}
@ Class GP::Nekonata {
description {Nekonataj vortoj}
}
Class GP::Nekonata -superclass ::GP::Elemento
@ ::GP::Nekonata idemeta component EspSintaksaAnalizo
GP::Nekonata instproc prenuSimbolo {} {
    return NULL
}
GP::Nekonata instproc printString {} {
    return "[my prenuNomo]: [my vorto]"
}
@ Class GP::NekonataMix {
description {Tiu klaso estas uzato por vortoj, kiu aspektas kiel
adjektivoj, substativoj, verboj aux adverboj sen ne ekzistas en vortaro.}
}
Class GP::NekonataMix
@ ::GP::NekonataMix idemeta component EspSintaksaAnalizo
GP::NekonataMix instproc prenuBazanFormon {} {
    my set bazaFormo
}
@ Class GP::Numeralo {
description {cxiuj numeraloj (sed ne kiom, iom) - numeraj povas samtempe enhavi dinamike klasoj: adjektivo, substantivo, adverbo}
}
Class GP::Numeralo -superclass ::GP::Partikolo
@ ::GP::Numeralo idemeta component EspSintaksaAnalizo
GP::Numeralo instproc estasAdjVeraNombro {} {
    my instvar vorto veraNombro
    expr {[info exists veraNombro] && [regexp {\d+\-?(a|an|aj|ajn)} $vorto]}
}
GP::Numeralo instproc estasAdjektiva {} {
    expr {[my hasclass ::GP::Adjektivo]}
}
GP::Numeralo instproc estasAdjektivaGrandskribita {} {
    expr {[my hasclass ::GP::Adjektivo] && [my estasUnuaGrandSkribita]}
}
GP::Numeralo instproc estasAdvAdv {} {
    my instvar arto
    expr {$arto eq "on" || $arto eq "obl"}
}
GP::Numeralo instproc estasJaroNumero {} {
    my instvar veraNombro
    expr {[my estasNurNumero] && [info exists veraNombro] && $veraNombro>1000 && $veraNombro<9999}
}
GP::Numeralo instproc estasLaAdjektiva {} {
    expr {[my estasSubstantiva] && [my havasMerkmalon estisAdjektiva]}
}
GP::Numeralo instproc estasNeSubstantiva {} {
    expr {![my hasclass GP::Substantivo]}
}
GP::Numeralo instproc estasNeVorto {} {
    my instvar vorto veraNombro
    # la metodo testas cxu vorto estas vera vorta nombro
    # dek unu tri tria ...
    # kelkdek estas nevorto
    expr {[info exists veraNombro] && ($vorto eq $veraNombro || [string map {. ""} $vorto] eq $veraNombro || $veraNombro eq "?")}
}
GP::Numeralo instproc estasNurNumero {} {
    expr {![my hasclass GP::NombroKazo] && ![my hasclass GP::Adverbo]}
}
GP::Numeralo instproc estasOnoj {} {
    my instvar arto
    expr {$arto eq "on" && [my hasclass GP::Substantivo]}
}
GP::Numeralo instproc estasSubstantiva {} {
    expr {[my hasclass ::GP::Substantivo]}
}
GP::Numeralo instproc estuAdjektiva {} {
    if {![my ismixin ::GP::Adjektivo]} {
        if {[my ismixin ::GP::Substantivo]} {
            my mixin delete ::GP::Substantivo
        }
        if {[my ismixin ::GP::NombroKazo]} {
            my mixin delete ::GP::NombroKazo
        }
        my mixin add ::GP::Adjektivo
    }
}
GP::Numeralo instproc estuAdverba {} {
    my mixin add ::GP::Adverbo
}
GP::Numeralo instproc estuSubstantiva {} {
    if {[my estasAdjektiva]} {
        my aliguMerkmalon estisAdjektiva
    }
    if {![my ismixin ::GP::Substantivo]} {
        if {[my ismixin ::GP::Adjektivo]} {
            my mixin delete ::GP::Adjektivo
        }
        if {[my ismixin ::GP::NombroKazo]} {
            my mixin delete ::GP::NombroKazo
        }
        my mixin add ::GP::Substantivo
    }
}
GP::Numeralo instproc init args {
    my instvar vorto arto veraNombro
    if {[info exists vorto]} {
        if {[string is double $vorto]} {
            # cxu nombro lau 2.000
            if {[regexp {\.[0-9]{3}$} $vorto]} {
                set veraNombro [string map {. ""} $vorto]
            } else {
                set veraNombro $vorto
            }
        }
    }
    set arto ""
}
GP::Numeralo instproc prenuBazanFormon {} {
    EORadikilo radikigi [my prenuVorton]
}
GP::Numeralo instproc prenuNumeron {} {
    my instvar veraNombro
    if {[info exists veraNombro]} {
        return $veraNombro
    }
    GP::Numeralo leguKunligitaNombro [my prenuVorton]
}
GP::Numeralo instproc prenuSimbolo {} {
    return NUN
}
GP::Numeralo instproc printString {} {
    if {[my exists radiko]} {
        next
    } else {
        return "[my prenuNomo]: [my vorto]"
    }
}
GP::Numeralo instproc rekoni {} {
    my instvar arto vorto
    set tvorto $vorto
    set arto ""
    foreach f {ajn aj an onj oj o a e} {
        set l [string length $f]
        set ln [expr {$l-1}]
        if {[string range $tvorto end-$ln end] eq $f} {
            set tvorto [string range $vorto 0 end-$l]
            break
        }
    }
    foreach f {obl op on} {
        set l [string length $f]
        incr l -1
        if {[string range $tvorto end-$l end] eq $f} {
            set arto $f
            return
        }
    }
    return
}
GP::Numeralo instproc sxercxiErarojn kolektilo {
    my instvar arto veraNombro parenco vorto
    if {[my hasclass GP::Substantivo]} {

    } elseif {[my hasclass GP::Adjektivo]} {
        set radElemento [my miAuxRadikaElemento]
        set rparenco [$radElemento set parenco]
        if {$rparenco ne "" && [$rparenco istype SintaksAsto::np] && $arto eq "" && ![$rparenco estasDifinita]} {
            $kolektilo aliguEraron [self] "adjektiva numeralo bezonas difinilon 'la'" [list "la $vorto"]
        }
    } elseif {[my hasclass GP::Adverbo]} {
        if {$arto eq ""} {

        }
    } else {
        if {$parenco ne "" && [$parenco istype SintaksAsto::np] && $arto eq "" && [info exists veraNombro]} {
            if {$veraNombro==1 || $veraNombro==0} {
                set prad [$parenco prenuRadiko]
                if {$prad ne "" && [$prad hasclass GP::NombroKazo]} {
                    if {[$prad prenuNombron] ne "singularo"} {
                        $kolektilo aliguEraron $prad "atendas singularon post 1" [esp::prenuKazoNombro [$prad prenuBazanFormon] [$prad estasAkuzativo] 0]
                    }
                }
            } else {
                set prad [$parenco prenuRadiko]
                if {$prad ne "" && [$prad hasclass GP::NombroKazo]} {
                    if {[$prad prenuNombron] ne "pluralo"} {
                        $kolektilo aliguEraron $prad "atendas pluralon post '$veraNombro'" [esp::prenuKazoNombro [$prad prenuBazanFormon] [$prad estasAkuzativo] 1]
                    }
                }
            }
        }
    }
}
GP::Numeralo proc leguKunligitaNombro espNombro {
    set fortrancxu {opa opan opaj opajn ope oble obla oblan oblaj obajn ono ona one onan onaj onajn onoj onojn a an aj ajn e o}
    regsub {^(.+)j?n?$} $espNombro {\1} espNombro
    if {$espNombro ni {miliono miliardo biliono kvadriliono}} {
        foreach f $fortrancxu {
            set len [string length $f]
            if {[string range $espNombro end-[expr {$len-1}] end] eq $f} {
                set espNombro [string range $espNombro 0 end-$len]
                break
            }
        }
    }
    my leguNombro [split $espNombro "- "]
}
GP::Numeralo proc leguNombro nombroListo {
    if {[llength $nombroListo]==0} {
        error "malplena cxeno"
    }
    array set nombroj {
        nul 0
        unu 1
        du 2
        tri 3
        kvar 4
        kvin 5
        ses 6
        sep 7
        ok 8
        naŭ 9
        dek 10
        cent 100
        mil 1000
        miliono 1000000
        miliardo    1000000000
        biliono     1000000000000
        kvadriliono 1000000000000000
        milion 1000000
        miliard    1000000000
        bilion     1000000000000
        kvadrilion 1000000000000000
    }
    #    miliono     1000000
    #    miliardo    1000000000
    #    biliono     1000000000000
    #    kvadriliono 1000000000000000
    set rez 0
    foreach nombro $nombroListo {
        if {$nombro eq "mil"} {
            if {$rez == 0} {
                set rez 1000
            } else {
                set rez [expr {1000*$rez}]
            }
        } elseif {[info exists nombroj($nombro)]} {
            incr rez $nombroj($nombro)
        } elseif {[string range $nombro end-2 end] eq "dek"} {
            set kom [string range $nombro 0 end-3]
            if {[info exists nombroj($kom)]} {
                incr rez [expr {$nombroj($kom)*10}]
            } else {
                error "$nombro elemento ne konata"
            }
        } elseif {[string range $nombro end-3 end] eq "cent"} {
            set kom [string range $nombro 0 end-4]
            if {[info exists nombroj($kom)]} {
                incr rez [expr {$nombroj($kom)*100}]
            } else {
                error "$nombro elemento ne konata"
            }
        } else {
            error "$nombro elemento ne konata"
        }
    }
    return $rez
}
Class GP::Onomatopeo -superclass ::GP::Partikolo
@ ::GP::Onomatopeo idemeta component EspSintaksaAnalizo
GP::Onomatopeo instproc prenuSimbolo {} {
    return "ONO"
}
@ Class GP::Partizipo {
description {Tio klaso estas uzata dinamike kiel mixin}
}
Class GP::Partizipo -parameter tempo
@ ::GP::Partizipo idemeta component EspSintaksaAnalizo
GP::Partizipo instproc appendDOM dom {
    next
    $dom setAttribute partizipo [my tempo]
}
GP::Partizipo instproc eblasObjekto {} {
    my instvar derivolisto radiko vorto
    if {[string range [lindex $derivolisto 1] end-2 end] eq "igi"
        || [string range [lindex $derivolisto 1] end-4 end] eq "igadi"
        || "trans" in [lindex $derivolisto 2]
        || [lindex $derivolisto 0] eq "pri"} {
        return 1
    }
    if {[lindex $derivolisto 1] in {adi igi eti egi i} || [lindex $derivolisto 0] eq "ne"} {
        set ndl [$radiko sxercxuDerivonPS {} i]
        if {[lsearch -exact [lindex $ndl 2] trans]>=0} {
            return 1
        }
    }
    return 0
}
GP::Partizipo instproc ekkoniTempo finajxo {
    my instvar tempo
    set tempo $finajxo
    if {[my istype GP::Adjektivo]} {
        append tempo a
    } elseif {[my istype GP::Adverbo]} {
        append tempo e
    } elseif {[my istype GP::Substantivo]} {
        append tempo o
    }
}
GP::Partizipo instproc estasAdvAdv args {
    # problemo kun "vidante"
    # cxar gxi havas priskribon "mod" sed tiu priskribo ne estas AdvAdv sed temas pri priskribo de verbo
    # do nun ne ekzistas participoj kun "advadv"
    return 0
}
GP::Partizipo instproc estasAktiva {} {
    expr {[string first n [my set tempo]]>0}
}
GP::Partizipo instproc estasPasiva {} {
    expr {[string first n [my set tempo]]<0}
}
GP::Partizipo instproc prenuBazanFormonKazoNombro {} {
    my prenuParticipanBazanFormon
}
GP::Partizipo instproc prenuGramatikeAnalogan vorto {
    my instvar tempo kazo nombro
    regexp {^(.+)i$} $vorto _ vorto
    append vorto $tempo
    if {[my hasclass GP::Adverbo]} {
        return $vorto
    }
    if {$nombro eq "pluralo"} {
        append vorto j
    }
    if {$kazo eq "akuzativo"} {
        append vorto n
    }
    return $vorto
}
GP::Partizipo instproc prenuParticipanBazanFormon {} {
    my instvar tempo
    return [string range [my prenuBazanFormon] 0 end-1]$tempo
}
GP::Partizipo instproc prenuSimbolo {} {
    return "[next]-PARTZ"
}
GP::Partizipo instproc sxercxiErarojn kolektilo {
    next
    my instvar radiko vorto
    GP::Verbo metuIgVerbojArr tArr
    
    
    if {[my estasPasiva] && ![my eblasObjekto] && ![my hasclass GP::Substantivo] && ![my estasNekonata]} {
        # parolata lingvo
        if {[my prenuBazanFormon] ni "paroli iri pensi kuri"} {
            set korekto vorto
            if {![catch {set tArr([my prenuBazanFormon])} igiFormo]} {
                $kolektilo aliguEraron [self] "uzu la ig-formon ĉe pasiva participo" [my prenuGramatikeAnalogan $igiFormo]
            } else {
                if {![regsub {ta(n|jn|j)?$} $vorto {nta\1} korekto]} {
                    regsub {te?$} $vorto {nte} korekto
                }
                $kolektilo aliguEraron [self] "pasiva participo '$vorto' estas ebla nur ĉe transitivaj verboj" $korekto
            }
        }
    }
}
Class GP::Pronomo -superclass ::GP::PrimitivaElemento
@ ::GP::Pronomo idemeta component EspSintaksaAnalizo
Class GP::Substantivo -superclass {::GP::Elemento ::GP::NombroKazo}
@ ::GP::Substantivo idemeta categories testado
@ ::GP::Substantivo idemeta categoriesMethods {{estasNePronomoKajNeAdo estasIdenteca estasMonato estasTempoAkuzativo estasNeDifinitaPP estasAkuzativo estasPropraNomo estasInaPersono estasNePronomo estasNeDifinitaDekstra estasLongeco estasDistanco estasNeDifinitaNum estasNePronomoNum estasTempo estasLoko estasPersono estasIdentEbla estasNeDifinita estasKuneblaj}}
@ ::GP::Substantivo idemeta component EspSintaksaAnalizo
GP::Substantivo instproc estasAkuzativo {} {
    if {[my hasclass GP::Konstanto] && [my estasVirinaNomo]} {
        return 1
    }
    next
}
GP::Substantivo instproc estasDistanco {} {
    expr {[my estasLongeco] && [my estasAkuzativo]}
}
GP::Substantivo instproc estasIdentEbla {} {
    my instvar derivolisto
    expr {[my estasNePronomo] && ([my havasDerivoPriskribon ident] || ([info exists derivolisto] && [lindex $derivolisto 1] in {ano isto ino istino estro})) && [my estasSingularo]}
}
GP::Substantivo instproc estasIdenteca {} {
    # ekzemple. Sinjoro Artur
    expr {[[my miAuxRadikaElemento] istype SintaksAsto::ident]}
}
GP::Substantivo instproc estasInaPersono {} {
    my instvar vorto derivolisto radiko
    if {[info exists derivolisto]} {
       if {[lsearch {ino} [lindex $derivolisto 1]]>=0} {
           return 1
       }
    }
    return 0
}
GP::Substantivo instproc estasKuneblaj {elem ligilo stupo} {
    if {$stupo<2} {
        return 0
    }
    set radobj [$elem prenuRadiko]
    # gazetoj kaj multe da libroj
    if {[$elem istype SintaksAsto::advsup] && [$elem eblasKielSubstantivo]} {
        return 1
    }
    if {[$elem istype GP::TabloVorto] && [$elem bazo] eq "ki"} {
        return 0
    }
    if {[$radobj hasclass ::GP::Substantivo] && [my kazo] eq [$radobj kazo]} {
       return 1
    }
    return 0
}
GP::Substantivo instproc estasLoko {} {
    my havasDerivoPriskribon loko
}
GP::Substantivo instproc estasLongeco {} {
    my estasBazajVortoj {metro kilometro mejlo centimetro milimetro}
}
GP::Substantivo instproc estasMonato {} {
    my estasBazajVortoj {januaro februaro marto aprilo majo julio junio aŭgusto septembro oktobro novembro decembro}
}
GP::Substantivo instproc estasNeDifinita {radiko kazo} {
    # pruvas cxu substantivo aux frazo povas esti aligita per adjektivo
    # jes - homo, io, granda hundo
    # ne - la homo, li, la malnova hundo
    if {$kazo ne "" && [my kazo] ne $kazo} {
        return 0
    }
    if {[my hasclass GP::Substantivo] && ![my istype GP::Pronomo]} {
        if {$radiko eq [self]} {
            return 1
        } elseif {([$radiko istype SintaksAsto::np] && [$radiko estasNeDifinita]) || [$radiko istype SintaksAsto::grupo] || [$radiko istype SintaksAsto::ident] || [$radiko istype SintaksAsto::ignor]} {
            return 1
        } elseif {[$radiko istype SintaksAsto::konj] || [$radiko istype SintaksAsto::disk]} {
            set kradiko [$radiko radiko]
            if {$kradiko eq [self] || ([$kradiko istype SintaksAsto::np] && [$kradiko estasNeDifinita])} {
                return 1
            }
        }
        return 0
    }
    return 0
}
GP::Substantivo instproc estasNeDifinitaDekstra {radiko kazo} {
    # pruvas cxu substantivo aux frazo povas esti aligita per adjektivo
    # jes - homo, io, granda hundo
    # ne - la homo, li, la malnova hundo
    if {[my kazo] ne $kazo} {
        return 0
    }
    if {[my hasclass GP::Substantivo] && ![my istype GP::Pronomo]} {
        if {$radiko eq [self]} {
            return 1
        } elseif {([$radiko istype SintaksAsto::np] && [$radiko estasNeDifinitaDekstra]) || [$radiko istype SintaksAsto::grupo] || [$radiko istype SintaksAsto::ident] || [$radiko istype SintaksAsto::ignor]} {
            return 1
        } elseif {[$radiko istype SintaksAsto::konj] || [$radiko istype SintaksAsto::disk]} {
            set kradiko [$radiko radiko]
            if {$kradiko eq [self] || ([$kradiko istype SintaksAsto::np] && [$kradiko estasNeDifinitaDekstra])} {
                return 1
            }
        }
        return 0
    }
    return 0
}
GP::Substantivo instproc estasNeDifinitaNum {radiko kazo} {
    my estasNeDifinita $radiko $kazo
}
GP::Substantivo instproc estasNeDifinitaPP radiko {
    if {[my istype GP::Substantivo] && [my estasNePronomo]} {
        if {$radiko eq [self]} {
            return 1
        } elseif {([$radiko istype SintaksAsto::np] && [$radiko estasNeDifinitaPP]) || [$radiko istype SintaksAsto::grupo]} {
            return 1
        } elseif {[$radiko istype SintaksAsto::konj] || [$radiko istype SintaksAsto::disk]} {
            set kradiko [$radiko radiko]
            if {$kradiko eq [self] || ([$kradiko istype SintaksAsto::np] && [$kradiko estasNeDifinitaPP])} {
                return 1
            }
        }
        return 0
    }
    return 0
}
GP::Substantivo instproc estasNePronomo {} {
    expr {[my istype GP::Substantivo] || [my istype GP::Konstanto] || [my istype GP::Numeralo]}
}
GP::Substantivo instproc estasNePronomoKajNeAdo {} {
    my instvar derivolisto
    expr {[my estasNePronomo] && ([info exists derivolisto] && [lindex $derivolisto 1] ne "ado")}
}
GP::Substantivo instproc estasNePronomoNum {} {
    my estasNePronomo
}
GP::Substantivo instproc estasPersono {} {
    my instvar vorto derivolisto radiko
    if {[info exists derivolisto]} {
       if {[lsearch {isto ano ino} [lindex $derivolisto 1]]>=0} {
           return 1
       }
       if {[lindex $derivolisto 1] eq "o" && [info exists radiko] && [$radiko ekzistasDerivo {} ino]} {
           return 1
       }
       if {[my estasBazajVortoj {persono homo alia}]} {
           return 1
       }
    }
    return 0
}
GP::Substantivo instproc estasPropraNomo {} {
    my instvar radiko
    # substantivo estas nur mixin
    if {[my istype GP::PrimitivaElemento]} {
        return 0
    }
    if {[info exists radiko] && [$radiko istype Propranono] || [my havasDerivoPriskribon  pnomo]} {
        return 1
    }
    return 0
}
GP::Substantivo instproc estasTempo {} {
    my havasDerivoPriskribon tempo
}
GP::Substantivo instproc estasTempoAkuzativo {} {
    expr {[my estasTempo] && [my estasAkuzativo]}
}
GP::Substantivo instproc prenuPersonon {} {
    return 3
}
GP::Substantivo instproc prenuSimbolo {} {
    if {[my ismixin [self class]]} {
         return "S-[next]"
    } else {
         return S
    }
}
GP::Substantivo instproc prenuSubsupRadiko {} {
    my instvar parenco
    if {$parenco ne "" && [$parenco istype SintaksAsto::pp]} {
        $parenco prenuSubsupRadiko
    } else {
        next
    }
}
GP::Substantivo instproc senDifinilo {} {
    set bazaFormo [my prenuBazanFormon]
    expr {[my estasPropraNomo] || [string range $bazaFormo end-2 end] eq "aro" || [string range $bazaFormo end-2 end] eq "eco" || [my estasIdenteca]}
}
GP::Substantivo instproc sxercxiErarojn kolektilo {
    next
    my instvar radiko vorto derivolisto
    if {![my estasNekonata] && [my estasPropraNomo] && ![string is upper [string index $vorto 0]]} {
        $kolektilo aliguEraron [self] "propraj nomoj devas esti grandskribitaj" [esp::grandskribi $vorto]
    }
    set defElemento [my miAuxRadikaElemento]
    set kparenco [$defElemento set parenco]
    if {$kparenco ne "" && [$kparenco istype SintaksAsto::main] && [$defElemento set funkcio] eq "comp"} {
        set subj [$kparenco prenuSubjekton]
        if {$subj ne ""} {
            set kazo [my prenuKazon]
            set nombro [$subj prenuNombron]
            # TODO: Li estas mensogisto(j) kaj malbonulo
            if {[$defElemento istype SintaksAsto::konj]} {
                $defElemento sxercxiErarojnNombreco $kolektilo $nombro $kazo]
            } else {
                if {[$defElemento prenuNombron] ne $nombro && ![$defElemento istype SintaksAsto::konj] && ![[$defElemento prenuRadiko] estasBazajVortoj {problemo solvo rezulto atuto ekzemplo kategorio paro}] && ![[$subj prenuRadiko] estasBazajVortoj {tio ekzemplo kategorio}]} {
                    set br [my miAuxRadikaElemento]
                    if {[$br istype SintaksAsto::np]} {
                        foreach {k f prop} [$br prenuFrazpartoKazoNombro 0 [expr {$nombro eq "pluralo"}]] {}
                        if {$k ne ""} {
                            $kolektilo aliguEraron [list $k $f] "nombro de substantiva priskribo kaj substantivo ne estas la sama" [list $prop]
                        }
                    } else {
                        $kolektilo aliguEraron [self] "nombro de substantiva priskribo kaj substantivo ne estas la sama" [esp::prenuKazoNombro [my prenuBazanFormon] 0 [expr {$nombro eq "pluralo"}]]
                    }
                }
            }
            # Sxi estas auxtoro -> Sxi estas auxtorino
            if {[$subj istype GP::PersonPronomo] && $nombro eq "singularo" && [$subj prenuPersonon] eq "3" && [info exists derivolisto]} {
                set bvorto [my prenuBazanFormon]
                if {[$subj prenuBazanFormon] eq "ŝi" && ![regexp {^.+ino$} $bvorto] && [$radiko ekzistasDerivo [lindex $derivolisto 0] [string range [lindex $derivolisto 1] 0 end-1]ino]} {
                    $kolektilo aliguEraron [self] "ina formo de substanitvo ekzistas" [string range $bvorto 0 end-1]ino
                } elseif {[$subj prenuBazanFormon] eq "li" && [regexp {^.+ino$} $bvorto] && [$radiko ekzistasDerivo [lindex $derivolisto 0] [string range [lindex $derivolisto 1] 0 end-3]o]} {
                    $kolektilo aliguEraron [self] "vira formo de substanitvo ekzistas" [string range $bvorto 0 end-3]o
                }
            }
        }
    }
    # En somero estas tre varme tie. (En la somero)
    # En frua somero estas tre varme tie
    if {[my havasDerivoPriskribon dif]} {
        if {$defElemento ne "" && [$defElemento istype SintaksAsto::np] && ![$defElemento estasDifinita]} {
            set dunua [$defElemento prenuUnuan]
            $kolektilo aliguEraron $dunua "la vorto '$vorto' bezonas difinilon." [list "la [$dunua vorto]"]
        } elseif {$defElemento eq [self]} {
            $kolektilo aliguEraron [self] "la vorto '$vorto' bezonas difinilon." [list "la $vorto"]
        }
    }
    # mi vizitis la Varsovion.
    if {[my havasDerivoPriskribon pnomo]} {
        if {$defElemento ne "" && [$defElemento istype SintaksAsto::np]} {
            set def [$defElemento trovuUnunanInfanonKiu elem {[$elem istype GP::Difinilo] && [$elem estasVorto la]}]
            if  {$def ne ""} {
                $kolektilo aliguEraron $def "Propraj nomoj ne bezonas difinilon." [list ""]
            }
        }
    }
}
GP::Substantivo instproc testuKuntekston priskribo {
    my instvar parenco
    set ptipo [lindex $priskribo 0]

    set kelemento [my trovuMainVerboAston]
    if {$ptipo ni {kun kunobj kunadj} || $kelemento eq ""} {return 0}
    if {$ptipo eq "kun"} {
        # verbo
    } elseif {$ptipo eq "kunobj"} {
        # substativo devas esti objekto
        set objrad [$kelemento trovuKunFunkcio obj]
        if {$objrad eq ""} {return 0}
        set objrad [$objrad prenuRadiko]
        set erad [self]
        if {$objrad ne $erad} {
            return 0
        }
    } elseif {$ptipo eq "kunadj"} {
        if {$parenco eq "" || ![$parenco hasclass SintaksAsto::np]} {
            return 0
        }
        set kelemento [$parenco prenuAdjektivon]
    } else {
        error "ne povas okazi"
    }
    if {$kelemento eq ""} {
        return 0
    }
    set kelemento [$kelemento prenuRadiko]
    foreach p [lrange $priskribo 1 end] {
        if {[$kelemento testuSencon $p]} {
            return 1
        }
    }
    return 0
}
Class GP::PersonPronomo -superclass {::GP::Pronomo ::GP::Substantivo}
@ ::GP::PersonPronomo idemeta component EspSintaksaAnalizo
GP::PersonPronomo instproc estasNePronomo {} {
    return 0
}
GP::PersonPronomo instproc estasPersono {} {
    expr {![my estasBasaVorto ĝi]}
}
GP::PersonPronomo instproc prenuPersonon {} {
    switch -- [string trimright [my prenuVorton] n] {
        mi {
            return 1
        }
        vi {
            return 2
        }
        li {
            return 3
        }
        ŝi {
            return 3
        }
        ĝi {
            return 3
        }
        ni {
            return 1
        }
        ili {
            return 3
        }
        oni {
            return 4
        }
        si {
            return 3
        }
        default {
            return 3
        }
    }
}
GP::PersonPronomo instproc prenuSimbolo {} {
    return PPRON
}
GP::PersonPronomo instproc printString {} {
    return "[my prenuSimbolo] - [my prenuVorton]"
}
Class GP::PosesivPronomo -superclass {::GP::Pronomo ::GP::NombroKazo}
@ ::GP::PosesivPronomo idemeta component EspSintaksaAnalizo
GP::PosesivPronomo instproc estasNeTranzitivaPartizipo {} {
    return 0
}
GP::PosesivPronomo instproc estasTranzitivaPartizipo {} {
    return 0
}
GP::PosesivPronomo instproc prenuBazanFormon {} {
    return [next]a
}
GP::PosesivPronomo instproc prenuSimbolo {} {
    return POSPRON
}
GP::PosesivPronomo instproc sxercxiErarojn kolektilo {
    next
    my instvar parenco radiko kazo vorto funkcio
    set defElemento [my miAuxRadikaElemento]
    set kparenco [$defElemento set parenco]

    if {$kparenco ne "" && [$kparenco istype SintaksAsto::main] && $funkcio ne "parto"} {
        set funkcio [my selektu {miAuxRadikaElemento prenuFunkcioNomo}]
        if {$funkcio ne "attr"} {
            return
        }
        set subj [$kparenco prenuSubjekton]
        if {$subj eq ""} {
            return
        }
        set kazo [my prenuKazon]
        set subNombro [$subj prenuNombron]
        set subjrad [$subj prenuRadiko]
        if {[my prenuNombron] ne $subNombro} {
            # vi povas esti samtemp plurala aux singulara
            # nur en kazo "vi cxiuj" vi estas nur plurala
            if {![$subjrad estasBazajVortoj {vi si oni}] || [$subjrad prenuNombron] eq "pluralo"} {
                set msg "nombro de pronomo kaj substantivo ne similas"
                # se sekva vortoj estas en alia kazo do eble tio estas problemo
                # via libroj estas bonaj.
                $kolektilo aliguEraron [self] $msg [esp::prenuKazoNombro [my prenuBazanFormonKazoNombro] 0 [expr {$subNombro eq "pluralo"}]]
                set sekva [my prenuSekvaElemento]
                if {$sekva ne "" && [$sekva istype GP::NombroKazo] && [$sekva prenuNombron] ne [my prenuNombron]} {
                    set parto [$kparenco trovuKunFunkcio parto]
                    if {$parto ne "" && [[$parto prenuRadiko] istype GP::NombroKazo]} {
                        $parto aliguMerkmalon ignoruparto
                    }
                }
            }
        }
    }
}
Class GP::Prepozicio -superclass ::GP::Partikolo
@ ::GP::Prepozicio idemeta component EspSintaksaAnalizo
GP::Prepozicio instproc eblasKunInf {} {
    expr {[lsearch {por sen anstataŭ krom malgraŭ} [string tolower [my vorto]]]>=0}
}
GP::Prepozicio instproc estasDusignifa {} {
    # la prepozicio akceptas akuzativon
    expr {[string tolower [my vorto]] in {sur en sub kontraŭ preter trans ĉirkaŭ super apud malantaŭ antaŭ}}
}
GP::Prepozicio instproc estasLokoebla {} {
    # eblas liko kun kie, tie
    expr {[lsearch {al el de sur sub ĝis} [string tolower [my vorto]]]>=0}
}
GP::Prepozicio instproc estasTempoebla {} {
    expr {[lsearch {ĝis post de por antaŭ ekde} [string tolower [my vorto]]]>=0}
}
@ GP::Prepozicio instproc prenuSimbolo {} {
description {Du signifaj prepocioj povas havi objekton
en akuzativo aux nominativo.
Li povas esti uzate en du signifoj cxe verboj,
kiu signifas muvigo (iri, kuri, meti)

Al tiu prepozicioj apartanas (en sur)}
}
GP::Prepozicio instproc prenuSimbolo {} {
    return PREP
}
GP::Prepozicio instproc sxercxiErarojn kolektilo {
    #
    if {[my estasVorto da]} {
        set kelemento [my miAuxRadikaElemento]
        if {[$kelemento istype SintaksAsto::pp]} {
            set kelemento [$kelemento selektu {prenuSubsupRadiko prenuRadiko}]
            if {$kelemento ne ""} {
                if {![$kelemento havasDerivoPriskribon kvanto] && ![$kelemento istype GP::Numeralo]} {
                    $kolektilo aliguEraron [self] "uzu \"da\" nur kun kvanto!" de
                }
            }
        }
    }
}
GP::Prepozicio instproc testuKuntekston priskribo {
    set kelemento [my miAuxRadikaElemento]
    if {[$kelemento istype SintaksAsto::pp]} {
        set kelemento [$kelemento selektu {prenuNPParton prenuRadiko}]
        if {[lindex $priskribo 0] ne "kun" || $kelemento eq ""} {return 0}
        foreach p [lrange $priskribo 1 end] {
            if {[$kelemento testuSencon $p]} {
                return 1
            }
        }
    }
    my instvar parenco
    if {$parenco ne "" && [$parenco istype SintaksAsto::advp]} {
        set kelemento [$parenco prenuRadiko]
        if {[lindex $priskribo 0] ne "kun" || $kelemento eq ""} {return 0}
        foreach p [lrange $priskribo 1 end] {
            if {[$kelemento testuSencon $p]} {
                return 1
            }
        }
    }
    return 0
}
Class GP::PrimitivaAdverbo -superclass ::GP::PrimitivaElemento
@ ::GP::PrimitivaAdverbo idemeta component EspSintaksaAnalizo
GP::PrimitivaAdverbo instproc estasAdvAdv {} {
    if {[lsearch {pli malpli} [string tolower [my vorto]]]<0} {
        return 1
    } else {
        return 0
    }
}
GP::PrimitivaAdverbo instproc estasDaSubj {} {
    my estasVortoj {pli tro}
}
GP::PrimitivaAdverbo instproc estasDirektaElementoPriskribo {} {
    expr {[lsearch -exact -sorted {almenaŭ ankaŭ ankoraŭ apenaŭ eĉ jam nur preskaŭ} [my vorto]]>=0}
}
GP::PrimitivaAdverbo instproc estasPluralo {} {
    return 1
}
@ GP::PrimitivaAdverbo instproc estasSolaAdverbo {} {
description {Testo cxu tiu primitiva adverbo povas stari sole en la frazo
Kutime tiu primitiva adverbo rolas kiej adverbo (adjekto)}
}
GP::PrimitivaAdverbo instproc estasSolaAdverbo {} {
    expr {[lsearch -sorted {almenaŭ ankaŭ ankoraŭ antaŭhieraŭ apenaŭ baldaŭ do eĉ for hieraŭ hodiaŭ ja jam jen jes ju malpli mem morgaŭ nun nur pli pli-malpli plimalpli plu post-morgaŭ postmorgaŭ preskaŭ tamen tuj ĵus} [string tolower [my vorto]]]>=0}
}
@ GP::PrimitivaAdverbo instproc estasTempo {} {
description {Testo cxu tiu primitiva adverbo povas stari sole en la frazo
kaj rolas kiel tempa adjekto}
}
GP::PrimitivaAdverbo instproc estasTempo {} {
    expr {[my vorto] in {nun morgaŭ hodiaŭ hieraŭ antaŭhieraŭ}}
}
GP::PrimitivaAdverbo instproc estasTranzitivaPartizipo {} {
    return 0
}
GP::PrimitivaAdverbo instproc prenuKuntekston tipo {
    # La sama metodo kiel en GP::Adverbo
    my instvar parenco elemento
    if {$tipo ni {kun kunadj kunadv}} {return}
    set pelem [my selektu {elemento parenco}]
    if {$pelem ne "" && ([$pelem istype SintaksAsto::adjp] || [$pelem istype SintaksAsto::advp])} {
        if {$tipo in {kunadj kunadv}} {
            return [$pelem prenuRadiko]
        }
    } elseif {$tipo eq "kun"} {
        return [my selektu {trovuMainVerboAston prenuRadiko}]
    }
    return
}
GP::PrimitivaAdverbo instproc prenuNomo {} {
    return PrimAdverbo
}
GP::PrimitivaAdverbo instproc prenuSimbolo {} {
    return PADV
}
GP::PrimitivaAdverbo instproc sxercxiErarojn kolektilo {
    if {[my estasVorto morgaŭ]} {
        set velemento [my prenuKuntekston kun]
        if {$velemento ne "" && [$velemento istype GP::Verbo]} {
            if {[$velemento set tempo] ni "us u i os"} {
                $kolektilo aliguEraron $velemento "adverbo 'morgaŭ' postulas la venontan tempon" [string range [$velemento prenuBazanFormon] 0 end-1]os
            }
        }
    } elseif {[my estasVorto ĵus]} {
        set velemento [my prenuKuntekston kun]
        if {$velemento ne "" && [$velemento istype GP::Verbo]} {
            if {[$velemento set tempo] ni "us u i is"} {
                $kolektilo aliguEraron $velemento "adverbo 'ĵus' postulas la pasintan tempon" [string range [$velemento prenuBazanFormon] 0 end-1]is
            }
        }
    }
    next
}
GP::PrimitivaAdverbo instproc testuKuntekston priskribo {
    # La sama metodo kiel en GP::Adverbo
    set tipo [lindex $priskribo 0]
    set kelemento [my prenuKuntekston $tipo]
    if {$kelemento ne ""} {
        foreach p [lrange $priskribo 1 end] {
            if {[$kelemento testuSencon $p]} {
                return 1
            }
        }
    }
    return 0
}
@ Class GP::Simbolo {
description {Por enhavi literaj simboloj kiel , ; . ?}
}
Class GP::Simbolo -superclass ::GP::Elemento
@ ::GP::Simbolo idemeta component EspSintaksaAnalizo
GP::Simbolo instproc prenuBazanFormon {} {
    my set vorto
}
GP::Simbolo instproc prenuSimbolo {} {
    return SIM
}
GP::Simbolo instproc printString {} {
    my vorto
}
Class GP::Subjunkcio -superclass ::GP::Partikolo
@ ::GP::Subjunkcio idemeta component EspSintaksaAnalizo
Class GP::TabloVorto -superclass ::GP::PrimitivaElemento -parameter {bazo arto}
@ ::GP::TabloVorto idemeta categories {bazaj testado transformigo}
@ ::GP::TabloVorto idemeta categoriesMethods {{prenuSimbolo printString} {estasBazo estasArto estasNePronomo estasArtoj estasNeTablovorto estasBazoj estasKadv estasTempo estasKunliga estasRelativPronomo estasAdvAdv estasKuneblaj} {estuAdjektiva estuSubstantiva}}
@ ::GP::TabloVorto idemeta component EspSintaksaAnalizo
GP::TabloVorto instproc estasAdvAdv {} {
    # nur por adverbaj tablo vortoj
    # sen kie
    my estasArtoj {el om}
}
GP::TabloVorto instproc estasArto a {
    my instvar arto
    expr {$arto eq $a}
}
GP::TabloVorto instproc estasArtoj listo {
    my instvar arto
    expr {[lsearch $listo $arto]>=0}
}
GP::TabloVorto instproc estasBazo b {
    my instvar bazo
    expr {$bazo eq $b}
}
GP::TabloVorto instproc estasBazoj bazoj {
    my instvar bazo
    expr {[lsearch $bazoj $bazo]>=0}
}
GP::TabloVorto instproc estasKadv {} {
    # demanda kaj adverba
    # kie kien kiel kial kiam
    my instvar arto bazo
    expr {$bazo eq "ki" && [lsearch {e en el al am} $arto]>=0}
}
GP::TabloVorto instproc estasKuneblaj {elem ligilo stupo} {
    # kie kaj kiel vi vivas
    if {$ligilo eq ","} { return 0 }
    if {[$elem istype GP::TabloVorto] && [my hasclass GP::Adverbo] && [$elem hasclass GP::Adverbo] && [my set bazo] eq [$elem set bazo]} {
        return 1
    }
    return 0
}
GP::TabloVorto instproc estasKunliga {} {
    my instvar parenco arto bazo
    # anataux la elemento staras komo
    set antauxElemento [my prenuAntauxElemento]
    if {$antauxElemento ne ""} {
        if {[$antauxElemento set vorto] eq ","} {
            return 1
        } else {
            if {[$antauxElemento istype GP::Prepozicio]} {
                set antauxElemento [$antauxElemento prenuAntauxElemento]
                if {$antauxElemento ne ""} {
                    return [expr {[$antauxElemento set vorto] eq ","}]
                }
            }
        }
    }
    return 0
}
GP::TabloVorto instproc estasNePronomo {} {
    return 0
}
GP::TabloVorto instproc estasNeTablovorto {} {
    return 0
}
GP::TabloVorto instproc estasRelativPronomo {} {
    my instvar parenco arto bazo
    if {($arto eq "u" || $arto eq "a" || $arto eq "es") && $bazo eq "ki"} {
        set antauxElemento [my prenuAntauxElemento]
        if {$antauxElemento ne ""} {
            if {[$antauxElemento set vorto] eq ","} {
                return 1
            } else {
                if {[$antauxElemento istype GP::Prepozicio]} {
                    set antauxElemento [$antauxElemento prenuAntauxElemento]
                    if {$antauxElemento ne "" && [$antauxElemento set vorto] eq ","} {
                        return 1
                    }
                }
                set main [my trovuUnuanPerenconKiu par {[$par hasclass SintaksAsto::main]}]
                # Mi vidis homon kiu estas granda.
                # Mi vidis homon pri kiu vi parolis.
                if {$main ne "" && [$main funkcio] eq "subfrazo" && ([lindex [$main astoj] 0] eq [self] || [lindex [$main astoj] 0] eq $parenco)} {
                    return 1
                }
            }
        }
    }
    return 0
}
GP::TabloVorto instproc estasTempo {} {
    return 0
}
GP::TabloVorto instproc estuAdjektiva {} {
    if {![my ismixin ::GP::Adjektivo]} {
        if {[my ismixin ::GP::Substantivo]} {
            my mixin delete ::GP::Substantivo
        }
        if {[my ismixin ::GP::NombroKazo]} {
            my mixin delete ::GP::NombroKazo
        }
        my mixin add ::GP::Adjektivo
    }
}
GP::TabloVorto instproc estuSubstantiva {} {
    if {![my ismixin ::GP::Substantivo]} {
        if {[my ismixin ::GP::Adjektivo]} {
            my mixin delete ::GP::Adjektivo
        }
        if {[my ismixin ::GP::NombroKazo]} {
            my mixin delete ::GP::NombroKazo
        }
        my mixin add ::GP::Substantivo
    }
}
GP::TabloVorto instproc initKunteksto parenco {
    my instvar arto
    if {[$parenco istype SintaksAsto::np] && $arto eq "u"} {
        my estuAdjektiva
    }
    next
}
GP::TabloVorto instproc prenuBazanFormon {} {
    my instvar bazo arto
    return $bazo$arto
}
GP::TabloVorto instproc prenuSimbolo {} {
    return TAB
}
GP::TabloVorto instproc printString {} {
    return "[my prenuNomo]: [my vorto]"
}
GP::TabloVorto instproc rekoni {} {
    my instvar bazo arto vorto
    set tabvortoj [list ki ti i ĉi neni]
    set tvorto [string tolower $vorto]
    foreach t $tabvortoj {
        if {[string range $tvorto 0 [expr {[string length $t]-1}]] eq $t} {
            set bazo $t
            break
        }
    }
    set fino [string range $tvorto [string length $bazo] end]
    switch -- $fino {
        u {
            set arto u
            my mixin add GP::NombroKazo
        }
        uj {
            set arto u
            my mixin add GP::NombroKazo
        }
        ujn {
            set arto u
            my mixin add GP::NombroKazo
        }
        un {
            set arto u
            my mixin add GP::NombroKazo
        }
        o {
            set arto o
            my mixin add GP::Substantivo
        }
        on {
            set arto o
            my mixin add GP::Substantivo
        }
        a {
            set arto a
            my mixin add GP::Adjektivo
        }
        an {
            set arto a
            my mixin add GP::Adjektivo
        }
        aj {
            set arto a
            my mixin add GP::Adjektivo
        }
        ajn {
            set arto a
            my mixin add GP::Adjektivo
        }
        es {
            set arto es
            my mixin add GP::Adverbo
        }
        e {
            set arto e
            my mixin add GP::Adverbo
        }
        en {
            set arto e
            my mixin add GP::Adverbo
            my ekkoniFinajxo $fino
        }
        am {
            set arto am
            my mixin add GP::Adverbo
        }
        al {
            set arto al
            my mixin add GP::Adverbo
        }
        el {
            set arto el
            # kiel havas du naturoj
            # sole gxi laboras kiel adverbo
            # "kiel vi tion faris?"
            # kun substantivo gxi estas kvazau prepozicio
            # "Mi volas esti forta kiel urso."
            # my mixin add GP::Adverbo
        }
        om {
            set arto om
            my mixin add GP::Adverbo
        }
        oma {
            set arto om
            my mixin add GP::Adjektivo
        }
        default {
            set arto ?
        }
    }
    if {[my hasclass GP::NombroKazo]} {
        my ekkoniFinajxo $fino
    }
}
GP::TabloVorto instproc sxercxiErarojn kolektilo {
    next
    # testu nombro en relativaj subfrazoj. 
    # ekz: Homoj , kiujn mi konas , estas junaj
    if {[my estasBazo ki] && [my ismixin GP::Substantivo]} {
        my instvar parenco
        if {[$parenco istype SintaksAsto::main] && [$parenco set funkcio] eq "subfrazo"} {
            set pparenco [$parenco set parenco]
            if {$pparenco ne "" && [$pparenco istype SintaksAsto::disk]} {
                 if {[$pparenco exists relradiko]} {
                     set srad [[$pparenco set relradiko] prenuRadiko]
                 } else {
                     set srad [$pparenco prenuRelFrazoRadiko]
                 }
                 # Mi konas la eblon de homoj, kiu estas senlima.
                 if {[$srad selektu {miAuxRadikaElemento parenco prenuFunkcioNomo}] ne "pos" && [$srad selektu {parenco parenco prenuFunkcioNomo}] ne "pos"} {
                     if {[$srad hasclass GP::NombroKazo] && [$srad prenuNombron] ne [my prenuNombron]} {
                         $kolektilo aliguEraron [self] "nombro ne similas kun priskribata o-vorto" [esp::prenuKazoNombro [my prenuBazanFormon] [my estasAkuzativo] [$srad estasPluralo]]
                         return
                     }
                     if {[$srad hasclass GP::TabloVorto] && [$srad set arto] eq "o" && [my set arto] eq "u"} {
                         my instvar vorto
                         set f ""
                         regexp {.+?(n|jn)$} $vorto _ f
                         $kolektilo aliguEraron [self] "tio, kio" [my set bazo]o$f
                         return
                     }
                 }
                 # Bonvena alternativo estis pomkompoto farita el la pomoj de nia ĝardeno, kiuj estis konservitaj en la kelo sur bretaro.
                 if {[$srad istype GP::TabloVorto] && [$srad estasArto o]} {
                     # tio, kiu
                     if {[$srad hasclass GP::Substantivo] && [my set arto] eq "u" && [my set bazo] eq "ki"} {
                         my instvar vorto
                         set f ""
                         regexp {.+?(n|jn)$} $vorto _ f
                         $kolektilo aliguEraron [self] "uzu 'kio' kiel relativan pronomon" [my set bazo]o$f
                     
                     }
                 } else {
                     # , kio
                     if {[$srad hasclass GP::Substantivo] && [my set arto] eq "o" && [my set bazo] eq "ki" && !([$srad istype GP::TabloVorto] && [$srad estasArto o])} {
                         my instvar vorto
                         set f ""
                         regexp {.+?(n|jn)$} $vorto _ f
                         $kolektilo aliguEraron [self] "uzu 'kiu' kiel relativan pronomon" [my set bazo]u$f
                     
                     }
                 }
             }
        }
    }
}
GP::TabloVorto instproc testuSintakso elem {
    next
}
@ Class GP::Verbo {
description Verbo
}
Class GP::Verbo -superclass ::GP::Elemento -parameter tempo
@ ::GP::Verbo idemeta categories testado
@ ::GP::Verbo idemeta categoriesMethods {{eblasAlPrepozicio estasInfinitivo estasOrdono eblasFor estasInfinitivoTransitiva estasInfinitivoEst estasEldiro eblasAdjComp eblasObjekto estasEst necesasSubjekton estasMuvigo eblasObjComp eblasObjAdjComp eblasIndirektaObjekto eblasComp estasModVerbo estasKuneblaj}}
@ ::GP::Verbo idemeta component EspSintaksaAnalizo
GP::Verbo instproc eblasAdjComp {} {
    expr {"acomp" in [lindex [my derivolisto] 2]}
}
GP::Verbo instproc eblasAlPrepozicio {} {
    expr {[my estasMuvigo] || [my eblasIndirektaObjekto]}
}
@ GP::Verbo instproc eblasComp {} {
description {perverba priskribo de subjekto
ekz: li estas homo}
}
GP::Verbo instproc eblasComp {} {
    # expr {[lsearch {esti nomi fariĝi ŝajni} [my prenuBazanFormon]]>=0}
    my havasDerivoPriskribonBaza scomp
}
GP::Verbo instproc eblasFor {} {
    my instvar radiko
    expr {[$radiko sxercxuDerivonPS for i] ne ""}
}
GP::Verbo instproc eblasIndirektaObjekto {} {
    my havasDerivoPriskribonBaza indobj
}
@ GP::Verbo instproc eblasObjAdjComp {} {
description {ajektiva perverba priskribo de objekto
ekz: mi farbis la domon blua}
}
GP::Verbo instproc eblasObjAdjComp {} {
    my havasDerivoPriskribonBaza aocomp
}
@ GP::Verbo instproc eblasObjComp {} {
description {ajektiva perverba priskribo de objekto
ekz: mi farbis la domon blua}
}
GP::Verbo instproc eblasObjComp {} {
    my havasDerivoPriskribonBaza socomp
}
GP::Verbo instproc eblasObjekto {} {
    my instvar derivolisto radiko vorto
    if {[string range [lindex $derivolisto 1] end-2 end] eq "igi"
        || [string range [lindex $derivolisto 1] end-4 end] eq "igadi"
        || "trans" in [lindex $derivolisto 2]
        || [lindex $derivolisto 0] eq "pri"} {
        return 1
    }
    # ne konataj verboj
    if {[regexp {ig(i|as|is|us|os)$} $vorto]} {
        return 1
    }
    if {[lindex $derivolisto 1] in {adi igi eti egi i} || [lindex $derivolisto 0] in  {ne re}} {
        set ndl [$radiko sxercxuDerivonPS {} i]
        if {"trans" in [lindex $ndl 2]} {
            return 1
        }
    }
    return 0
}
GP::Verbo instproc ekkoniFinajxo finajxo {
    my set tempo $finajxo
}
GP::Verbo instproc eraroNeTransitivaKunObjekto {kolektilo objekto} {
    my instvar tempo
    # ignoru se nekonata vorto
    if {[my estasNekonata]} {
        return
    }
    if {[$objekto havasMerkmalon nekonataDerivo] || [$objekto hasclass GP::NekonataMix] || [$objekto hasclass GP::Konstanto]} {
        # La nova Esperanto-urbo Herzberg situas iom norde de la geografia centro de Germanio
        if {[$objekto selektu {prenuAntauxElemento {hasclass GP::Substantivo}}] ne "0"} {
            return
        }
    }

    array set tArr {
        necesi bezoni
        plaĉi ŝati
    }
    GP::Verbo metuIgVerbojArr tArr
    array set esceptoj {
        iri vojo
        ekiri vojo
        pensi penso
        vojaĝi {vojo lando mondo}
        veturi vojo
        labori laboro
        peki peko
        utili nenio
        funebri morto
        kuri distanco
        paroli {lingvo esperanto vorto dialekto vero sensencaĵo gramatiko malbono malo nomo restaĵo samo stultaĵo ĵuro angla germana pola itala rusa}
    }

    if {![catch {set esceptoj([my prenuBazanFormon])} objektoj]} {
        set ovorto [[set orad [$objekto prenuRadiko]] prenuBazanFormon]
        if {$ovorto in $objektoj} {
            return
        }
        # La vojo, kiun vi iras, estas bona
        if {[$orad istype GP::TabloVorto]} {
            return
        }
    }
    if {[my prenuBazanFormon] eq "manki"} {
        $kolektilo aliguEraron [self] "oni diras: \"io mankas al iu\""
    } elseif {![catch {set tArr([my prenuBazanFormon])} tVerbo]} {
        $kolektilo aliguEraron [self] "verbo '[my prenuBazanFormon]' ne ebligas objekton; uzu la ig-formon aŭ alian verbon" [string range $tVerbo 0 end-1]$tempo
    } else {
        $kolektilo aliguEraron [$objekto prenuRadiko] "verbo '[my prenuBazanFormon]' ne ebligas objekton"
    }
}
GP::Verbo instproc estasEldiro {} {
    expr {[lsearch -exact {diri daŭri aldoni} [my prenuBazanFormon]]>=0}
}
GP::Verbo instproc estasEst {} {
    # expr {[lsearch {esti resti ŝajni fariĝi iĝi} [my prenuBazanFormon]]>=0}
    set mod [lindex [my derivolisto] 2]]
    expr {"scomp" in $mod || "acomp" in $mod}
}
GP::Verbo instproc estasInfinitivo {} {
    expr {[string index [my vorto] end] eq "i"}
}
GP::Verbo instproc estasInfinitivoEst {} {
    expr {[my estasInfinitivo] && [my estasEst]}
}
GP::Verbo instproc estasInfinitivoTransitiva {} {
    expr {[my estasInfinitivo] && [my eblasObjekto]}
}
GP::Verbo instproc estasKuneblaj {elem ligilo stupo} {
    # auxtomata kunligigo tro dangxera, cxar povas esti aplikata
    # sur frazoj
    return 0
    if {[my estasInfinitivo] && [$elem istype GP::Verbo] && [$elem estasInfinitivo]} {
        # escepto nur por infinitivoj
        # me sxatas dormi kaj legi
        return 1
    }
    return 0
}
GP::Verbo instproc estasModVerbo {} {
    my havasDerivoPriskribonBaza mod
}
GP::Verbo instproc estasMuvigo {} {
    my havasDerivoPriskribonBaza muv
}
GP::Verbo instproc estasOrdono {} {
    expr {[string index [my vorto] end] eq "u"}
}
GP::Verbo instproc estasVortoEstNeInfinitivo {} {
    expr {[my estasBasaVorto esti] && ![my estasInfinitivo]}
}
GP::Verbo instproc havasDerivoPriskribonBaza priskribo {
    my instvar derivolisto radiko
    if {[my havasDerivoPriskribon $priskribo]} {
        return 1
    }
    if {[lindex $derivolisto 1] in {adi eti egi i} || [lindex $derivolisto 0] in  {ne re}} {
        set ndl [$radiko sxercxuDerivonPS {} i]
        if {$priskribo in [lindex $ndl 2]} {
            return 1
        }
    }
    return 0
}
@ GP::Verbo instproc necesasSubjekton {} {
description {cxu ne necesas subjekton !
ekzemple: pluvi, esti}
}
GP::Verbo instproc necesasSubjekton {} {
    expr {"sensub" ni [lindex [my derivolisto] 2]}
}
GP::Verbo instproc prenuGramatikeAnalogan vorto {
    my instvar tempo
    regexp {^(.+)i$} $vorto _ vorto
    append vorto $tempo
}
GP::Verbo instproc prenuNombron {} {
    #  por kazo ke verbo estas substantivo
    return singularo
}
GP::Verbo instproc prenuSimbolo {} {
    return V
}
GP::Verbo instproc prenuVerbRadiko {} {
    self
}
GP::Verbo instproc sxercxiErarojn kolektilo {
    next
    my instvar radiko vorto derivolisto tempo
    set bazaFormo [my prenuBazanFormon]
    # Eraro: Mi komencigis la laboron
    # komenci estas jam transitiva
    if {[info exists radiko] && $radiko ne "" && [string range $bazaFormo end-2 end] eq "igi" && $bazaFormo ni {havigi farigi memorigi rememorigi kapabligi malkapabligi koloniigi kontaktigi komprenigi subkomprenigi radikigi daŭrigi centrigi koloniigi indignigi sulkigi heredigi dentigi kontaktigi komprenigi subkomprenigi breĉigi radikigi ĵurigi daŭrigi ekvilibrigi konfesigi konfidigi kompatigi pensigi boligi artikigi devigi dirigi rimarkigi egaligi favorigi farigi loĝigi penetrigi luigi neigi origi finigi pintigi atentigi ĉirkaŭigi havigi ŝraŭbigi terurigi ŝparigi potencigi falsigi indigi dolorigi buterigi farmigi kavigi vitrigi koncentrigi decidigi kodigi konigi limigi sonorigi lumigi klasigi movigi obeigi presigi interesigi ŝuldigi pasigi eksplodigi rajtigi ordigi abonigi lernigi sciigi supozigi distingigi kredigi timigi kolorigi modeligi krucigi vidigi vivigi volontigi foliigi suĉigi kulpigi kvadratigi simboligi embuskigi sekvigi sentigi glorigi anstataŭigi disponigi naskigi honorigi ruinigi manĝigi reguligi motivigi ĉarmigi reprezentigi komunikigi aŭdigi bruligi konatigi trinkigi antaŭsciigas}} {
        set senigi [string range $bazaFormo 0 end-2]
        set vortaro [Vortaro prenuVortaron]
        # ignoru se objecto estas persono
        # tio signifas "igi" iun fari
        if {[my selektu {miAuxRadikaElemento {filtruVeron hasclass SintaksAsto} {trovuKunFunkcio obj} prenuRadiko {filtruVeron hasclass GP::Substantivo} estasPersono}] ne "1"} {
            if {[$vortaro estasVorto $senigi]==2} {
                if {"trans" in [$vortaro set derivolisto]} {
                    $kolektilo aliguEraron [self] "la verbo '$senigi' estas jam transitiva." [my prenuGramatikeAnalogan $senigi]
                }
            }
        }
    }
    # kiel trovi tiujn derivajxojn
    #set ret ""
    #set revo [REVOdatabazoSQL prenuBazon]
    #foreach r [Radiko chiojRadikoj] {
        #foreach d [$r prenuDerivoj] {
            #if {[string range $d end-2 end] eq "igi"} {
                #set senigi [string range $d 0 end-2]
                #set de [$r sxercxuDerivon $senigi]
                #if {"trans" in [lindex $de 2]} {
                    #if {[llength [lindex [$revo trovuSencojn $d] 0]]>0} {
                        #lappend ret $d
                    #}
                #}
            #}
        #}
    #}
    #set ret

    if {[string match ne* $vorto] && $tempo in {is os us u as}} {
        set vortaro [Vortaro prenuVortaron]
        if {[$vortaro estasVorto [string range $vorto 2 end]]==2} {
            $kolektilo aliguEraron [self] "oni skribas 'ne' kun verboj dise." [list "ne [string range $vorto 2 end]"]
        }
    }
}
GP::Verbo instproc testuKuntekston priskribo {
    set kelemento [my trovuMainVerboAston]
    set ptipo [lindex $priskribo 0]
    if {$ptipo ni {kun kunobj kunadv} || $kelemento eq ""} {return 0}
    if {$ptipo eq "kun"} {
        set kelemento [$kelemento trovuKunFunkcio subj]
    } elseif {$ptipo eq "kunobj"} {
        set kelemento [$kelemento trovuKunFunkcio obj]
    } elseif {$ptipo eq "kunadv"} {
        set kelemento [$kelemento trovuKunFunkcio adv]
    } else {
        puts "falsa kunteksto $ptipo"
    }
    if {$kelemento eq ""} {
        return 0
    }
    set kelemento [$kelemento prenuRadiko]
    foreach p [lrange $priskribo 1 end] {
        if {[$kelemento testuSencon $p]} {
            return 1
        }
    }
    return 0
}
GP::Verbo proc metuIgVerbojArr arr_ref {
    upvar $arr_ref tArr
    # Verboj kiuj ofte estas konsiderataj kiel transitivaj
    array set tArr {
        starti startigi
        recikli recikligi
        ebli ebligi
        aborti abortigi
        boli boligi
        bruli bruligi
        daŭri daŭrigi
        degeli degeligi
        droni dronigi
        eksplodi eksplodigi
        halti haltigi
        lumi lumigi
        pasi pasigi
        pendi pendigi
        soni sonigi
        sonori sonorigi
        evolui evoluigi
    }
}
GP::Verbo proc sxercxuTransitivajnVerbojn {} {
    foreach r [Radiko chiojRadikoj] {
        if {[$r havasFinon i] && [$r havasFinon ebla]} {
            set i 0
            foreach d [$r set derivoj] {
                if {[lindex $d 0] eq "" && [lindex $d 1] eq "i"} {
                    set def [lindex $d 2]
                    if {[lsearch $def trans]<0} {
                        puts "$r estu transitiva"
                        lappend def trans
                        $r instvar derivoj
                        if {[llength $def]==1} {
                            lset derivoj $i [concat $d $def]
                        } else {
                            lset derivoj $i 2 $def
                        }
                        break
                    }
                }
                incr i
            }
        }
    }
}
Class GramMRegulo
@ ::GramMRegulo idemeta component EspSintaksaAnalizo
GramMRegulo instproc enlegu difino {
    my set mesagxo "sen mesagxo"
    foreach {tipo dif} $difino {
        if {$tipo eq "komento"} {
            continue
        }
        my set $tipo $dif
    }
}
GramMRegulo instproc prenuProponojn elementoj {
    my instvar korekto pkorekto
    if {[info exists korekto]} {
        return $korekto
    } elseif {[info exists pkorekto]} {
        set i 1
        foreach e $elementoj {
            set e$i $e
            set v$i [$e prenuVorton]
            incr i
        }
        if {[catch {subst $pkorekto} ret]} {
            puts "$ret\n$::errorInfo"
            return ERR
        }
        return $ret
    } else {
        return
    }
}
GramMRegulo instproc prenuRegionon elementoj {
    my instvar regiono
    if {[info exists regiono]} {
        if {[llength $regiono]==1} {
            return [lindex $elementoj [lindex $regiono 0]]
        } else {
            set range [lrange $elementoj [lindex $regiono 1] [lindex $regiono 2]]
            # oni interesas nur pri unua kaj lasta elemento
            return [list [lindex $range 0] [lindex $range end]]
        }
    } else {
        if {[llength $elementoj]==1} {
            return [lindex $elementoj 0]
        } else {
            # oni interesas nur pri unua kaj lasta elemento
            return [list [lindex $elementoj 0] [lindex $elementoj end]]
        }
    }

}
GramMRegulo instproc testu sarbo {
    my instvar match
    if {[catch {$sarbo match $match} err]} {
        puts "eraro cxe regulo [my set mesagxo] $err $::errorInfo"
        return
    }
    return $err
}
@ Class GramMReguloKorektilo {
description {Gramatika korektilo laux musteraj reguloj}
}
Class GramMReguloKorektilo
@ ::GramMReguloKorektilo idemeta component EspSintaksaAnalizo
GramMReguloKorektilo instproc enlegu dosiero {
    my instvar reguloj
    if {[info exists reguloj]} {
        foreach r $reguloj {
            $r destroy
        }
    }
    set reguloj [list]
    if {![file isfile $dosiero]} {
        return
    }
    set f [open $dosiero r]
    set script ""
    while {[gets $f line]>=0} {
        if {[string index $line 0] eq "#"} continue
        append script $line \n
        if {[info complete $script]} {
            if {[lindex $script 0] eq "regulo"} {
                set r [GramMRegulo new -childof [self]]
                $r enlegu [lindex $script 1]
                lappend reguloj $r
            }
            set script ""
        }
    }
    close $f
}
GramMReguloKorektilo instproc testu sarbo {
    my instvar reguloj
    foreach r $reguloj {
        set rez [$r testu $sarbo]
        if {[llength $rez]>0} {
            return [list $r $rez]
        }
    }
    return
}
GramMReguloKorektilo instproc testuPorErarkolektilo {kolektilo sarbo} {
    my instvar reguloj
    foreach r $reguloj {
        set rez [$r testu $sarbo]
        if {[llength $rez]>0} {
            $kolektilo aliguEraron [$r prenuRegionon $rez] [$r set mesagxo] [$r prenuProponojn $rez] 1
        }
    }
}
GramMReguloKorektilo proc prenuGramKorektiloDosieron {} {
    file join [EsperantoConf prenuVortaroDosierujo] gramreguloj.txt
}
GramMReguloKorektilo proc prenuKorektiolon {} {
    my instvar korektilo
    if {![info exists korektilo] || ![Object isobject $korektilo]} {
        set korektilo [GramMReguloKorektilo new]
        $korektilo enlegu [my prenuGramKorektiloDosieron]
    }
    return $korektilo
}
GramMReguloKorektilo proc relegu {} {
    [my prenuKorektiolon] enlegu [my prenuGramKorektiloDosieron]
}
@ Class HTMLFrazoLegilo {
description {klaso povas legi HTML fonton kaj ignori html-markilojn}
}
Class HTMLFrazoLegilo -superclass ::FrazoLegilo -parameter {{frazFinoSigno 0} {uzuListoSignon 0}}
@ ::HTMLFrazoLegilo idemeta component EspSintaksaAnalizo
HTMLFrazoLegilo instproc komencuFrazon {} {
    next
    my uzuListoSignon 0
}
HTMLFrazoLegilo instproc prenuVorton {} {
    set vorto [next]
    if {$vorto eq "<"} {
        set resto [my saltuGxis >]
        if {[string range $resto 0 7] eq "!DOCTYPE"} {
            return _FINO_
        } elseif {[string range $resto 0 2] eq "!--" && [string range $resto end-2 end] ne "-->"} {
            set resto [my saltuGxisSekvo -->]
        } elseif {[regexp {\s*(\w+)} $resto _ markilo]} {
            set markilo [string tolower $markilo]
            set ignorListo [HTMLFrazoLegilo prenuMultIgnorListo]
            if {[lsearch $ignorListo $markilo]>=0} {
                if {![regexp {/\s*>} $resto _ markilo]} {
                    my saltuGxiMalfermataMarkilo $markilo
                    return _FINO_
                }
            } else {
                set enmiksoListo [HTMLFrazoLegilo prenuEnmiksigxoListo]
                if {[lsearch $enmiksoListo $markilo]<0} {
                    return _FINO_
                }
            }
        }
        return [my prenuVorton]
    } elseif {$vorto eq "&"} {
        set resto [my saltuGxis \;]
        return [my prenuVorton]
    }
    return $vorto
}
HTMLFrazoLegilo instproc saltuGxiMalfermataMarkilo markilo {
    my instvar signoLegilo
    while {![$signoLegilo estasFino]} {
        my saltuGxis <
        set rez [my saltuGxis >]
        if {[regexp -nocase {^\s*/\s*(\w+)} $rez _ finmarkilo]} {
            if {[string tolower $finmarkilo] eq $markilo} {
                break
            }
        }
    }
}
HTMLFrazoLegilo instproc saltuGxis signo {
    my instvar signoLegilo
    set rez ""
    while {![$signoLegilo estasFino]} {
        set sig [$signoLegilo sekvaSigno]
        append rez $sig
        if {$sig eq $signo} {
            break
        }
    }
    return $rez
}
HTMLFrazoLegilo instproc saltuGxisSekvo sekvo {
    my instvar signoLegilo
    set rez ""
    set index 0
    set sl [string length $sekvo]
    incr sl -1
    while {![$signoLegilo estasFino]} {
        set sig [$signoLegilo sekvaSigno]
        append rez $sig
        if {[string range $rez end-$sl end] eq $sekvo} {
             return rez
        }
    }
    return $rez
}
HTMLFrazoLegilo proc prenuEnmiksigxoListo {} {
    list a img b i u strike s big small sup span font em strong br
}
HTMLFrazoLegilo proc prenuIgnorListo {} {
    return {meta map img input object applet embed script pre code img kbd cite style}
}
HTMLFrazoLegilo proc prenuMultIgnorListo {} {
    list map embed script pre code cite style
}
Class OficialaVortoTestilo
@ ::OficialaVortoTestilo idemeta component EspSintaksaAnalizo
OficialaVortoTestilo instproc estasOficiala vorto {
    set vortaro [Vortaro prenuVortaron]
    set vorto [string tolower $vorto]
    if {[$vortaro estasVorteto $vorto]} {
        return 1
    }
    set rezulto [$vortaro estasVorto $vorto]
    # mallongigxo aux numeralo
    if {$rezulto==4 || $rezulto==5} {return 1}
    # nekonato aux konstanto
    if {$rezulto==3 || $rezulto==0} {return 0}

    my instvar radikoj
    lassign [$vortaro prenuVortfarado] prefikso radiko sufikso vortktg
    if {$rezulto==1} {
        foreach k [$vortaro set kandidatoj] {
            lassign $k prefikso radiko sufikso vortktg
            if {[my estasOficialaRadikoListo $radiko $vortaro]} {
                return 1
            }
        }
    } else {
        if {[my estasOficialaRadikoListo $radiko $vortaro]} {
            return 1
        }
    }
    return 0
}
OficialaVortoTestilo instproc estasOficialaRadiko radiko {
    my instvar radikoj
    if {[lsearch -sorted $radikoj $radiko]>0} {
         return 1
    }
    if {[regexp {^(.+)[aoi]n?t$} $radiko _ nr] && [lsearch -sorted $radikoj $nr]>0} {
        return 1
    }
    return 0
}
OficialaVortoTestilo instproc estasOficialaRadikoListo {radikoListo vortaro} {
    my instvar radikoj
    if {![my estasOficialaRadiko [lindex $radikoListo end]]} {
        return 0
    }
    foreach radiko [lrange $radikoListo 0 end-1] {
        if {[lsearch -sorted $radikoj $radiko]>0} {
            break
        }
        if {[regexp {^(.+)[aoe]$} $radiko _ nr] && [lsearch -sorted $radikoj $nr]>0} {
            break
        }
        if {[regexp {^(.+)[aoi]n?t$} $radiko _ nr] && [lsearch -sorted $radikoj $nr]>0} {
            break
        }
        if {$radiko in [$vortaro set prefiksoj]} {
            # pra-ge-nepoj
            break
        }
        if {[my estasOficiala ${radiko}o]} {
            break
        }
        return 0
    }
    return 1
}
OficialaVortoTestilo instproc legu {} {
    set d [file join [EsperantoConf prenuFontoDosierujon] oficialaj.txt]
    if {[file isfile $d]} {
        my leguDeDosiero $d
    } else {
        error "oficialaj radikoj $d ne ekzistas"
    }
}
OficialaVortoTestilo instproc leguDeDosiero dosiero {
    my instvar radikoj
    set radikoj [list]
    set f [open $dosiero r]
    while {[gets $f line]>=0} {
        set l [string trim $line]
        if {[string index $l 0] eq "#"} continue
        if {[regexp {^\w+} $l radiko]} {
            lappend radikoj [string tolower $radiko]
        }
    }
    set radikoj [lsort $radikoj]
    close $f
}
OficialaVortoTestilo proc convert {} {
    set d [IDE::Dialog getOpenFile]
    if {$d eq ""} return
    set f [open $d r]
    set of [open [file join [EsperantoConf prenuFontoDosierujon] oficialaj.txt] w]
    while {[gets $f line]>=0} {
        set v [lindex $line 1]
        if {[string first - $v]>=0} {
            continue
        }
        puts $of $v
    }
    close $of
    close $f
}
OficialaVortoTestilo proc prenuTestilon {} {
    my instvar testilo
    if {![info exists testilo] || ![Object isobject $testilo]} {
        set testilo [OficialaVortoTestilo new]
        $testilo legu
    }
    return $testilo
}
Class PliBonaVortoKorektilo
@ ::PliBonaVortoKorektilo idemeta component EspSintaksaAnalizo
PliBonaVortoKorektilo instproc enlegu dosiero {
    my instvar plibonajArr
    if {[array exists plibonajArr]} {
        unset plibonajArr
    }
    if {![file isfile $dosiero]} {
        return
    }
    set f [open $dosiero r]
    set script ""
    while {[gets $f line]>=0} {
        if {[string index $line 0] eq "#"} continue
        regsub -all {\(.+?\)} $line {} line
        lassign [split $line >] vorto plibonaj
        set pb [list]
        foreach i [split $plibonaj ,] {
            lappend pb [string trim $i]
        }
        set plibonajArr([string trim $vorto]) $pb
    }
    close $f
}
PliBonaVortoKorektilo instproc enleguFalsajnAmikojn dosiero {
    my instvar falsajAmikojArr
    if {[array exists falsajAmikojArr]} {
        unset falsajAmikojArr
    }
    if {![file isfile $dosiero]} {
        return
    }
    set f [open $dosiero r]
    while {[gets $f line]>=0} {
        if {[string index $line 0] eq "#"} continue
        set vortoj [split $line \t]
        if {[llength $vortoj]!=4} {
            puts "malbona defino de falsa amiko; atendas 4 vortoj - $line [llength $vortoj]"
        }
        set ret [list]
        foreach v $vortoj {
            lappend ret [string trim $v]
        }
        set s [list]
        foreach v [split [lindex $ret 1] ,\;] {
            lappend s [string trim $v]
        }
        lset ret 1 $s
        set falsajAmikojArr([lindex $ret 2]) $ret
    }
    close $f
}
PliBonaVortoKorektilo instproc listoDeOftajVortoj {} {
    my instvar plibonajArr
    set frek [FrekvencoListo prenuFrekveno]
    foreach v [array names plibonajArr] {
        lappend ret [list [$frek prenuFrekvencon $v] $v]
    }
    set ret [lsort -integer -index 0 $ret]
    join $ret \n
}
PliBonaVortoKorektilo instproc testuPorErarkolektilo {kolektilo sarbo} {
    my instvar plibonajArr falsajAmikojArr
    set testuPliBonaj [EsperantoConf set gramatikaPliBonajVortoj]
    set testuFalsajAmikoj [EsperantoConf set gramatikaFalsajAmikoj]
    foreach elemento [$sarbo prenuFoliojn] {
        set v [$elemento prenuBazanFormon]
        if {$testuPliBonaj} {
            if {![catch {set plibonajArr($v)} plibonaj]} {
                set pb [list]
                foreach i $plibonaj {
                    lappend pb [$elemento prenuGramatikeAnalogan $i]
                }
                $kolektilo aliguEraron [list $elemento $elemento] "uzu pli konvenan sinonimon" $pb 10
            }
        }
        if {$testuFalsajAmikoj} {
            if {![catch {set falsajAmikojArr($v)} fvortoj]} {
                set pb [list]
                foreach i [lindex $fvortoj 1] {
                    lappend pb [$elemento prenuGramatikeAnalogan $i]
                }
                $kolektilo aliguEraron [list $elemento $elemento] "ebla falsa amiko; '$v' signifas '[lindex $fvortoj 3]'; '[lindex $fvortoj 0]' estas: '[lindex $fvortoj 1]'" $pb 11
            }
        }
    }
}
PliBonaVortoKorektilo proc prenuFalsajAmikojDosieron {} {
    file join [EsperantoConf prenuVortaroDosierujo] falsajamikoj_[EsperantoConf set gramatikaFalsajAmikojNaciaLingvo].txt
}
PliBonaVortoKorektilo proc prenuFalsajAmikojLingvoj {} {
    set lingvoj [list]
    foreach file [glob -nocomplain -directory [EsperantoConf prenuVortaroDosierujo] falsajamikoj_*.txt] {
        if {[regexp falsajamikoj_(.+).txt $file _ lingvo]} {
            lappend lingvoj $lingvo
        }
    }
    return $lingvoj
}
PliBonaVortoKorektilo proc prenuKorektiloDosieron {} {
    file join [EsperantoConf prenuVortaroDosierujo] plibonajvortoj.txt
}
PliBonaVortoKorektilo proc prenuKorektiolon {} {
    my instvar korektilo
    if {![info exists korektilo] || ![Object isobject $korektilo]} {
        set korektilo [PliBonaVortoKorektilo new]
        $korektilo enlegu [my prenuKorektiloDosieron]
        $korektilo enleguFalsajnAmikojn [my prenuFalsajAmikojDosieron]
    }
    return $korektilo
}
PliBonaVortoKorektilo proc relegu {} {
    set k [my prenuKorektiolon]
    $k enlegu [my prenuKorektiloDosieron]
    $k enleguFalsajnAmikojn [my prenuFalsajAmikojDosieron]
}
@ Class Radiko {
description {Baza klaso por cxiu radiko de esperanta vortaro.
Derivoj estas enskribitaj kiel listoj en tiuj instancoj.
Radikoj estas konservitaj kiel radikoj.xotcl dosiero en formato de XOTcl kodo.
Cxiu instancoj estas subobjekto de klasa objekto ::Radiko.
Ekzemple por radiko "vid" la objekto nomas "::Radiko::vid"

La parametero "arto" difinas simile kiel oficiala vortaro la cxefan naturon de radiko.
Do "a" por adejektiva, "o" por subjektiva.}
}
Class Radiko -parameter arto
@ ::Radiko idemeta categoriesMethodsProcs {{chiojRadikoj addDerivo forigu metuDerivoAttr estuPropraNomo estuKutimaRadiko pr}}
@ ::Radiko idemeta categoriesProcs privata-vortaro
@ ::Radiko idemeta component EspSintaksaAnalizo
@ Radiko instproc addDerivo {} {
description {resultas 1 se derivo ne jam egsistis
kaj estas aligita
aliekaze 0}
}
Radiko instproc addDerivo {prefikso sufikso} {
    my instvar derivoj
    set l [list $prefikso $sufikso]
    if {![info exists derivoj] || ![my ekzistasDerivo $prefikso $sufikso]} {
        lappend derivoj $l
        return 1
    }
    return 0
}
Radiko instproc eksportuKielXML fileh {
    my instvar arto
    if {[info exists arto]} {
        puts $fileh "<rdk v='[my prenuRadiko]' a='$arto'>"
    } else {
        puts $fileh "<rdk v='[my prenuRadiko]'>"
    }
    foreach v [my prenuListDerivoj] {
        set attr ""
        if {[lindex $v 0] eq "" && [lindex $v 1] eq ""} {
            if {[my istype Propranono]} {
                append attr " nomo='1'"
            } elseif {[my istype Pronomo]} {
                append attr " typo='[my prenuTypo]'"
            }
        }
        if {[lindex $v 0] ne ""} {
            append attr " pre='[lindex $v 0]'"
        }
        if {[lindex $v 1] ne ""} {
            append attr " suf='[lindex $v 1]'"
        }
        if {[llength $v]>2} {
            append attr " grm='[lindex $v 2]'"
        }
        puts $fileh "  <drv$attr />"
    }
    puts $fileh </rdk>
}
Radiko instproc ekzistasDerivo {prefikso sufikso} {
    my instvar derivoj
    if {![info exists derivoj]} {
        return 0
    }
    foreach d $derivoj {
        if {[lindex $d 0] eq $prefikso && [lindex $d 1] eq $sufikso} {
            return 1
        }
    }
    return 0
}
Radiko instproc estasVorto vorto {
    if {[lsearch [my prenuDerivoj] $vorto]>=0} {
       return 1
    }
    return 0
}
Radiko instproc estuKutimaRadiko args {
    # mi estas jam
}
Radiko instproc estuPropraNomo {} {
    my class Propranono
}
Radiko instproc forigu {} {
    my destroy
}
Radiko instproc foriguDerivo {prefikso sufikso} {
    my instvar derivoj
    set i 0
    if {[info exists derivoj]} {
        foreach d $derivoj {
            if {[lindex $d 0] eq $prefikso && [lindex $d 1] eq $sufikso} {
                set derivoj [lreplace $derivoj $i $i]
                return 1
            }
            incr i
        }
    }
    return 0
}
Radiko instproc havasFinon fino {
    if {![my exists derivoj]} {
        return 0
    }
    foreach d [my set derivoj] {
        if {[lindex $d 1] eq $fino} {
            return 1
        }
    }
    return 0
}
Radiko instproc havasPrefikso pre {
    if {![my exists derivoj]} {
        return 0
    }
    foreach d [my set derivoj] {
        if {[lindex $d 0] eq $pre} {
            return 1
        }
    }
    return 0
}
Radiko instproc konservu fileh {
    my instvar arto
    if {[info exists arto]} {
        puts $fileh "[my info class] create [self] -arto $arto"
    } else {
        puts $fileh "[my info class] create [self]"
    }
    foreach v [my info vars] {
        if {$v ne "arto"} {
            puts $fileh "[self] set $v [list [my set $v]]"
         }
    }
}
Radiko instproc metuDerivoAttr {pre suf def} {
    my instvar derivoj
    set i 0
    foreach d $derivoj {
        if {[lindex $d 0] eq $pre && [lindex $d 1] eq $suf} {
            if {[llength $d]==2} {
                lset derivoj $i [concat $d $def]
            } else {
                lset derivoj $i 2 $def
            }
            return 1
        }
        incr i
        update
    }
    return 0
}
Radiko instproc prenuDerivoj {} {
    set derv [list]
    if {![my exists derivoj]} {
        return [my prenuRadiko]
    }
    set radiko [my prenuRadiko]
    foreach d [my set derivoj] {
        lappend derv [join [list [lindex $d 0] $radiko [join [lindex $d 1] ""]] ""]
    }
    if {[Object isobject EsperantoConf] && [EsperantoConf set derivuEVortoj]} {
        if {[lsearch $derv ${radiko}e]<0} {
            lappend derv ${radiko}e
        }
    }
    return $derv
}
Radiko instproc prenuEblajVortoj {} {
    set rez [list]
    set radiko [my prenuRadiko]
    foreach ld [my prenuListDerivoj] {
        set d [lindex $ld 0]$radiko[lindex $ld 1]
        lappend rez $d
        set alt [list]
        switch [string index $d end] {
            o {
                set alt {oj on ojn}
            }
            a {
                set alt {aj an ajn}
            }
            i {
                set alt {as os is us u ita ata ota itan atan otan itaj ataj otaj itajn atajn otajn}
                if {[lsearch [lindex $ld 2] trans]>=0} {
                    lappend alt inta anta onta intan antan ontan intaj antaj ontaj intajn antajn ontajn ante onte inte
                }
            }
        }
        foreach a $alt {
             lappend rez [string range $d 0 end-1]$a
        }
    }
    return $rez
}
Radiko instproc prenuEblajVortoj2 {} {
    set rez [list]
    set radiko [my prenuRadiko]
    foreach ld [my prenuListDerivoj] {
        set vorto [lindex $ld 0]$radiko[lindex $ld 1]
        if {"pnomo" in [lindex $ld 2]} {
            set vorto [string toupper [string index $vorto 0]][string range $vorto 1 end]
        } elseif {[lindex $ld 0] eq "" && [lindex $ld 1] eq "o" && [my hasclass Propranono]} {
            if {![my ekzistasDerivo {} io] && ![my ekzistasDerivo {} ujo]} {
                set vorto [string toupper [string index $vorto 0]][string range $vorto 1 end]
            }
        }
        lappend rez $vorto
        set alt [list]
        switch [string index $vorto end] {
            o {
                set alt {}
            }
            a {
                set alt {}
            }
            i {
                set alt {}
                if {[lsearch [lindex $ld 2] trans]>=0 || [lindex $ld 1] eq "igi"} {
                    lappend alt ita ata ota
                }
            }
        }
        foreach a $alt {
             lappend rez [string range $vorto 0 end-1]$a
        }
    }
    return $rez
}
Radiko instproc prenuListDerivoj {} {
    if {![my exists derivoj]} {
        return
    }
    my set derivoj
}
Radiko instproc prenuPrefiksoj {} {
    set pre [list]
    foreach d [my prenuListDerivoj] {
        lappend pre [lindex $d 0]
    }
    lsort -unique $pre
}
Radiko instproc prenuRadiko {} {
    namespace tail [self]
}
Radiko instproc sxercxuDerivon vorto {
    set radiko [my prenuRadiko]
    foreach d [my prenuListDerivoj] {
        if {[join [list [lindex $d 0] $radiko [lindex $d 1]] ""] eq $vorto} {
            return $d
        }
        if {[string index [lindex $d 1] end] eq "j"} {
            if {[join [list [lindex $d 0] $radiko [string trimright [lindex $d 1] j]] ""] eq $vorto} {
                return $d
            }
        }
    }
    return
}
Radiko instproc sxercxuDerivonPS {pre suf} {
    set radiko [my prenuRadiko]
    foreach d [my prenuListDerivoj] {
        if {[lindex $d 0] eq $pre && [lindex $d 1] eq $suf} {
            return $d
        }
    }
    return
}
Radiko proc addDerivo args {
    # ignoru
}
Radiko proc aldonoPriskirboPorVortoj {priskribo vortoj} {
    set vortaro [Vortaro prenuVortaron]
    foreach vorto $vortoj {
        set vorto [string trim $vorto]
        if {$vorto eq ""} continue
        if {[$vortaro estasVorto $vorto]==2} {
            foreach {pre rad suf} [$vortaro prenuDerivoPropono] {}
            set radobj [Radiko pr $rad]
            if {$radobj ne ""} {
                set d [$radobj sxercxuDerivonPS $pre $suf]
                set gd [lindex $d 2]
                if {[lsearch -exact $d $priskribo]<0} {
                    puts "vorto $vorto + $priskribo"
                    $radobj metuDerivoAttr $pre $suf [concat $gd $priskribo]
                } else {
                    puts "vorto $vorto havas jam $priskribo"
                }
            } else {
                puts "radobj ne trovita $pre $rad $suf"
            }
        } else {
            puts "ne konata: $vorto"
        }
    }
}
Radiko proc chiojRadikoj {} {
    set r [list]
    foreach i [Radiko info children] {
        if {[$i istype Radiko]} {
            lappend r $i            
        }
    }
    return $r
}
Radiko proc clearAll {} {
    foreach i [my chiojRadikoj] {
        $i destroy
    }
}
Radiko proc doniDuoblajLiteroj {} {
    set ret [list]
    foreach i [Radiko info instances] {
        set radiko [$i prenuRadiko]
        if {![::esp::estasVokalo [string index $radiko 0]] && ![::esp::estasVokalo [string index $radiko 1]]} {
            ::ide::lappendIfNone ret [string range $radiko 0 1]
        }
    }
    lsort $ret
}
Radiko proc doniPrefiksoj {} {
    foreach i [Radiko info instances] {
        if {[$i exists derivoj]} {
            foreach der [$i set derivoj] {
                set prefikso [lindex $der 0]
                if {$prefikso ne ""} {
                    if {[catch {incr prefiksoj($prefikso)}]} {
                        set prefiksoj($prefikso) 1
                    }
                }
            }
        }
    }
    foreach {k v} [array get prefiksoj] {
        lappend ordoListo [list $k $v]
    }
    set ordoListo [lsort -index 1 -integer -decreasing $ordoListo]
    join $ordoListo \n
}
Radiko proc doniSufiksoj {} {
    foreach i [Radiko info instances] {
        if {[$i exists derivoj]} {
            foreach der [$i set derivoj] {
                foreach sufikso [lindex $der 1] {
                    if {[catch {incr sufiksoj($sufikso)}]} {
                        set sufiksoj($sufikso) 1
                    }
                }
            }
        }
    }
    foreach {k v} [array get sufiksoj] {
        lappend ordoListo [list $k $v]
    }
    set ordoListo [lsort -index 1 -integer -decreasing $ordoListo]
    join $ordoListo \n
}
Radiko proc eksportuEblajVortoj dosiero {
    set fileh [open $dosiero w]
    foreach i [my chiojRadikoj] {
        foreach v [$i prenuEblajVortoj] {
            puts $fileh $v
        }
    }
    close $fileh
}
Radiko proc eksportuEblajVortoj2 dosiero {
    set fileh [open $dosiero w]
    foreach i [my chiojRadikoj] {
        foreach v [$i prenuEblajVortoj2] {
            puts $fileh $v
        }
    }
    close $fileh
}
Radiko proc eksportuVortoj dosiero {
    set fileh [open $dosiero w]
    foreach i [my chiojRadikoj] {
        foreach v [$i prenuDerivoj] {
            puts $fileh $v
        }
    }
    close $fileh
}
Radiko proc eksportuXMLVortaro dosiero {
    set fileh [open $dosiero w]
    puts $fileh {<?xml version='1.0' encoding='utf-8'?>}
    puts $fileh {<vortaro>}
    puts $fileh "<!-- \n[EsperantoConf prenuPermesiloTekston]\n -->"
    foreach i [my chiojRadikoj] {
        $i eksportuKielXML $fileh
    }
    puts $fileh {</vortaro>}
    close $fileh
}
Radiko proc estuKutimaRadiko {} {
    # ignoru
}
Radiko proc estuPropraNomo {} {
    # ignoru
}
Radiko proc forigu {} {
    # ignoru
}
Radiko proc foriguDerivo args {
    # ignoru
}
Radiko proc importuLandonomojn nomoj {
    foreach l $nomoj {
        set l [string tolower $l]
        if {![::esp::enhavasEsparantajLiteroj $l]} {
            puts "nenio simpla nomo $l"
            continue
        }
        if {[string index $l end] eq "o"} {
            set radobj Radiko::[string tolower [string range $l 0 end-1]]
            if {![Object isobject $radobj]} {
                if {[string range $l end-1 end] eq "io"} {
                    set radobj Radiko::[string tolower [string range $l 0 end-2]]
                    if {[Object isobject $radobj]} {
                        if {![$radobj estasVorto $l]} {
                            if {![$radobj istype Propranono]} {
                                puts "!!! ne definita kiel propra nomo"
                                $radobj class Propranono
                            }
                            puts "aligi io al $radobj"
                            $radobj addDerivo {} {io}
                            $radobj addDerivo {} {a}
                        }
                    } else {
                        puts "krei $radobj kun io"
                        Propranono create $radobj
                        $radobj addDerivo {} {io}
                        $radobj addDerivo {} {a}
                    }
                } else {
                    if {[string first "lando" $l]<0} {
                        Propranono create $radobj
                        $radobj addDerivo {} {o}
                        $radobj addDerivo {} {a}
                    } else {
                        set radobj Radiko::[string range $l 0 [expr {[string first lando $l]-1}]]
                        if {![Object isobject $radobj]} {
                            Propranono create $radobj
                            $radobj addDerivo {} {lando}
                        }
                    }
                }
            }
        }
    }
}
Radiko proc importuRadikoArtoDeAkademioVortaro {} {
    set d {/home/artur/esperanto/fontoj/akademio-radikoj.txt}
    set f [open $d r]
    while {[gets $f line]>=0} {
        if {[string index $line 0] eq "#"} continue
        set vorto [lindex $line 1]
        if {[regexp {(\w+)/(\w+)} $vorto _ rad fino]} {
            set robj Radiko::$rad
            if {[lsearch {o a e i} $fino]>=0} {
                if {[Object isobject $robj]} {
                    $robj arto $fino
                }
            } else {
                puts "nekonata fino $fino"
            }
        } else {
            puts " nvorto $vorto"
        }
    }
    close $f
}
Radiko proc kalkuluStatistikon {} {
    set devNombro 0
    set radNombro 0
    foreach i [my chiojRadikoj] {
        incr radNombro
        incr devNombro [llength [$i prenuListDerivoj]]
    }
    return "rad: $radNombro dev: $devNombro"
}
Radiko proc konservuVortoj dosiero {
    set fileh [open $dosiero w]
    foreach i [my chiojRadikoj] {
        $i konservu $fileh
    }
    close $fileh
}
Radiko proc kreuRadiko radobj {
    if {![Object isobject $radobj]} {
        [self] create $radobj
    }
}
Radiko proc metuDerivoAttr args {
    # ignoru
}
@ Radiko proc pr {} {
description {Uzata por skribi privatan vortaron.
Ebigas uzi ankaux neniigitaj radikoj}
}
Radiko proc pr radiko {
    if {$radiko eq "slot"} {
        set radiko _slot
    }
    set radobj Radiko::$radiko
    if {[Object isobject $radobj]} {
        return $radobj
    }
    self
}
Radiko proc prenuDerivojPriskriboj {} {
    return {
        Substantivo {
            {pnomo {propra nomo}}
            {mod {priskribo per i-verbo}}
            {ident {priskribo per p. nomo}}
            {tempo {tempo}}
            {kvanto {kvanto}}
            {loko {loko}}
            {dif {difinita}}
        }
        Adjektivo {
            {mod {priskribo per i-verbo}}
            {pverbo {priskribas verbon}}
        }
        Adverbo {
            {mod {priskribo de adjektivo}}
            {imod {priskribo per i-verbo}}
            {tempo {tempo}}
            {certeco {certeco}}
        }
        Verbo {
            {trans {transitiva Verbo}}
            {muv {verbo signifas movigon}}
            {indobj {indirekta objekto}}
            {deobj {de objekto}}
            {sensub {sensubjekta verbo}}
            {rep {raportoverbo}}
            {scomp {substantiva priskribo}}
            {acomp {adjektiva priskribo}}
            {socomp {obj. substantiva priskribo}}
            {aocomp {obj. adjektiva prisktibo}}
            {mod {priskribo per i-verbo}}
            {objmod {objekto + i-verbo}}
        }
    }
}
Radiko proc prenuRad radiko {
    if {$radiko eq "slot"} {
        set radiko _slot
    }
    return Radiko::$radiko
}
Radiko proc puriguDatumaron {} {
    foreach rad [my chiojRadikoj] {
        set derivoj [list]
        if {![$rad exists derivoj]} continue
        foreach d [$rad set derivoj] {
            if {[llength $d]>3} {
                puts "$rad : $d : [concat [lrange $d 0 1] trans]"
                set d [concat [lrange $d 0 1] trans]
            }
            lappend derivoj $d
        }
        $rad set derivoj $derivoj
    }
}
Radiko proc sxercxiRadikojn mustero {
    set rez [list]
    if {[string first ? $mustero]>=0 || [string first * $mustero]>=0} {
        foreach r [my chiojRadikoj] {
            if {[string match $mustero [$r prenuRadiko]]} {
                lappend rez $r
            }
        }
    } else {
        set robj Radiko::$mustero
        if {[Object isobject $robj]} {
            lappend rez $robj
        }
    }
    return $rez
}
Radiko proc sxercxuKunPriskribo pri {
    set rez [list]
    foreach r [Radiko chiojRadikoj] {
         if {![$r exists derivoj]} {
             continue
         }
         foreach d [$r set derivoj] {
             if {[lsearch [lindex $d 2] $pri]>=0} {
                 lappend rez [join [list [lindex $d 0] [$r prenuRadiko] [join [lindex $d 1] ""]] ""]
             }
         }
    }
    return $rez
}
Radiko proc trovuDerivojKunSufikso suf {
    set derivoj [list]
    foreach i [Radiko info instances] {
        if {[$i exists derivoj]} {
            foreach der [$i set derivoj] {
                if {$suf eq [lindex $der 1]} {
                    lappend derivoj [lindex $der 0][$i prenuRadiko][lindex $der 1]
                }
            }
        }
    }
    return $derivoj
}
@ Class Pronomo {
description {La nomo de klaso estas falsa. La prava nomo estus "Vorteto"}
}
Class Pronomo -superclass ::Radiko -parameter {typNombro priskribo}
@ ::Pronomo idemeta component EspSintaksaAnalizo
Pronomo instproc estasVorto vorto {
    if {[my prenuRadiko] eq $vorto} {
        return 1
    }
    next
}
Pronomo instproc prenuDerivoj {} {
    if {[my exists derivoj]} {
        concat [my prenuRadiko] [next]
    } else {
        my prenuRadiko
    }

}
Pronomo instproc prenuListDerivoj {} {
    if {[my exists derivoj]} {
        linsert [next] 0 {{} {}}
    } else {
        list {{} {}}
    }

}
Pronomo instproc prenuTypo {} {
    if {[my exists typNombro]} {
        Pronomo nomoPorTypoNombro [my typNombro]
    } else {
        Pronomo nomoPorTypoNombro 0
    }
}
Pronomo proc cxiojPronomoj {} {
     my info instances
}
Pronomo proc cxiojPronomojPorTypo type {
     set id [lsearch [my prenuPrimitVortokTypoj] $type]
     if {$id<0} return
     set rez [list]
     foreach p [my cxiojPronomoj] {
         if {[$p exists typNombro] && [$p typNombro]==$id} {
             lappend rez [$p prenuRadiko]
         }
     }
     return $rez
}
Pronomo proc kreuRadiko radobj {
    if {![Object isobject $radobj]} {
        [self] create $radobj
    }
}
Pronomo proc nombroPorTypo typo {
    lsearch [my prenuPrimitVortokTypoj] $typo
}
Pronomo proc nomoPorTypoNombro nombro {
    lindex [my prenuPrimitVortokTypoj] $nombro
}
Pronomo proc prenuPrimitVortokTypoj {} {
     return {Nekonata Konjunkcio Interjekcio Numeralo Onomatopeo Prepozicio Subjunkcio PersonPronomo PosesivPronomo PrimitivaAdjektivo PrimitivaAdverbo Difinilo}
}
Pronomo proc sxercxiPronomoj {} {
    set personPronomoj [list mi ni vi li ŝi ĝi ni ili oni si]
    # TODO     pruvu cxiujn
    set rolvortetoj [list dum ĝis al anstataŭ antaŭ apud ĉe ĉirkaŭ da de dum ekster el en ĝis inter je kontraŭ krom kun laŭ malgraŭ per po por post preter pri pro sen sub super sur tra trans]
    set nombrajvortetoj [list unu du tri kvar kvin ses sep ok naŭ dek cent mil nul]
    set ekkriajvortetoj [list adiaŭ bis fi ha he ho hura nu ve ek]
    set dvortetoj [list ajn almenaŭ ankaŭ apenaŭ do eĉ ja jen jes kvazaŭ mem ne nur pli plej plimalpli preskaŭ tamen tre tro nun hodiaŭ morgaŭ jam ankoraŭ baldaŭ ĉi tuj ĵus plu for]
    # ankaux: dum, gxis, ol. sed ili havas kelkajn roloj
    set frazekondukajvortetoj [list ke ĉu se ĉar apenaŭ kvankam kvazaŭ]
    # kaj, sed estas ankaux frazekonduka
    set kunligajvortetoj [list kaj aŭ sed plus minus nek ol ju des]
    set definiloj [list la ambaŭ]
    foreach {listo typo} [list $rolvortetoj Prepozicio $nombrajvortetoj Numeralo $ekkriajvortetoj Onomatopeo $dvortetoj PrimitivaAdverbo $frazekondukajvortetoj Interjekcio $kunligajvortetoj Konjunkcio $definiloj Difinilo] {
        foreach p $listo {
            set radobj Radiko::$p
            if {[Object isobject $radobj]} {
                $radobj class Pronomo
                $radobj typNombro [Pronomo nombroPorTypo $typo]
            } else {
                puts "Primitiva Vorto '$p' ne estis trovita"
            }
        }
    }
    # alligi derivoj al personal pronomoj
    foreach p $personPronomoj {
        set radobj Radiko::$p
        if {[Object isobject $radobj]} {
            $radobj class Pronomo
            $radobj typNombro [Pronomo nombroPorTypo PersonPronomo]
            foreach suf {a an aj ajn n} {
                $radobj addDerivo {} $suf
            }
        } else {
            puts "Pronomo $p ne estis trovita"
        }
    }
    # kompilu tablelvortojn
    set tabvortoj [list ki ti i ĉi neni]
    set postpartoj [list u uj ujn un o on ojn oj a es e en am al el om oma]
    foreach p $tabvortoj {
        set radobj Radiko::$p
        if {![Object isobject $radobj]} {
            Pronomo create $radobj
        }
        foreach postparto $postpartoj {
            $radobj addDerivo {} $postparto
        }
    }
}
@ Class Propranono {
description {Radikoj, kiuj estas propraj nomoj. Ekzemple "varsovi", "german"}
}
Class Propranono -superclass ::Radiko
@ ::Propranono idemeta component EspSintaksaAnalizo
Propranono instproc estuKutimaRadiko args {
    my class Radiko
}
Propranono instproc estuPropraNomo {} {
    # mi estas jam
}
Propranono proc kreuRadiko radobj {
    if {![Object isobject $radobj]} {
        [self] create $radobj
    }
}
Class RadikoKonservadoMix
@ ::RadikoKonservadoMix idemeta component EspSintaksaAnalizo
RadikoKonservadoMix instproc addDerivo {prefikso sufikso} {
    set rez [next]
    [Vortaro prenuVortaron] konservuPrivatanDerivon [self] $prefikso $sufikso
    return $rez
}
RadikoKonservadoMix instproc estuKutimaRadiko {} {
    next
    [Vortaro prenuVortaron] konservuPrivatanRadikonEstuKutimaRadiko [self]
}
RadikoKonservadoMix instproc estuPropraNomo {} {
    next
    [Vortaro prenuVortaron] konservuPrivatanRadikonEstuPropraNomo [self]
}
RadikoKonservadoMix instproc forigu {} {
    next
    [Vortaro prenuVortaron] konservuPrivatanRadikonForigon [self]
}
RadikoKonservadoMix instproc foriguDerivo {prefikso sufikso} {
    set rez [next]
    [Vortaro prenuVortaron] konservuPrivatanDerivoForigon [self] $prefikso $sufikso
    return $rez
}
RadikoKonservadoMix instproc init {} {
    next
    [Vortaro prenuVortaron] konservuPrivatanRadikon [self]
}
RadikoKonservadoMix instproc metuDerivoAttr {prefikso sufikso disk} {
    next
    [Vortaro prenuVortaron] konservuPrivatanDerivoDiskribo [self] $prefikso $sufikso $disk
}
RadikoKonservadoMix proc malsxaltuPrivatanKonservadon {} {
    if {[Radiko info instmixin [self]] ne ""} {
        Radiko instmixin delete [self]
    }
    RadikoHunspellMix malsxaltuHunspellAligo
}
RadikoKonservadoMix proc sxaltuPrivatanKonservadon {} {
    Radiko instmixin add [self]
    RadikoHunspellMix sxaltuHunspellAligo
}
@ Class SANePluAnalizuMix {
description {Tiu mix ignoras la "analizu" komandon}
}
Class SANePluAnalizuMix
@ ::SANePluAnalizuMix idemeta component EspSintaksaAnalizo
SANePluAnalizuMix instproc analizu {} {
    # ignoru
}
@ Class SintaksAsto {
description {baza klaso por cxiuj sintaksaj astoj la klaso estas ankaux parenca klaso por cxiuj surbazoj}
}
Class SintaksAsto -superclass {::AstoElemento ::ArboAsto} -parameter {funkcio radiko}
@ ::SintaksAsto idemeta categories {init convert selektado graph-travers}
@ ::SintaksAsto idemeta categoriesMethods {init {asFormatedList asList asDOM} {match matchElem} initParencon}
@ ::SintaksAsto idemeta component EspSintaksaAnalizo
SintaksAsto instproc aliformuStrukturon {funkcio_p parenco pozicioKomenco pozicioFino postAktiono} {
    my instvar astoj funkcio
    set funkcio $funkcio_p
    set astoj [lrange [$parenco set astoj] $pozicioKomenco $pozicioFino]
    $parenco set astoj [lreplace [$parenco set astoj] $pozicioKomenco $pozicioFino [self]]
    my init
    if {$postAktiono ne ""} {
        my {*}$postAktiono
    }
}
SintaksAsto instproc analizu {} {
    foreach a [my astoj] {
        $a analizu
    }
}
SintaksAsto instproc asDOM doc {
    my instvar radiko
    set elem [$doc createElement [namespace tail [my info class]]]
    $elem setAttribute funkcio [my prenuFunkcioNomo]
    set astoj [$doc createElement astoj]
    $elem appendChild $astoj
    foreach e [my astoj] {
        set domElem [$e asDOM $doc]
        if {[my exists radiko] && $radiko eq $e} {
            $domElem setAttribute radiko 1
        }
        $astoj appendChild $domElem
    }
    return $elem
}
SintaksAsto instproc asFormatedList {{ident 0}} {
    set ret ""
    set identString [string repeat "    " $ident]
    append ret "$identString\{[my prenuSimbolo]:[my prenuFunkcioNomo]"
    foreach e [my astoj] {
        append ret "\n[$e asFormatedList [expr {$ident+1}]]"
    }
    append ret "\}"
    return $ret
}
SintaksAsto instproc asList {} {
    set ret [list]
    if {[my exists funkcio]} {
        lappend ret [my prenuSimbolo]:[my funkcio]
    } else {
        lappend ret [my prenuSimbolo]:parto
    }
    foreach e [my astoj] {
        lappend ret [$e asList]
    }
    return $ret
}
SintaksAsto instproc debugAnalizo {stupo poziciono mustero} {
    # uzo per mixin (vidu: SintaksAstoDebugMix)
}
SintaksAsto instproc drawGraph {} {
    SintaksCanvasGraf drawGraph [self] [my prenuVortoj]
}
SintaksAsto instproc estasBazaElemento {} {
    return 0
}
SintaksAsto instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto instproc estasNombraAkuzativa {} {
    my instvar astoj radiko
    expr {[[lindex $astoj 0] prenuRadiko] istype GP::Numeralo] &&
        [my estasAkuzativo]}
}
SintaksAsto instproc generuDiskripto rfrazo {
    set frazo [my info parent]
    set last [my prenuLastan]
    # Mi legas librojn, kiuj apartenas al homo, kiu loĝas tie.
    if {[my istype SintaksAsto::disk]} {
        set relradiko [[lindex [my astoj] end] prenuRelFrazoRadiko]
    } else {
        set relradiko [my prenuRelFrazoRadiko]
    }
    set dfunkcio disk
    if {[my exists funkcio]} {
        set dfunkcio [my set funkcio]
    }
    set f [SintaksAsto::disk new -childof $frazo -astoj [list $last $rfrazo] -funkcio $dfunkcio -relradiko $relradiko]

    set index [lsearch [my astoj] $last]
    if {$index<0} {
        set p [my sxercxiAsto asto {[lsearch [$asto astoj] $last]>=0}]
        if {$p eq ""} {
            error "neniu parenco"
        }
        set index [lsearch [$p astoj] $last]
    } else {
        set p [self]
    }
    $p instvar astoj
    set alt [lindex $astoj $index]
    lset astoj $index $f
    if {[$p exists radiko] && [$p set radiko] eq $alt} {
        $p set radiko $f
    }
    self
}
SintaksAsto instproc havasFunkcion {} {
    return 1
}
SintaksAsto instproc init {} {
}
SintaksAsto instproc initKunteksto parenco {
    #incr ::ikcount
    #if {$::ikcount>16} {
        #my halt
    #}
    #puts "initKunteksto [self] [my info class] $::ikcount"
    foreach a [my astoj] {
        $a initKunteksto [self]
    }
}
SintaksAsto instproc initParencon parenco {
    next
    if {![my exists funkcio]} {
        my funkcio parto
    }
}
SintaksAsto instproc konvenasMusteron mustero {
    my instvar astoj
    set sindekso 0
    set sukceso 1
    if {[llength $mustero]!=[llength $astoj]} {
        return 0
    }
    foreach e $mustero {
        set elemento [lindex $astoj $sindekso]
        regsub %e $e $elemento e
        if {[string index $e 0] eq ":"} {
            if {![$elemento testuStrukturo $e]} {
                set sukceso 0
                break
            }
        } else {
            if {![$elemento testuSintakso $e]} {
                set sukceso 0
                break
            }
        }
        incr sindekso
    }
    return $sukceso
}
@ SintaksAsto instproc kunliguRilativanFrazonAl {} {
description {aligas al elemento aux strukturo strukture priskibo ("disk")}
}
SintaksAsto instproc kunliguRilativanFrazonAl {rfrazo lelem} {
    if {[$lelem istype GP::Elemento]} {
        set frazo [my info parent]
        set d [SintaksAsto::disk new -childof $rfrazo -astoj [list $lelem $rfrazo] -funkcio disk -relradiko $lelem]
        set lastIndex [lsearch [my astoj] $lelem]
        my instvar astoj
        lset astoj $lastIndex $d
    } else {
        $lelem generuDiskripto $rfrazo
    }
}
SintaksAsto instproc match expr {
    switch -exact -- [lindex $expr 0] {
        folioj {
            set elementoj [my prenuFoliojn]
        }
        elementoj {
            set elementoj [my prenuElementoj]
        }
        infanoj {
            set elementoj [my astoj]
        }
        brancxoj {
            set elementoj [my prenuBrancxoj]
        }
        default {
            error "ne konata selektilo [lindex $expr 0]"
        }
    }
    set expr [lindex $expr 1]
    set startmatch 0
    set len [expr {[llength $expr]/2}]
    set wlen [llength $elementoj]
    set found -1
    while {$startmatch+$len<=$wlen} {
        set m 0
        foreach {tipo evaluo} $expr {
            set elem [lindex $elementoj [expr {$startmatch+$m}]]
            if {![$elem matchElem $tipo $evaluo]} {
                break
            }
            incr m
        }
        if {$m==$len} {
            set found $startmatch
            break
        }
        incr startmatch
    }
    if {$found>=0} {
        return [lrange $elementoj $startmatch [expr {$startmatch+$len-1}]]
    }
    return
}
SintaksAsto instproc matchElem {tipo evaluo} {
    switch -exact -- $tipo {
        f {
            set funkcio [my prenuFunkcioNomo]
            if {$funkcio eq $evaluo} {
                return 1
            }
        }
        fr {
            set funkcio [my prenuFunkcioNomo]
            if {[regexp $evaluo $funkcio]} {
                return 1
            }
        }
        s {
            set funkcio [my prenuSimbolo]
            if {$funkcio eq $evaluo} {
                return 1
            }
        }
        sr {
            set funkcio [my prenuSimbolo]
            if {[regexp $evaluo $funkcio]} {
                return 1
            }
        }
        AND {
            foreach {t v} $evaluo {
                if {![my matchElem $t $v]} {
                    return 0
                }
            }
            return 1
        }
        NOT {
           if {[my matchElem [lindex $evaluo 0] [lindex $evaluo 1]]} {
               return 0
           } else {
               return 1
           }
        }
        OR {
            foreach {t v} $evaluo {
                if {[my matchElem $t $v]} {
                    return 1
                }
            }
            return 0
        }
        match {
            if {[llength [my match $evaluo]]>0} {
                return 1
            }
        }
        radiko {
            return [[my miAuxRadikaElemento] matchElem [lindex $evaluo 0] [lindex $evaluo 1]]
        }
        parenco {
            if {[my parenco] ne ""} {
                return [[my parenco] matchElem [lindex $evaluo 0] [lindex $evaluo 1]]
            }

        }
    }
    return 0
}
SintaksAsto instproc miAuxRadikaElemento {} {
    my instvar funkcio parenco
    if {$parenco eq "" || ![info exists funkcio] || ($funkcio ne "radiko" && $funkcio ne "disk")} {
       self
    } else {
       $parenco miAuxRadikaElemento
    }
}
SintaksAsto instproc prenuCxefRadiko {} {
    self
}
SintaksAsto instproc prenuCxefajElementoj {} {
    set elementoj [list]
    foreach a [my astoj] {
        if {[$a istype SintaksAsto]} {
            foreach e [$a prenuCxefajElementoj] {
                lappend elementoj $e
            }
        } else {
            lappend elementoj $a
        }
    }
    return $elementoj
}
SintaksAsto instproc prenuCxefajVortoj {} {
    set vortoj [list]
    foreach a [my prenuCxefajElementoj] {
        lappend vortoj [$a vorto]
    }
    return $vortoj
}
SintaksAsto instproc prenuFinon {} {
    [lindex [my astoj] end] prenuFinon
}
SintaksAsto instproc prenuFunkcioNomo {} {
    if {[my exists funkcio]} {
        my funkcio
    } else {
        return "nekonata"
    }
}
SintaksAsto instproc prenuKazon {} {
    foreach e [my astoj] {
        if {[$e hasclass ::GP::NombroKazo]} {
            return [$e kazo]
        }
    }
    return
}
SintaksAsto instproc prenuKomencon {} {
    [lindex [my astoj] 0] prenuKomencon
}
SintaksAsto instproc prenuListon {} {
    set ret [list]
    foreach e [my astoj] {
        lappend ret [$e prenuListon]
    }
    list [my prenuSimbolo]:[my prenuFunkcioNomo] $ret
}
SintaksAsto instproc prenuNombron {} {
    [my radiko] prenuNombron
}
SintaksAsto instproc prenuNomo {} {
    namespace tail [my info class]
}
SintaksAsto instproc prenuRadiko {} {
    if {[my exists radiko] && [my radiko] ne ""} {
        [my radiko] prenuRadiko
    } else {
        return
    }
}
@ SintaksAsto instproc prenuRelFrazoRadiko {} {
description {Elemento, al kiu oni kunligas rilativan subfrazon.
Normale la lasta elemento (Substantivo)

La granda -libro-, kiu estas la plej granda, estas tre malnova.}
}
SintaksAsto instproc prenuRelFrazoRadiko {} {
   [lindex [my astoj] end] prenuRelFrazoRadiko
}
SintaksAsto instproc prenuSimbolo {} {
    namespace tail [my info class]
}
SintaksAsto instproc prenuSubsupRadiko {} {
    return
}
SintaksAsto instproc prenuVerbRadiko {} {
    my prenuRadiko
}
SintaksAsto instproc prenuVortoj {} {
    set vortoj [list]
    foreach a [my prenuFoliojn] {
        lappend vortoj [$a vorto]
    }
    return $vortoj
}
SintaksAsto instproc printString {} {
    return "[my prenuFunkcioNomo] [my prenuSimbolo]: [my prenuVortoj]"
}
SintaksAsto instproc sxercxiCxefrazoj {} {
    foreach a [my astoj] {
        if {[$a hasclass SintaksAsto]} {
            $a sxercxiCxefrazoj
        }
    }
}
SintaksAsto instproc sxercxiDialogoPriskribo {} {
    foreach a [my astoj] {
        if {[$a hasclass SintaksAsto]} {
            $a sxercxiDialogoPriskribo
        }
    }
}
SintaksAsto instproc sxercxiErarojn kolektilo {
    foreach e [my astoj] {
        $e sxercxiErarojn $kolektilo
    }
}
SintaksAsto instproc sxercxiFrazokapon {} {
    foreach a [my astoj] {
        $a sxercxiFrazokapon
    }
}
SintaksAsto instproc sxercxiKompleksajSubjektivanSuplementon {} {
}
SintaksAsto instproc sxercxiPlenajFrazoj {} {
    foreach a [my astoj] {
        if {[$a hasclass SintaksAsto]} {
            $a sxercxiPlenajFrazoj
        }
    }
}
SintaksAsto instproc testuSintakso elem {
    [my prenuRadiko] testuSintakso $elem
}
@ SintaksAsto instproc testuStrukturo {} {
description {La metode estas uzata por "chunking" li enmetas
novan strukturon}
}
SintaksAsto instproc testuStrukturo elem {
    set cname [namespace tail [my info class]]
    #puts "testuStrukturo [self] $elem"
    if {[string range [lindex $elem 0] 1 end] ne $cname} {
        return 0
    }
    if {[llength $elem]>1} {
        return [my {*}[lrange $elem 1 end]]
    }
    return 1
}
SintaksAsto instproc trovuKunFunkcio funkcio {
    my instvar astoj
    foreach a $astoj  {
        if {[$a exists funkcio] && [$a set funkcio] eq $funkcio} {
            return $a
        }
    }
    return
}
SintaksAsto instproc trovuMainVerboAston {} {
    my trovuUnuanPerenconKiu par {[$par hasclass SintaksAsto::main] || [$par hasclass SintaksAsto::nfvp]}
}
@ Class SintaksAsto::adjp {
description {Adjektivo subfrazo; ekzemplo:
''tre alta''}
}
Class SintaksAsto::adjp -superclass ::SintaksAsto
@ ::SintaksAsto::adjp idemeta component EspSintaksaAnalizo
SintaksAsto::adjp instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::adjp instproc estasPartizipa {} {
    [[my radiko] prenuRadiko] ismixin GP::Partizipo
}
SintaksAsto::adjp instproc estasPlej {} {
    my instvar astoj
    expr {[[[lindex $astoj 1] prenuRadiko] prenuVorton] eq "plej"}
}
SintaksAsto::adjp instproc init {} {
    my instvar astoj
    foreach e $astoj {
        set robj [$e prenuRadiko]
        if {[$robj hasclass GP::Adjektivo] || [$robj istype SintaksAsto::padj]} {
            my radiko $e
            $e set funkcio radiko
            break
        }
    }
}
SintaksAsto::adjp instproc initKunteksto parenco {
    my instvar estasInit
    if {[info exists estasInit]} {
        return
    }
    # pritraktu partizipaj adjektivoj kiel priskriboj por substantivoj
    # ekz: libroj skribitaj de grandaj homoj
    if {![$parenco istype SintaksAsto::disk] && [my estasPartizipa]} {
        set mindekso [lsearch [$parenco astoj] [self]]
        if {$mindekso>0} {
            set lasta [lindex [$parenco astoj] [expr {$mindekso-1}]]
            set lasta [$lasta prenuLastan]
            if {[$lasta hasclass GP::Substantivo]} {
                set frazo [my info parent]
                $parenco debugAnalizo 0 $mindekso "adjp - subsup"
                set f [SintaksAsto::subsup new -childof $frazo -astoj [list $lasta [self]] -radiko $lasta -funkcio [$lasta prenuFunkcioNomo]]
                set index [lsearch [$parenco astoj] $lasta]
                if {$index<0} {
                    set p [$parenco sxercxiAsto asto {[lsearch [$asto set astoj] $lasta]>=0}]
                    if {$p eq ""} {
                        error "parenco ne trovita $parenco"
                    }
                } else {
                    set p $parenco
                }
                $p intersxangxiElementoj $lasta $f
                $parenco foriguElemento [self]
            }
        }
    }
    set estasInit 1
    next
}
SintaksAsto::adjp instproc prenuKazon {} {
    [my prenuRadiko] prenuKazon
}
SintaksAsto::adjp instproc prenuNombron {} {
    [my prenuRadiko] prenuNombron
}
SintaksAsto::adjp instproc prenuNomo {} {
    return Adjektivo
}
SintaksAsto::adjp instproc sxercxiErarojn kolektilo {
    next
    my instvar parenco radiko
    if {[$parenco istype SintaksAsto::main]} {
        set subj [$parenco prenuSubjekton]
        if {$subj eq ""} {
            set defElemento [my miAuxRadikaElemento]
            set kparenco [$defElemento set parenco]
            if {![$kparenco estasOrdonoSenSubjekto]  && [$kparenco prenuNeInfVerbo] ne ""} {
                $kolektilo aliguEraron [my prenuRadiko] "nur adverboj povas priskribi sensubjektajn frazojn" [string range [[my prenuRadiko] prenuBazanFormon] 0 end-1]e
            }
            return
        } elseif {[[$subj prenuRadiko] istype GP::Verbo]} {
            $kolektilo aliguEraron [my prenuRadiko] "nur adverboj povas priskribi i-verbon" [string range [[my prenuRadiko] prenuBazanFormon] 0 end-1]e
        }
        set radobj [$radiko prenuRadiko]
        set kazo [$radobj kazo]
        if {$kazo eq "akuzativo"} {
            $kolektilo aliguEraron [my prenuRadiko] "priskriboj de substantivo nur en nominativo" [esp::prenuKazoNombro [$radobj prenuBazanFormon] 0 [expr {$radobj eq "pluralo"}]]
        }
        # sama kontrolo en Adjektivo
        #set subNombro [$subj prenuNombron]
        #if {[$radobj nombro] ne $subNombro} {
        #    $kolektilo aliguEraron $radobj "nombro de adjektivo kaj substantivo ne similas" [esp::prenuKazoNombro [$radobj prenuBazanFormonKazoNombro] 0 [expr {$subNombro eq "pluralo"}]]
        #}
    }
}
SintaksAsto::adjp instproc sxercxiFrazokapon {} {
    # sercxi lokaj objektoj
    next
    my instvar astoj radiko
    if {![info exists radiko] || ![$radiko hasclass GP::Partizipo]} {
        return
    }
    set radobj [$radiko prenuRadiko]

    set havisObjekton 0
    set havisIndirektanObjekton 0

    set estasKomenco 1
    set initListo [list]
    foreach e $astoj {
        set eobj [$e prenuRadiko]
        if {[$eobj hasclass GP::Substantivo]} {
            if {[$eobj prenuKazon] eq "akuzativo"} {
                if {[$eobj istype GP::Substantivo] && [$eobj estasTempo]} {
                    $e funkcio tempo
                } elseif {[$eobj istype GP::Substantivo] && [$eobj estasLongeco]} {
                    $e funkcio long
                } elseif {[$radobj havasDerivoPriskribon muv] && [$eobj istype GP::Substantivo] && [$eobj estasLoko]} {
                    $e funkcio direkto
                } else {
                    if {!$havisObjekton} {
                        set havisObjekton 1
                        $e funkcio obj
                    }
                }
            }
            continue
        }
        if {[$e prenuNomo] eq "Adverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e prenuNomo] eq "PrimAdverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e istype SintaksAsto::subsup]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$e hasclass SintaksAsto::advsup] && [$e eblasKielSubstantivo]} {
            $e set funkcio obj
            set havisObjekton 1
            continue
        }
        if {[$eobj hasclass GP::Adverbo]} {
            $e funkcio adv
            continue
        }
    }
}
@ Class SintaksAsto::adjsup {
description {Suplemento de adjektivo
ekz. ''plena de akvo''
radiko restas adjektivo plena
suplemento estas tie cxi prepozicia subfrazo}
}
Class SintaksAsto::adjsup -superclass ::SintaksAsto
@ ::SintaksAsto::adjsup idemeta component EspSintaksaAnalizo
SintaksAsto::adjsup instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::adjsup instproc estasPadj {} {
    my instvar radiko
    $radiko hasclass SintaksAsto::padj
}
SintaksAsto::adjsup instproc init {} {
    my instvar astoj
    foreach e $astoj {
        set robj [$e prenuRadiko]
        if {[$robj hasclass GP::Adjektivo] || [$robj istype SintaksAsto::padj]} {
            my radiko $e
            $e set funkcio radiko
            break
        }
    }
}
SintaksAsto::adjsup instproc initKunteksto parenco {
    next
    my instvar astoj radiko
    if {[lindex $astoj 0] eq $radiko} {
        # ekz. plena de akvo
        [lindex $astoj end] set funkcio apos
    }
}
@ Class SintaksAsto::advp {
description {Adverbo suffrazo; ekzemplo:
''tre rapide''}
}
Class SintaksAsto::advp -superclass ::SintaksAsto
@ ::SintaksAsto::advp idemeta component EspSintaksaAnalizo
SintaksAsto::advp instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::advp instproc estuTempo {} {
    # gxis nun
    my aliguMerkmalon tempo
}
SintaksAsto::advp instproc estusTempo {} {
    # gxis nun
    my aliguMerkmalon tempo
}
SintaksAsto::advp instproc init {} {
    my instvar astoj
    for {set x [expr {[llength $astoj]-1}]} {$x>=0} {incr x -1} {
        set e [lindex $astoj $x]
        set re [$e prenuRadiko]
        # primitivaj adveboj havas nur konvenan nomon !!!
        if {[$re hasclass GP::Adverbo] || [$re prenuNomo] eq "Adverbo" || [$re istype SintaksAsto::padv]} {
            my radiko $e
            $e set funkcio radiko
            return
        }
    }
    # !!! HACK
    my radiko [lindex $astoj end]
}
SintaksAsto::advp instproc prenuNomo {} {
    return Adverbo
}
SintaksAsto::advp instproc sxercxiFrazokapon {} {
    # sercxi lokaj objektoj
    next
    my instvar astoj radiko
    if {![info exists radiko] || ![$radiko hasclass GP::Partizipo]} {
        return
    }
    set radobj [$radiko prenuRadiko]

    set havisObjekton 0
    set havisIndirektanObjekton 0

    set estasKomenco 1
    set initListo [list]
    foreach e $astoj {
        set eobj [$e prenuRadiko]
        if {[$eobj hasclass GP::Substantivo]} {
            if {[$eobj prenuKazon] eq "akuzativo"} {
                if {[$eobj istype GP::Substantivo] && [$eobj estasTempo]} {
                    $e funkcio tempo
                } elseif {[$eobj istype GP::Substantivo] && [$eobj estasLongeco]} {
                    $e funkcio long
                } elseif {[$radobj havasDerivoPriskribon muv] && [$eobj istype GP::Substantivo] && [$eobj estasLoko]} {
                    $e funkcio direkto
                } else {
                    if {!$havisObjekton} {
                        set havisObjekton 1
                        $e funkcio obj
                    }
                }
            }
            continue
        }
        if {[$e prenuNomo] eq "Adverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e prenuNomo] eq "PrimAdverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e istype SintaksAsto::subsup]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$e hasclass SintaksAsto::advsup] && [$e eblasKielSubstantivo]} {
            $e set funkcio obj
            set havisObjekton 1
            continue
        }
        if {[$eobj hasclass GP::Adverbo]} {
            $e funkcio adv
            continue
        }
    }
}
@ Class SintaksAsto::advsup {
description {adverba suplemento
ekz: ''kaze de malvenko''}
}
Class SintaksAsto::advsup -superclass ::SintaksAsto
@ ::SintaksAsto::advsup idemeta component EspSintaksaAnalizo
@ SintaksAsto::advsup instproc eblasKielSubstantivo {} {
description {Frazpartoj de tipo: multe da ...}
}
SintaksAsto::advsup instproc eblasKielSubstantivo {} {
    my instvar eblasKielSubstantivo astoj
    if {![info exists eblasKielSubstantivo]} {
        set rad [my prenuRadiko]
        set pp [my selektu {1 prenuRadiko prenuVorton}]
        set eblasKielSubstantivo [expr {((([$rad hasclass GP::Adverbo] || [$rad hasclass GP::PrimitivaAdverbo]) && [$rad estasDaSubj]) || ([$rad istype GP::TabloVorto] && [$rad estasArto om])) && $pp eq "da"}]
    }
    return $eblasKielSubstantivo
}
SintaksAsto::advsup instproc estasKuneblaj {elem ligilo stupo} {
    expr {[my prenuNomo] eq [$elem prenuNomo]}
}
SintaksAsto::advsup instproc estasTempo {} {
    # iom da tempo
    set sobj [my prenuRelFrazoRadiko]
    expr {$sobj ne "" && [$sobj istype GP::Substantivo] && [$sobj estasTempo]}
}
SintaksAsto::advsup instproc init {} {
    my instvar astoj eblasKielSubstantivo
    my radiko [lindex $astoj 0]
    [my radiko] set funkcio radiko
    my eblasKielSubstantivo
    if {$eblasKielSubstantivo} {
        [my radiko] proc prenuNombron {} { return pluralo }
    }
}
SintaksAsto::advsup instproc initKunteksto parenco {
    next
    my instvar astoj
    [lindex $astoj end] set funkcio epos
}
@ Class SintaksAsto::amain {
description {abstrakta klaso por struktura analizo.
povas grupigi vortoj laux 0 nivelo}
}
Class SintaksAsto::amain -superclass ::SintaksAsto
@ ::SintaksAsto::amain idemeta categories {gramatika-analizo testado}
@ ::SintaksAsto::amain idemeta categoriesMethods {{sxangxGrandskribitajNekonatajAlKonstantoj sxangxKonstantojAlSubstantivoj sxangxUTablovortojAlSubstantivoj sxercxiSubfrazoj sxercxiKompleksajSubjektivanSuplementon sxercxuAdjSuplementoj kunliguKonjunkcioj kunliguDuoblajKonjunkcioj analizu} {kielNeDemando nePostKomo sekvasSubstantivo nurBazajElementoj samaNombroKazo}}
@ ::SintaksAsto::amain idemeta component EspSintaksaAnalizo
SintaksAsto::amain instproc analizu {} {
    next
    for {set stupo 0} {$stupo<=3} {incr stupo} {
        set nbr 0
        if {$stupo==0} {
            my sxangxGrandskribitajNekonatajAlKonstantoj
        }
        if {$stupo==1} {
            my sxangxKonstantojAlSubstantivoj
        }
        if {$stupo==2} {
            my sxangxUTablovortojAlSubstantivoj
        }
        while {[my kunliguDuoblajKonjunkcioj $stupo] && $nbr<100} {
            incr nbr
        }
        set estasKunligo 0
        while {[my kunliguKonjunkcioj $stupo] && $nbr<100} {
            set estasKunligo 1
            incr nbr
        }
        if {$estasKunligo && $stupo==2} {
            set stupo 1
        }
        if {$nbr>=100} {
            error "eventaula senfinajxo cxe sintaksa analizo"
        }
        set nbr 0
        #TempoMezurilo startuMezurilon sxercxiSubfrazoj
        #TempoMezurilo startuMezurilon sxercxiSubfrazoj_$stupo
        if {$stupo==0} {
            my sxercxiSubfrazoj 5
        }
        while {[set subFrazoAnalizoRez [my sxercxiSubfrazoj $stupo]]==1 && $nbr<100} {
            incr nbr
        }
        if {$stupo==3} {
            if {[my sxercxuAdjSuplementoj]} {
                incr stupo -3
                continue
            }
        }
        #TempoMezurilo malstartuMezurilon sxercxiSubfrazoj_$stupo
        #TempoMezurilo malstartuMezurilon sxercxiSubfrazoj
        if {$subFrazoAnalizoRez==2} {
            incr stupo -3
            continue
        }
        if {$subFrazoAnalizoRez==3} {
            incr stupo -3
            continue
        }
        if {$nbr>=100} {
            error "eventaula senfinajxo cxe sintaksa analizo"
        }
    }
}
SintaksAsto::amain instproc kielNeDemando elementoj {
    my instvar astoj
    set k [lindex $elementoj 0]
    # Ekzemple: Kiel vi tion faris?
    # !!! TODO ne ekzakta
    set i [lsearch $astoj $k]
    if {$i==0} {
        return 0
    }
    # Mi ne scis, kiel vi tion faris?
    if {$i>0 && [[set k [lindex $astoj [expr {$i-1}]]] istype GP::Simbolo] && [$k estasVorto ,]} {
        return 0
    }
    return 1
}
@ SintaksAsto::amain instproc kunliguDuoblajKonjunkcioj {} {
description {funkcio sxercas konjunkciaj frazoj laux modele
  nek rugxa nek blua
  kaj mi kaj vi}
}
SintaksAsto::amain instproc kunliguDuoblajKonjunkcioj {{stupo -1}} {
    set frazo [my info parent]
    my instvar astoj
    for {set x 0} {$x<[llength $astoj]-3} {incr x} {
        foreach {elem1 elem2 elem3 elem4} [lrange $astoj $x [expr {$x+3}]] {}
        if {[$elem1 istype GP::Konjunkcio] && [$elem3 istype GP::Konjunkcio] && [$elem1 estasDuobla] && [$elem1 prenuVorton] eq [$elem3 prenuVorton]} {
            if {[$elem2 estasKuneblaj $elem4 [$elem1 vorto] $stupo]} {
                my debugAnalizo 0 $x "kunligi duopajn"
                set tastoj [lrange $astoj $x [expr {$x+3}]]
                set a [SintaksAsto::konj new -childof $frazo -astoj $tastoj -funkcio fkonj]
                set astoj [lreplace $astoj $x [expr {$x+3}] $a]
                return 1
            }
        }
    }
    return 0
}
SintaksAsto::amain instproc kunliguKonjunkcioj {{stupo -1}} {
    set frazo [my info parent]
    my instvar astoj
    for {set x 1} {$x<[llength $astoj]-1} {incr x} {
        set elem [lindex $astoj $x]
        if {[$elem istype GP::Konjunkcio] && [$elem estasSimetria]} {
            if {[[lindex $astoj [expr {$x-1}]] estasKuneblaj [lindex $astoj [expr {$x+1}]] [$elem vorto] $stupo]} {
                my debugAnalizo 0 $x "kunligi"
                set tastoj [lrange $astoj [expr {$x-1}] [expr {$x+1}]]
                set a [SintaksAsto::konj new -childof $frazo -astoj $tastoj -funkcio fkonj]
                set astoj [lreplace $astoj [expr {$x-1}] [expr {$x+1}] $a]
                return 1
            }
        }
        if {[$elem istype GP::Simbolo] && [$elem vorto] eq ","} {
            set emd [lindex $astoj [expr {$x-1}]]
            set ed [lindex $astoj [expr {$x+1}]]
            if {[$ed istype SintaksAsto::konj] && [$emd estasKuneblaj $ed , $stupo]} {
                my debugAnalizo 0 $x "kunligi komon"
                set tastoj [lrange $astoj [expr {$x-1}] [expr {$x+1}]]
                set a [SintaksAsto::konj new -childof $frazo -astoj $tastoj -funkcio fkonj]
                set astoj [lreplace $astoj [expr {$x-1}] [expr {$x+1}] $a]
                return 1
            }
        }
    }
    return 0
}
SintaksAsto::amain instproc nePostKomo elementoj {
    my instvar astoj
    set k [lindex $elementoj 0]
    set i [lsearch $astoj $k]
    # Mi laboris, kvazaux mi estis lacxa?
    if {$i>0 && [[set k [lindex $astoj [expr {$i-1}]]] istype GP::Simbolo] && [$k estasVorto ,]} {
        return 0
    }
    return 1
}
SintaksAsto::amain instproc nurBazajElementoj elemtoj {
    foreach e $elemtoj {
        if {![$e estasBazaElemento]} {
            return 0
        }
    }
    return 1
}
SintaksAsto::amain instproc samaNombroKazo elemtoj {
    set kazo ""
    set nombro ""
    foreach e $elemtoj {
        if {[$e istype SintaksAsto::kadv]} {
            # kiel homo
            set rad [$e selektu {1 prenuRadiko}]
        } else {
            set rad [$e prenuRadiko]
        }
        if {[$e istype SintaksAsto::konj]} {
            set nradiko $e
        } else {
            set nradiko $rad
        }
        if {$kazo eq ""} {
            set kazo [$rad prenuKazon]
            set nombro [$nradiko prenuNombron]
            continue
        }
        if {$kazo ne [$rad prenuKazon] || $nombro ne [$nradiko prenuNombron]} {
            return 0
        }
    }
    return 1
}
SintaksAsto::amain instproc sekvasSubstantivo elementoj {
    my instvar astoj
    my initParencon ""
    # por
    # la nenion faranta homo
    # post "faranta" devas estas substantivo
    # pro
    # mi opinias la taskon funkcianta
    set elem [lindex $elementoj end]
    set selem [$elem prenuSekvaElemento]
    if {$selem ne "" && [[$selem prenuUnuan] istype GP::Substantivo]} {
        return 1
    }
    return 0
}
SintaksAsto::amain instproc sxangxGrandskribitajNekonatajAlKonstantoj {} {
    my instvar astoj
    # Nomoj estas grandskribitaj
    foreach ba $astoj {
        set a [$ba prenuCxefRadiko]
        if {[$a istype GP::Nekonata] && [$a estasUnuaGrandSkribita]} {
            $a class GP::Konstanto
        }
    }
}
SintaksAsto::amain instproc sxangxKonstantojAlSubstantivoj {} {
    my instvar astoj
    foreach ba $astoj {
        set a [$ba prenuCxefRadiko]
        if {[$a istype GP::Konstanto]} {
            $a mixin add GP::Substantivo
            $a kazo nominativo
            $a nombro singularo
        } elseif {[$a istype SintaksAsto::konj]} {
            set r [$a prenuRadiko]
            if {[$r istype GP::Konstanto]} {
                $r mixin add GP::Substantivo
                $r kazo nominativo
                $r nombro singularo
            }
        }
    }
}
SintaksAsto::amain instproc sxangxUTablovortojAlSubstantivoj {} {
    my instvar astoj
    foreach ba $astoj {
        set a [$ba prenuCxefRadiko]
        if {[$a istype GP::TabloVorto] && [$a arto] in {u a}} {
            $a estuSubstantiva
            continue
        }
        if {[$a istype SintaksAsto::grupo] || [$a istype SintaksAsto::ne]} {
            if {[[$a prenuRadiko] istype GP::TabloVorto]
            && [[$a prenuRadiko] arto] eq "u"} {
                [$a prenuRadiko] estuSubstantiva
                continue
            }
        }
        if {[$a istype GP::Difinilo] && [string tolower [$a vorto]] eq "ambaŭ"} {
            $a class GP::Substantivo
            $a kazo nominativo
            $a nombro pluralo
            continue
        }
        if {[$a istype GP::Adjektivo]} {
            if {[$a estasBazajVortoj {multa kelka alia pluraj plura malmulta nemulta ĉi-lasta tiulasta}]} {
                $a class GP::Substantivo
                continue
            }
        } else {
            # tre multaj, tro multaj, ne multaj
            set rad [$a prenuRadiko]
            if {[$rad estasBazajVortoj {multa malmulta kelka}]} {
                $rad class GP::Substantivo
                continue
            }

        }

        # unuj unujn
        # sed ne "unu"
        # problemo "unu" ne havas akuzativon
        # mi legis unu el libroj.
        if {[$a istype GP::Numeralo] && [$a estasBasaVorto unu]} {
            $a class GP::Substantivo
            $a set radiko Radiko::unu
            set finajxo ""
            regexp {jn?$} [$a set vorto] finajxo
            $a ekkoniFinajxo $finajxo
            if {[$a estasVorto unu]} {
                # Mi vidis unu
                $a aliguMerkmalon eblaakuzativo
            }
        }
    }
}
SintaksAsto::amain instproc sxercxiKompleksajSubjektivanSuplementon {} {
    my instvar astoj
    set nefino 1
    set frazo [my info parent]
    while {$nefino} {
        set aindekso 0
        set nefino 0
        foreach asto $astoj sekva [lrange $astoj 1 end] {
            if {$sekva eq ""} break
            set lasta [$asto prenuLastan]
            if {[$lasta hasclass GP::Substantivo]} {
                if {[$sekva istype SintaksAsto::pp]} {
                    set substantivo [$lasta prenuBazanFormon]
                    set pprep [[$sekva prenuRadiko] prenuVorton]
                    # homo kun kiu
                    set npradiko [[$sekva prenuNPParton] prenuRadiko]
                    if {[$npradiko istype GP::TabloVorto] && [$npradiko estasBazo ki]} continue
                    set supSubstantivo [$npradiko prenuBazanFormon]
                    if {[SubsSuplAnalizilo estasSubSuplemento $substantivo $pprep $supSubstantivo]} {
                        my debugAnalizo 0 $aindekso "subsup"
                        set a [SintaksAsto::subsup new -childof $frazo -astoj [list $lasta $sekva]]
                        set lparenco [$lasta parenco]
                        $lparenco tausxuAstoj $lasta $a
                        if {[$lparenco exists radiko] && [$lparenco set radiko] eq $lasta} {
                            $lparenco set radiko $a
                            $a set funkcio radiko
                        }
                        my foriguElemento $sekva
                        set nefino 1
                        break
                    }
                } elseif {[$sekva istype SintaksAsto::konj] && [[$sekva set radiko] istype SintaksAsto::pp]} {
                    set substantivo [$lasta prenuBazanFormon]
                    set pprep [[$sekva prenuRadiko] prenuVorton]
                    set supSubstantivo [[[[$sekva set radiko] prenuNPParton] prenuRadiko] prenuBazanFormon]
                    if {[SubsSuplAnalizilo estasSubSuplemento $substantivo $pprep $supSubstantivo]} {
                        my debugAnalizo 0 $aindekso "subsup konj"
                        set a [SintaksAsto::subsup new -childof $frazo -astoj [list $lasta $sekva]]
                        set lparenco [$lasta parenco]
                        $lparenco tausxuAstoj $lasta $a
                        if {[$lparenco exists radiko] && [$lparenco set radiko] eq $lasta} {
                            $lparenco set radiko $a
                            $a set funkcio radiko
                        }
                        my foriguElemento $sekva
                        set nefino 1
                        break
                    }
                }
            }
            incr aindekso
        }
    }
    # problemo pro
    # la libro granda
    # la libro de frato maljuna
    # la libro de frato plena de zorgo.
    set nefino 1
    while {$nefino} {
        set aindekso 0
        set nefino 0
        foreach elem $astoj {
            set relem [$elem prenuRadiko]
            if {[$relem istype GP::Adjektivo]} {
                set aelem [$elem prenuAntauxElemento]
                if {$aelem ne "" && [$aelem istype GP::Substantivo] && [$aelem estasNePronomo] && [$aelem kazo] eq [$relem kazo] && [$aelem nombro] eq [$relem nombro]} {
                    set aelemp [$aelem miAuxRadikaElemento]
                    # substantivo povas esti radiko de tuta frazo
                    # en tiu kazo trovu la direktan fration de $elem
                    set parencojelem [$elem prenuParencojn]
                    if {$aelemp in $parencojelem} {
                        set aelemp [$elem prenuMalantauxFraton]
                    }
                    if {$aelemp ne ""} {
                        $elem foriguDeParenco
                        if {[$aelemp istype SintaksAsto::np]} {
                            # la libro bona
                            $aelemp lappend astoj $elem
                        } else {
                            # libro bona
                            set np [SintaksAsto::np new -childof [my info parent] [list -astoj [list $aelemp $elem]]]
                            [$aelemp parenco] tausxuAstojMultaj $aelemp $np
                        }
                    }
                }
            }
        }
    }
}
@ SintaksAsto::amain instproc sxercxiSubfrazoj {} {
description {Tiu metodo faras la sintaksan alalizon
laux prisktibo en klaso SintaksaAnalizo}
}
SintaksAsto::amain instproc sxercxiSubfrazoj stupo {
    set frazo [my info parent]
    my instvar astoj

    set nbr 0
    set startindekso 0
    # nombro de musteroj kiuj estas jam analizitaj
    set tutmustero -1
    while 1 {
        incr nbr
        if {$nbr>=100} {
            error "eventaula senfinajxo cxe sintaksa analizo"
        }
        set sukceso 0
        set mustero 0
        foreach sf [lindex [SintaksaAnalizo set subfrazoj] $stupo] {
            set sukceso 0
            set funkcio [lindex $sf 0 0]
            set postAktiono [lindex $sf 0 1]
            set elementoj [lindex $sf 1]
            if {$mustero>$tutmustero} {
                set lstartindekso 0
            } else {
                set lstartindekso [expr {$startindekso-[llength $elementoj]+1}]
                if {$lstartindekso<0} {
                    set lstartindekso 0
                }
            }
            for {set aindekso $lstartindekso} {[llength $elementoj]+$aindekso<=[llength $astoj]} {incr aindekso} {
                set sindekso 0
                set sukceso 1
                set listo []
                foreach e $elementoj {
                    set elemento [lindex $astoj [expr {$aindekso+$sindekso}]]
                    regsub %e $e $elemento e
                    # uzu memoro por malsukcesaj testoj por prirapdigo
                    if {![catch {expr {$elemento in $malsukcesaj($e)}} cacherez]} {
                        if {$cacherez} {
                            #puts "$e $elemento"
                            set sukceso 0
                            break
                        }
                    }
                    if {[string index $e 0] eq ":"} {
                        if {![$elemento testuStrukturo $e]} {
                            set sukceso 0
                            lappend malsukcesaj($e) $elemento
                            break
                        }
                    } else {
                        if {![$elemento testuSintakso $e]} {
                            set sukceso 0
                            lappend malsukcesaj($e) $elemento
                            break
                        }
                    }
                    incr sindekso
                }
                # dua testo sur metodo en 2 pozicio
                if {$sukceso} {
                    set fpos [expr {$aindekso+[llength $elementoj]-1}]
                    if {[llength $sf]>2} {
                        if {![my [lindex $sf 2] [lrange $astoj $aindekso $fpos]]} {
                            set sukceso 0
                        }
                    }
                    if {$sukceso} {
                        my debugAnalizo $stupo $aindekso $sf
                        set c SintaksAsto::$funkcio
                        if {![Object isclass $c]} {
                            set c SintaksAsto
                        }
                        if {$postAktiono ne ""} {
                            set a [$c new -childof $frazo -noinit]
                            $a aliformuStrukturon $funkcio [self] $aindekso $fpos $postAktiono
                        } else {
                            set tastoj [lrange $astoj $aindekso $fpos]
                            set c SintaksAsto::$funkcio
                            if {![Object isclass $c]} {
                                set c SintaksAsto
                            }
                            set a [$c new -childof $frazo -astoj $tastoj -funkcio $funkcio]
                            set astoj [lreplace $astoj $aindekso $fpos $a]
                        }
                        # cxe adjsup ni devas reanalizi de lasta stupo por
                        # trovi eblajn np-subfrazoj
                        if {$funkcio eq "adjsup"} {
                            return 2
                        }
                        if {$funkcio eq "adjp" && $stupo==3} {
                            return 3
                        }
                        break
                    }
                }
            }
            # por 5. stupo ne rekomenco kun cxiuj musteroj (musteroj ne rekursivaj)
            if {$sukceso} {
                set startindekso $aindekso
                set tutmustero $mustero
                break
            }
            incr mustero
        }
        if {!$sukceso} {
            break
        }
    }
    return 0
}
SintaksAsto::amain instproc sxercxuAdjSuplementoj {} {
    # la gxis nun granda libro estas forvendita.
    my instvar astoj parenco
    set nefino 1
    set trovis 0
    set frazo [my info parent]
    if {![info exists parenco]} {
        set parenco {}
    }
    my initParencon $parenco
    while {$nefino} {
        set nefino 0
        set indekso 0
        foreach asto $astoj sekva [lrange $astoj 1 end] {
            incr indekso
            if {$sekva eq ""} break
            set unua [$sekva prenuUnuanKiu e {[[$e prenuRadiko] istype GP::Adjektivo]}]
            if {$unua eq ""} continue
            set unuaRadiko [$unua prenuRadiko]
            if {((([$asto istype SintaksAsto::advp] && [$asto havasMerkmalon tempo]) || ([$asto istype SintaksAsto::pp] && ([$asto testuCxuTempo] || [$asto estasPrepozicioj {por}])))) || ([$unuaRadiko estasPartizipo] && [$unuaRadiko estasPasiva] && [$asto istype SintaksAsto::pp] && [$asto estasPrepozicioj {de per}])} {
                my debugAnalizo 0 [expr {$indekso-1}] "adjsup"
                set a [SintaksAsto::adjsup new -childof $frazo -astoj [list $asto $unua]]
                set uparenco [$unua parenco]
                $uparenco tausxuAstoj $unua $a
                my foriguElemento $asto
                set trovis 1
                set nefino 1
                break
            }
        }
    }
    return $trovis
}
@ Class SintaksAsto::disk {
description {Diskription, helpelemonto uzita por rilativaj frazoj.
Rilativa frazo priskribas la elementon de superfrazo.}
}
Class SintaksAsto::disk -superclass ::SintaksAsto -parameter relradiko
@ ::SintaksAsto::disk idemeta component EspSintaksaAnalizo
SintaksAsto::disk instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::disk instproc init {} {
    my instvar relradiko radiko funkcio
    set radiko [lindex [my astoj] 0]
    if {[info exists relradiko]} {
        set funkcio [$relradiko set funkcio]
    }
}
SintaksAsto::disk instproc initKunteksto parenco {
    # tio metodo estas neniam uzata !!!
    next
    #[my radiko] initKunteksto $parenco
    [my radiko] set funkcio radiko
}
SintaksAsto::disk instproc kolektuSubstantivoj {} {
    my instvar radiko
    $radiko kolektuSubstantivoj
}
SintaksAsto::disk instproc prenuCxefRadiko {} {
    my prenuRadiko
}
SintaksAsto::disk instproc prenuCxefajElementoj {} {
    my instvar radiko
    if {[$radiko istype SintaksAsto]} {
        $radiko prenuCxefajElementoj
    } else {
        list $radiko
    }
}
SintaksAsto::disk instproc prenuEblajRelRadukoj {} {
    # Bonvena alternativo estis pomkompoto farita el la pomoj de nia ĝardeno, kiuj ...
    # devas esti: pomkompoto, pomoj, gxardeno
    set ret [list]
    set unua [my prenuRelFrazoRadiko]
    lappend ret $unua
    set sekva [[$unua miAuxRadikaElemento] prenuSubsupRadiko]
    while {$sekva ne ""} {
        lappend ret $sekva
        set sekva [[$sekva miAuxRadikaElemento] prenuSubsupRadiko]
    }
    return $ret
}
SintaksAsto::disk instproc prenuRelFrazoRadiko {} {
    [lindex [my astoj] 0] prenuRelFrazoRadiko
}
@ Class SintaksAsto::frazj {
description {Strukturo por sintaksaj frazajxoj
 * unu post la alia
 * jen kaj jen
 * pli kaj pli}
}
Class SintaksAsto::frazj -superclass ::SintaksAsto
@ ::SintaksAsto::frazj idemeta component EspSintaksaAnalizo
SintaksAsto::frazj instproc init {} {
    my radiko [lindex [my astoj] 0]
    my funkcio adv
}
SintaksAsto::frazj instproc radikoFino {} {
    my radiko [lindex [my astoj] end]
}
SintaksAsto::frazj instproc testuSintakso elem {
    return 0
}
@ Class SintaksAsto::grupo {
description {gxenerala grupo sen signifo}
}
Class SintaksAsto::grupo -superclass ::SintaksAsto
@ ::SintaksAsto::grupo idemeta component EspSintaksaAnalizo
SintaksAsto::grupo instproc igiAntauOl {} {
    my instvar astoj radiko
    set radiko [lindex $astoj end]
    #my funkcio fkonj
    my aliguMerkmalon antauxol
}
SintaksAsto::grupo instproc igiFkonj {} {
    my funkcio fkonj
}
SintaksAsto::grupo instproc igiRadikoLasta {} {
    my instvar astoj radiko
    set radiko [lindex $astoj end]
}
SintaksAsto::grupo instproc igiRadikoUnua {} {
    my instvar astoj radiko
    set radiko [lindex $astoj 0]
}
SintaksAsto::grupo instproc init {} {
    if {![my exists radiko]} {
        my instvar astoj
        set duaVorto [[lindex $astoj 1] prenuRadiko]
        if {[$duaVorto estasVortoj {mem for ĉi ajn}]} {
            my radiko [lindex [my astoj] 0]
        } else {
            my radiko [lindex [my astoj] end]
        }
    }
}
SintaksAsto::grupo instproc initKunteksto parenco {
    next
    [my radiko] set funkcio radiko
}
SintaksAsto::grupo instproc radikoSurVerbo {} {
   my radiko [lindex [my astoj] 1]
}
Class SintaksAsto::horo -superclass ::SintaksAsto
@ ::SintaksAsto::horo idemeta component EspSintaksaAnalizo
SintaksAsto::horo instproc init {} {
    my instvar astoj
    # la sepa kvin
    my radiko [lindex $astoj 1]
}
@ Class SintaksAsto::ident {
description {identiga subjektiva suplemento:
'''urbo Varsovio'''
'''lando USA'''}
}
Class SintaksAsto::ident -superclass ::SintaksAsto
@ ::SintaksAsto::ident idemeta component EspSintaksaAnalizo
SintaksAsto::ident instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::ident instproc init {} {
    my radiko [lindex [my astoj] 0]
}
SintaksAsto::ident instproc initKunteksto parenco {
    next
    #[my radiko] initKunteksto $parenco
    [my radiko] set funkcio radiko
}
SintaksAsto::ident instproc prenuCxefRadiko {} {
    my prenuRadiko
}
SintaksAsto::ident instproc prenuCxefajElementoj {} {
    my instvar radiko
    if {[$radiko istype SintaksAsto]} {
        $radiko prenuCxefajElementoj
    } else {
        list $radiko
    }
}
SintaksAsto::ident instproc prenuRelFrazoRadiko {} {
    [lindex [my astoj] 0] prenuRelFrazoRadiko
}
@ Class SintaksAsto::ignor {
description {Helpoasto por alligu ignor partoj (cxitajxoj aux klameroj)
al normalaj elementoj.
}
}
Class SintaksAsto::ignor -superclass ::SintaksAsto
@ ::SintaksAsto::ignor idemeta component EspSintaksaAnalizo
SintaksAsto::ignor instproc estasBazaElemento {} {
    my instvar radiko
    $radiko estasBazaElemento
}
SintaksAsto::ignor instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::ignor instproc init {} {
    if {![my exists radiko]} {
        my radiko [lindex [my astoj] 0]
    }
}
SintaksAsto::ignor instproc initKunteksto parenco {
    next
    # [my radiko] initKunteksto $parenco
    [my radiko] set funkcio radiko

}
SintaksAsto::ignor instproc kolektuSubstantivoj {} {
    my instvar radiko
    $radiko kolektuSubstantivoj
}
SintaksAsto::ignor instproc prenuCxefRadiko {} {
    my prenuRadiko
}
SintaksAsto::ignor instproc prenuRelFrazoRadiko {} {
    if {[my exists radiko]} {
        my radiko
    } else {
        [lindex [my astoj] 0] prenuRelFrazoRadiko
    }
}
Class SintaksAsto::kadv -superclass ::SintaksAsto
@ ::SintaksAsto::kadv idemeta component EspSintaksaAnalizo
SintaksAsto::kadv instproc estuAdverba {} {
    my instvar radiko
    if {[$radiko hasclass GP::Adverbo]} {
        $radiko mixin add GP::Adverbo
    }
}
SintaksAsto::kadv instproc init {} {
    my instvar astoj
    my radiko [lindex $astoj 0]
}
@ Class SintaksAsto::konj {
description {Konjunkcio kunkigas du elementoj sen sxangxi la funkcio de elemento.
''Mi kaj vi'' kuras.}
}
Class SintaksAsto::konj -superclass ::SintaksAsto
@ ::SintaksAsto::konj idemeta component EspSintaksaAnalizo
SintaksAsto::konj instproc estasDuobla vorto {
    my instvar radiko astoj
    if {[llength $astoj]==4 && [[lindex $astoj 0] estasVorto $vorto] && [[lindex $astoj 2] estasVorto $vorto]} {
        return 1
    }
    return 0
}
SintaksAsto::konj instproc estasKuneblaj {elem ligilo stupo} {
    # nur komo povas esti plu kunligita
    set uElem [lindex [my astoj] 1]
    if {[$uElem exists vorto] && [$uElem vorto] eq ","} {
        my instvar radiko
        $elem estasKuneblaj $radiko $ligilo $stupo
    } else {
        return 0
    }
}
SintaksAsto::konj instproc init {} {
    next
    my instvar radiko astoj
    if {[llength $astoj]==3} {
        set radiko [lindex $astoj 0]
    } else {
        set radiko [lindex $astoj 1]
    }
    if {[$radiko havasFunkcion] && [$radiko exists funkcio]} {
        my funkcio [$radiko funkcio]
    }
}
SintaksAsto::konj instproc initKunteksto parenco {
    next
    [my radiko] set funkcio radiko
}
SintaksAsto::konj instproc prenuNombron {} {
    my instvar astoj
    set rad [my prenuRadiko]
    if {[$rad istype GP::Adjektivo]} {
        return [$rad prenuNombron]
    }
    if {[[lindex $astoj end-1] istype GP::Konjunkcio] &&
        [[lindex $astoj end-1] prenuVorton] eq "kaj"} {
            return pluralo
    }
    if {[[lindex $astoj end-1] istype GP::Simbolo] &&
        [[lindex $astoj end-1] prenuVorton] eq ","} {
            return pluralo
    }
    next
}
SintaksAsto::konj instproc sxercxiAdjektivoErarojnNombreco {kolektilo nombro kazo} {
    my instvar astoj
    # testado de
    # Li estas mensogisto kaj malbonuloj
    foreach e $astoj {
        if {[$e istype GP::Konjunkcio] || [$e istype GP::Simbolo]} {
            continue
        }
        if {[$e istype SintaksAsto::konj]} {
            $e sxercxiErarojnNombreco $kolektilo $nombro $kazo
            continue
        }
        set radiko [$e prenuRadiko]
        if {[$radiko istype GP::Adjektivo] || [$radiko istype SintaksAsto::np]} {
            set defElemento $radiko
        } else {
            set defElemento [$radiko miAuxRadikaElemento]
        }
        if {[$defElemento prenuNombron] ne $nombro} {
            if {[$defElemento istype SintaksAsto::np]} {
                foreach {k f prop} [$defElemento prenuFrazpartoKazoNombro 0 [expr {$nombro eq "pluralo"}]] {}
                if {$k ne ""} {
                    $kolektilo aliguEraron [list $k $f] "nombro de substantiva priskribo kaj substantivo ne estas la sama" [list $prop]
                }
            } else {
                $kolektilo aliguEraron $radiko "nombro de substantiva priskribo kaj substantivo ne estas la sama" [esp::prenuKazoNombro [$radiko prenuBazanFormon] 0 [expr {$nombro eq "pluralo"}]]
            }
        }
    }
}
SintaksAsto::konj instproc sxercxiErarojnNombreco {kolektilo nombro kazo} {
    my instvar astoj
    # testado de
    # Li estas mensogisto kaj malbonuloj
    foreach e $astoj {
        if {[$e istype GP::Konjunkcio] || [$e istype GP::Simbolo]} {
            continue
        }
        if {[$e istype SintaksAsto::konj]} {
            $e sxercxiErarojnNombreco $kolektilo $nombro $kazo
            continue
        }
        set radiko [$e prenuRadiko]
        if {[$radiko hasclass GP::Substantivo] || [$radiko istype SintaksAsto::np]} {
            set defElemento $radiko
        } else {
            set defElemento [$radiko miAuxRadikaElemento]
        }
        if {[$defElemento hasclass GP::NombroKazo] && [$defElemento prenuNombron] ne $nombro} {
            if {[$defElemento istype SintaksAsto::np]} {
                foreach {k f prop} [$defElemento prenuFrazpartoKazoNombro 0 [expr {$nombro eq "pluralo"}]] {}
                if {$k ne ""} {
                    $kolektilo aliguEraron [list $k $f] "nombro de substantiva priskribo kaj substantivo ne estas la sama" [list $prop]
                }
            } else {
                $kolektilo aliguEraron $radiko "nombro de substantiva priskribo kaj substantivo ne estas la sama" [esp::prenuKazoNombro [$radiko prenuBazanFormon] 0 [expr {$nombro eq "pluralo"}]]
            }
        }
    }
}
SintaksAsto::konj instproc testuStrukturo elem {
    my instvar radiko
    $radiko testuStrukturo $elem
}
@ Class SintaksAsto::ktempo {
description {Grupo po kompleksaj tempoj kiel: estas farinta}
}
Class SintaksAsto::ktempo -superclass ::SintaksAsto
@ ::SintaksAsto::ktempo idemeta component EspSintaksaAnalizo
@ SintaksAsto::ktempo instproc init {} {
description {ekzemple:

estas rapide leginta
esti leginta}
}
SintaksAsto::ktempo instproc init {} {
    my instvar astoj radiko
    set radiko [lindex $astoj end]
    set r [$radiko prenuRadiko]
    set eradiko [[lindex $astoj 0] prenuRadiko]
    $r class GP::Verbo
    if {[$r hasclass ::GP::Partizipo]} {
        $r mixin delete ::GP::Partizipo
    }
    $r tempo [$eradiko tempo]
}
SintaksAsto::ktempo instproc prenuEsti {} {
    my instvar astoj
    [lindex $astoj 0] prenuRadiko
}
@ Class SintaksAsto::main {
description {Superelemento por frazoj aux frazo partoj, kiu necesas verbon.
}
}
Class SintaksAsto::main -superclass ::SintaksAsto::amain
@ ::SintaksAsto::main idemeta categories {verbo testado subfrazoj gramatika-analizo gramatika-testado}
@ ::SintaksAsto::main idemeta categoriesMethods {{prenuInfVerbo prenuNeInfVerbo sxercxiVerboFrazoj} {estasEkzistoEsprimo estasPasivaFrazo estasDemando estasEkkrio estasKompleksaTempo estasPunktaTempo estasOrdonoSenSubjekto estasOrdonoKunBonvolu havasKeSubfrazon estasDemandaKomenco estasDauraTempo estasKromaSenverba} {sxercxiRilativanFrazon sxercxiKomaIgnorfrazoj sxercxiKajSubfrazojDeFino sxercxiPlenajFrazoj sercxiSenkomajSubfrazoj sxercxiCxefrazoj sxercxiIgnorPartoj sxercxiKajKomaSubfrazoj} {sxercxiDialogoPriskribo provuKorektonSenSubjekto aliguRilativanFrazon pritraktuDumKajGxis definuFunkcioj analizu sxercxiFrazokapon} {testuSubjekton testuSubfrazon sxercxiErarojn raportuEraroAkuzativo testuKomenco testuElementoSenFunkcio}}
@ ::SintaksAsto::main idemeta component EspSintaksaAnalizo
@ SintaksAsto::main instproc aliguRilativanFrazon {} {
description {Konstruas relativan frazon de pozicio.}
}
SintaksAsto::main instproc aliguRilativanFrazon pozicio {
    my instvar astoj parenco
    set komoend end
    set frazo [my info parent]
    set verbopos -1
    for {set x [expr {$pozicio+1}]} {$x<[llength $astoj]} {incr x} {
        set elem [[lindex $astoj $x] prenuLastan]
        if {[$elem istype GP::Simbolo]} {
            if {[$elem vorto] eq ","} {
                set komoend $x
            } elseif {[$elem vorto] in {) \" '}} {
                continue
            } else {
                set komoend [expr {$x-1}]
            }
            break
        } elseif {[$elem istype GP::Verbo] && ![$elem estasInfinitivo]} {
            # La homo kiu laboras vivas bone.
            # ! La homo kiu laboras kaj ripozas vivas bone.
            if {$verbopos>0} {
                set komoend [expr {$x-1}]
                break
            } else {
                set verbopos $x
            }
        } elseif {[$elem istype GP::Konjunkcio] && [$elem estasVortoj {aŭ kaj}]} {
            # La homo, kiu laboras kaj legas libron.
            set komoend [expr {$x-1}]
            break
        }
    }
    my debugAnalizo 0 $pozicio "aligu rel-frazo"
    # se la antauxa elemento estas , do movu tiun elemento al aktuala relativa frazo
    # ekz. Mi havas la libron, kiu apartenas al homo, kiu loĝas tie.
    set aelemento [[lindex $astoj $pozicio] prenuAntauxElemento]
    if {$aelemento ne "" && [$aelemento istype GP::Simbolo] && [$aelemento estasVorto ,]} {
        $aelemento foriguDeParenco
        set f [SintaksAsto::main new -childof $frazo -astoj [concat $aelemento [lrange $astoj $pozicio $komoend]] -funkcio subfrazo]
    } else {
        set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $pozicio $komoend] -funkcio subfrazo]
    }

    [lindex $astoj $pozicio] funkcio fkonj
    if {$komoend ne "end" && $komoend+1 eq [llength $astoj]} {
        set komoend end
    }
    if {$komoend ne "end" && [[lindex $astoj $komoend] istype GP::Simbolo]} {
        [lindex $astoj $komoend] funkcio fkonj
    }
    set lastIndex [expr {$pozicio-1}]
    set lemem [lindex $astoj $lastIndex]
    my kunliguRilativanFrazonAl $f $lemem
    set astoj [lreplace $astoj $pozicio $komoend]

    $f sxercxiKajSubfrazojDeFino
    $f sxercxiKomaIgnorfrazoj
    $f sxercxiKajKomaSubfrazoj

    my initParencon $parenco

    # Mi havas la libron, kiu apartenas al homo, kiu loĝis en tiu urbo.
    if {$komoend ne "end"} {
        set selem [lindex $astoj $pozicio]
        if {[$selem istype GP::TabloVorto] && [$selem bazo] eq "ki"} {
            my aliguRilativanFrazon $pozicio
        } elseif {[$selem istype SintaksAsto::pp]} {
            set sselem [lindex [$selem astoj] end]
            if {[$sselem istype GP::TabloVorto] && [$sselem bazo] eq "ki"} {
                my aliguRilativanFrazon $pozicio
            }
        }
    }
}
SintaksAsto::main instproc analizu {} {
    my pritraktuDumKajGxis
    my sxercxiKajKomaSubfrazoj 1
    if {[my istype SintaksAsto::mainc]} {
        # la metodo sxercxiKajKomaSubfrazoj povas sxangxi la klason
        my analizu
    } else {
        next
        set nbr 0
        # Duopa Sercxado de suplemento pro frazoj kiel
        # Ĉiu ricevis kuleregon da supo kaj grandan suplementon.
        foreach a [my astoj] {
            $a initKunteksto [self]
        }
        my initParencon {}
        my sxercxiKompleksajSubjektivanSuplementon
        while {[my kunliguKonjunkcioj 2] && $nbr<100} {
            incr nbr
        }
        if {$nbr>=100} {
            IDE::Dialog message "eventaula senfinajxo"
        }
        # se la ordo estus alia, la analizilo havus problomon kun frazo
        # "Mi vidis la homon, kiu pene laboras, tre ofte."
        my sxercxiRilativanFrazon
        my sxercxiKomaIgnorfrazoj
        my sxercxiKajSubfrazojDeFino
        my sxercxiKajKomaSubfrazoj 0
        foreach a [my astoj] {
            $a initKunteksto [self]
        }
        my initParencon {}
        my sxercxiKompleksajSubjektivanSuplementon
        foreach a [my prenuAstojn] {
            if {[$a istype SintaksAsto::amain]} {
                $a sxercxiKompleksajSubjektivanSuplementon
            }
        }

        my sxercxiFrazokapon
    }
}
SintaksAsto::main instproc definuFunkcioj {} {
    next
    my instvar astoj radiko parenco
    if {![info exists radiko]} {
        return
    }

    set havisSubj 0
    set havisObjekton 0
    set havisIndirektanObjekton 0
    set havisPSubjekton 0
    set radobj [$radiko prenuRadiko]
    set estasEst [$radobj estasEst]
    set eblasComp [$radobj eblasComp]
    set havisComp [expr {!$eblasComp}]
    set havisOComp [expr {![$radobj eblasObjComp]}]
    set havisOAttr [expr {![$radobj eblasObjAdjComp]}]
    set havisAttr [expr {![$radobj eblasAdjComp]}]
    set havisModVerbo [expr {![$radobj estasModVerbo]}]

    set estasKomenco 1
    set initListo [list]
    foreach e $astoj {
        set eobj [$e prenuRadiko]
        if {[$e istype SintaksAsto::np]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$eobj hasclass GP::Substantivo] || ([$eobj hasclass GP::Adjektivo] && [$eobj estasSubstantiva])} {
            if {[$eobj prenuKazon] eq "nominativo"} {
                if {$havisSubj} {
                    if {[$eobj istype GP::Konstanto] && $havisComp} {
                        if {!$havisObjekton} {
                           set havisObjekton 1
                           $eobj kazo akuzativo
                           $e funkcio obj
                        }
                    } elseif {[my havasMerkmalon sub-da] && $havisComp} {
                        # multe da libroj mi legis.
                        $e funkcio subj
                        $subjObjekto funkcio obj
                        set subjObjekto $e
                    } elseif {[$eobj havasMerkmalon numel] && $havisComp} {
                        # tri el libroj
                        set havisObjekton 1
                        $e funkcio obj
                        $eobj kazo akuzativo
                    } elseif {[$eobj havasMerkmalon eblaakuzativo] && $havisComp} {
                        # tri el libroj
                        set havisObjekton 1
                        $e funkcio obj
                        $eobj kazo akuzativo
                    } elseif {[$eobj estasVorto ambaŭ] && $havisComp} {
                        # mi vidis ambaŭ
                        if {!$havisObjekton} {
                           set havisObjekton 1
                           $eobj kazo akuzativo
                           $e funkcio obj
                        }
                    } else {
                        if {!$havisComp && (!$havisAttr || ![$radobj eblasAdjComp])} {
                            $e funkcio comp
                            set compObjekto $e
                            set havisComp 1
                        } elseif {!$havisOComp && $havisObjekton} {
                            $e funkcio ocomp
                            set havisOComp 1
                        } elseif {[$eobj istype GP::Konstanto] && [$eobj estasVirinaNomo]} {
                            if {!$havisObjekton} {
                                set havisObjekton 1
                                $e funkcio obj
                            }
                        }
                    }
                } else {
                    $e funkcio subj
                    set subjObjekto $e
                    set havisSubj 1
                }
            } else {
                if {[$eobj istype GP::Substantivo] && [$eobj estasTempo]} {
                    $e funkcio tempo
                } elseif {[$eobj istype GP::Substantivo] && [$eobj estasLongeco]} {
                    $e funkcio long
                } elseif {[$radobj estasMuvigo] && [$eobj istype GP::Substantivo] && [$eobj estasLoko]} {
                    $e funkcio direkto
                } else {
                    set objObjekto $e
                    if {!$havisObjekton} {
                        set havisObjekton 1
                        $e funkcio obj
                    }
                }
            }
            continue
        }
        if {[$e prenuNomo] eq "Adverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e prenuNomo] eq "PrimitivaAdverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$eobj istype GP::Adjektivo]} {
            if {(!$havisAttr && (!$havisComp || !$eblasComp) && !$havisObjekton) || [$eobj havasDerivoPriskribon pverbo]} {
                $e funkcio attr
                set attrObjekto $e
                set havisAttr 1
            } elseif {!$havisOAttr && $havisObjekton} {
                $e funkcio oattr
                set havisOAttr 1
            }
            # tion mi estas kapabla kompreni
            # trovi nfvp verbon
            if {[set v [$e selektu {{filtruVeron istype SintaksAsto::adjsup} 1 {filtruVeron istype SintaksAsto::nfvp} prenuRadiko}]] ne ""} {
                set infVerbo $v
                $e funkcio attr
                set attrObjekto $e
                set havisAttr 1
            }
            continue
        }
        # La libro estas mia.
        if {[$eobj istype GP::PosesivPronomo]} {
            if {!$havisAttr} {
                $e funkcio attr
                set attrObjekto $e
                set havisAttr 1
                continue
            }
        }
        if {[$e istype SintaksAsto::subsup]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$e istype SintaksAsto::kadv]} {
            $e funkcio adv
            $e estuAdverba
        }
        # Kiel vi tion faris?
        if {[$eobj istype GP::TabloVorto] && [$eobj estasArto el]} {
            $e funkcio adv
            $eobj mixin add GP::Adverbo
        }
        # multe da ...
        if {[$e hasclass SintaksAsto::advsup] && [$e eblasKielSubstantivo]} {
            if {[$e estasTempo]} {
                $e set funkcio tempo
            } else {
                if {!$havisSubj} {
                    $e set funkcio subj
                    set havisSubj 1
                    set subjObjekto $e
                    my aliguMerkmalon sub-da
                } elseif {!$havisObjekton} {
                    $e set funkcio obj
                    set havisObjekton 1
                }
            }
            continue
        }
        if {[$eobj hasclass GP::Adverbo]} {
            $e funkcio adv
            continue
        }
        if {[$eobj hasclass GP::PrimitivaAdverbo]} {
            if {[$eobj estasTempo]} {
                $e funkcio tempo
            } elseif {[$eobj estasSolaAdverbo]} {
                $e funkcio adv    
            }
            continue
        }
        if {[$eobj hasclass GP::Verbo] && [$eobj estasInfinitivo]} {
            set infVerbo $e
            if {!$havisModVerbo} {
                $e funkcio nfvp
                set havisModVerbo 1
            }
            continue
        }
        if {[$e havasFunkcion] && [$e funkcio] eq "pp"} {
            if {[$eobj prenuVorton] eq "al" && [$radobj eblasIndirektaObjekto]} {
                if {!$havisIndirektanObjekton} {
                    $e funkcio iobj
                    set havisIndirektanObjekton 1
                    continue
                }
            }
            if {[$eobj prenuVorton] eq "de" && [$radobj estasEst]} {
                if {$havisPSubjekton} {
                    $e funkcio psubj
                    set havisPSubjekton 1
                    continue
                }
            }
        }
        # frazcxenoj, kiu komencas de interjekcioj
        set ce [$e prenuCxefRadiko]
        if {$estasKomenco && [$ce istype GP::Konjunkcio] && ([$ce estasCertaSubfrazo] || [$ce estasVorto aŭ])} {
            $ce funkcio fkonj
            # estas nepre subfrazo, se ekzistas parenco
            if {$parenco ne ""} {
                my funkcio subfrazo
            }
        }
        # Dum interne ĉio kantadis kaj ĝojadis, ŝi sidis malgaja en sia ĝardeneto.
        if {$estasKomenco && [$e istype GP::Prepozicio] && [$e estasVorto dum]} {
             $e funkcio fkonj
             $e class GP::Interjekcio  
        }

        # ignoru kelkaj simboloj kiel vara frazkomenco
        # ankaux plenvortoj sed, kaj
        if {$estasKomenco && [$e istype GP::Elemento] && [$e prenuVorton] in {— - \" “ kaj sed aŭ ( \;}} {
            set estasKomenco 1
        } else {
            set estasKomenco 0
        }
        if {[$e istype GP::Onomatopeo]} {
            $e funkcio ono
        }
    }
    # infinitiva verbo kiel complemento
    # ekz: Mangxi estas bone.
    if {!$havisPSubjekton && $estasEst && [info exists infVerbo] && !$havisSubj} {
        $infVerbo set funkcio subj
        set havisSubj 1
    }
    # Rigardi interesis min
    if {!$havisSubj && [info exists infVerbo] && [$radobj estasBazajVortoj {interesi surprizi}]} {
        $infVerbo set funkcio subj
        set havisSubj 1
    }
    # Kazoj kiel
    # "Kiu vi estas?"
    # "Kia homo vi estas?"
    # Subjekto ne estas en la unua pozicio
    if {[info exists subjObjekto] && [info exists compObjekto]} {
        if {[[set u [$subjObjekto prenuUnuan]] istype GP::TabloVorto] && ![[$compObjekto prenuRadiko] estasVorto tio]} {
            $subjObjekto set funkcio comp
            $compObjekto set funkcio subj
        }
        # testu cxu "vi" en pluralo
        if {[[$subjObjekto prenuRadiko] estasVorto vi] &&
            [[$compObjekto prenuRadiko] set nombro] eq "pluralo"} {
            [$subjObjekto prenuRadiko] set nombro pluralo
        }
   }
   if {[info exists subjObjekto] && [info exists attrObjekto]} {
        if {[[$subjObjekto prenuRadiko] estasVorto vi] &&
            [[$attrObjekto prenuRadiko] set nombro] eq "pluralo"} {
            [$subjObjekto prenuRadiko] set nombro pluralo
        }
   }
   # komputu pasivan merkmalon
   if {[$radobj estasBasaVorto esti] && $havisSubj && $havisAttr} {
       set attrobj [my trovuKunFunkcio attr]
       if {$attrobj ne ""} {
            set rad [$attrobj prenuRadiko]
            if {[$rad estasNeTranzitivaPartizipo]} {
                my aliguMerkmalon pasivo
            } elseif {[$rad estasTranzitivaPartizipo]} {
                # kompleksa tempo. Li estis finanta
                my aliguMerkmalon ktempo
            }
       }
   }
   # Tion mi sukcesis kompreni
   # Tion mi volas scii.
   # Li alvoki cxiujn fari tion. (i+obj)
   # nfvpobj
   if {[info exists infVerbo] && [info exists objObjekto] && ![$radobj havasDerivoPriskribon objmod]} {
       set iv [$infVerbo prenuRadiko]
       if {[$iv eblasObjekto]} {
           if {![$infVerbo hasclass SintaksAsto1] || [$infVerbo trovuKunFunkcio obj] eq ""} {
               $objObjekto set funkcio nfvpobj
               $objObjekto set nvfp $infVerbo
               $infVerbo aliguMerkmalon obj
           }
       }
   }
   # almenaux nun difinu la funktiojn de nfvp
   # pro "Tion mi volas scii"
   foreach e $astoj {
       if {[$e istype SintaksAsto::nfvp]} {
           $e sxercxiFrazokapon
       }
   }
   if {!$havisSubj} {
       my provuKorektonSenSubjekto
   }
}
@ SintaksAsto::main instproc estasDauraTempo {} {
description {Gravas pos slavaj espektoj. Adejtkoj, kiu sndikas longdauran agon:
 * du monatojn
 * longe
 * dauere
 * ripete
 * kutime
Tiu spekulas la koncepton de durativo en aspektoj
}
}
SintaksAsto::main instproc estasDauraTempo {} {
    my instvar radiko astoj
    if {[info exists radiko] && [string range [[my prenuRadiko] prenuBazanFormon] end-2 end] eq "adi"} {
        return 1
    }
    set t [my trovuKunFunkcio tempo]
    # du semajnojn, tutan vesperon
    if {$t ne "" && [$t istype SintaksAsto::np] && [$t estasAkuzativo]} {
        return 1
    }
    foreach a $astoj {
        set r [$a prenuRadiko]
        if {$r ne "" && [$r estasVortoj {dum longe ĉiam foje daŭre ripete kutime plu}]} {
            return 1
        }
    }
    return 0
}
SintaksAsto::main instproc estasDemandaKomenco {} {
    my instvar astoj
    set komenco [my selektu {0 prenuRadiko}]
    if {[$komenco istype GP::Interjekcio] && [$komenco prenuVorton] eq "ĉu"} {
        return 1
    }
    if {[$komenco istype GP::TabloVorto] && [$komenco estasBazo ki]} {
        return 1
    }
    set komenco [my prenuUnuanNeSimbolo]
    if {[$komenco istype GP::TabloVorto] && [$komenco estasBazo ki]} {
        return 1
    }
    # de kie vi venas?
    if {[$komenco istype GP::Prepozicio]} {
        set komenco [$komenco parenco]
        if {$komenco ne "" && [$komenco istype SintaksAsto::pp] && [[set k [[$komenco prenuNPParton] prenuRadiko]] istype GP::TabloVorto] &&  [$k estasBazo ki]} {
            return 1
        }
    }
    # kun kiu homo, je kioma horo
    set unua [lindex $astoj 0]
    if {[$unua istype SintaksAsto::pp]} {
        set npparto [$unua prenuNPParton]
        if {[$npparto istype SintaksAsto::np]} {
            set unua [lindex [$npparto set astoj] 0]
            if {[$unua istype GP::TabloVorto] && [$unua estasBazo ki]} {
                return 1
            }
            # je la kioma horo
            set dua [lindex [$npparto set astoj] 1]
            if {[$dua istype GP::TabloVorto] && [$dua estasBazo ki]} {
                return 1
            }
        }
    }
    return 0
}
SintaksAsto::main instproc estasDemando {} {
    set elementoj [my prenuFoliojn]
    set fino [lindex $elementoj end]
    if {$fino ne "" && [$fino istype GP::Simbolo]} {
        if {[$fino vorto] eq "?"} {
             return 1
        } else {
            set sfino [lindex $elementoj end-1]
            if {$sfino ne "" && [$sfino istype GP::Simbolo] && [$sfino vorto] eq "?"} {
                return 1
            }
        }
    }
    return 0

}
SintaksAsto::main instproc estasEkkrio {} {
    set elementoj [my prenuFoliojn]
    set fino [lindex $elementoj end]
    if {[$fino istype GP::Simbolo]} {
        if {[$fino vorto] eq "!"} {
             return 1
        } else {
            set sfino [lindex $elementoj end-1]
            if {$sfino ne "" && [$sfino istype GP::Simbolo] && [$sfino vorto] eq "!"} {
                return 1
            }
        }
    }
    return 0
}
SintaksAsto::main instproc estasEkzistoEsprimo {} {
    # ekzemple: En arbaro estas bestaro.
    set r [my prenuRadiko]
    set s [my prenuSubjekton]
    if {$s eq "" || $r eq "" || ![$r estasBasaVorto esti] || [$s istype GP::PersonPronomo] || [$s istype GP::TabloVorto]}  {
        return 0
    }
    if {[my trovuKunFunkcio attr] ne "" || [my trovuKunFunkcio comp] ne ""} {
        return 0
    }
    set subj [my prenuSubjekton]
    if {$subj ne ""} {
        set rsubj [$subj prenuRadiko]
        if {![$rsubj istype GP::Substantivo]} {
            return 0
        }
        if {$subj ne $rsubj} {
            set np [$rsubj trovuUnuanPerenconKiu e {[$e istype SintaksAsto::np]}]
            if {$np ne ""} {
                foreach e [$np astoj] {
                    set re [$e prenuRadiko]
                    if {[$re istype GP::Difinilo] || [$re istype GP::PosesivPronomo] || [$re istype GP::TabloVorto]} {
                        return 0
                    }
                }
            }
        }
    }
    return 1
}
@ SintaksAsto::main instproc estasKompleksaTempo {} {
description {Kompleksa tempo estas havas du partoj esti + aktiva partizipo
 Ekzemple: Mi estis finanta.}
}
SintaksAsto::main instproc estasKompleksaTempo {} {
    my havasMerkmalon ktempo
}
SintaksAsto::main instproc estasKromaSenverba {} {
    foreach e [my prenuElementoj] {
        if {[$e istype GP::Elemento] && [$e estasVorto jen]} {
            return 1
        }
    }
    my instvar parenco funkcio
    # Mi ne scias, kion fari.
    # Mi ne scias, kiel fari.
    # Mi ne scias, per kio fajri.
    # devas komenci per "kio" , "kiel" "pp + kio"
    if {$funkcio eq "subfrazo" && $parenco ne "" && [$parenco istype SintaksAsto::disk]} {
        if {[my selektu {prenuUnuanNeSimbolo prenuRadiko {estasBazajVortoj {kio kiel}}}] eq "1"} {
            return 1
        }
        if {[my selektu {prenuUnuanNeSimbolo miAuxRadikaElemento {filtruVeron istype SintaksAsto::pp} prenuNPParton {estasBazajVortoj kio}}] eq "1"} {
            return 1
        }
    }
    return 0
}
SintaksAsto::main instproc estasOrdonoKunBonvolu {} {
    set r [my prenuRadiko]
    set s [my prenuSubjekton]
    expr {$s eq "" && $r ne "" && [$r estasOrdono] && [$r estasBasaVorto bonvoli]}
}
SintaksAsto::main instproc estasOrdonoSenSubjekto {} {
    set r [my prenuRadiko]
    set s [my prenuSubjekton]
    expr {$s eq "" && $r ne "" && [$r estasOrdono] && ![$r estasBasaVorto bonvoli]}
}
@ SintaksAsto::main instproc estasPasivaFrazo {} {
description {Analizas adjektoj je tempodauxraj indikoj.
Tio estas grava por slavaj aspektoj.
Ekzemple:
 * du monatojn
 * ofte, lange
Tioj frazoj devas esti pole ''nie dokonany''}
}
SintaksAsto::main instproc estasPasivaFrazo {} {
    my havasMerkmalon pasivo
}
SintaksAsto::main instproc estasPunktaTempo {} {
    set t [my trovuKunFunkcio tempo]
    my instvar astoj
    # la sepan de decembro
    # ?? jam jxus ankoraux
    if {$t ne "" && [$t istype SintaksAsto::np] && ![$t estasAkuzativo]} {
        return 1
    }
    # TODO ?
    # ankoraux, jxus
    return 0
}
SintaksAsto::main instproc havasKeSubfrazon {} {
    my instvar parenco
    if {[info exists parenco] && $parenco ne "" && [$parenco istype SintaksAsto::mainc]} {
        $parenco havasKeSubfrazon
    } else {
        return 0
    }
}
SintaksAsto::main instproc prenuCxeffrazon {} {
    # mi volas, ke tio funkcias.
    # cxeffrazo = vi volas
    # subfrazo = ke tio funkcias
    my selektu {parenco {filtruVeron istype SintaksAsto::mainc} {trovuKunFunkcio cxeffrazo}}
}
SintaksAsto::main instproc prenuInfVerbo {} {
    my instvar astoj
    foreach a $astoj {
        set robj [$a prenuRadiko]
        if {[$robj istype GP::Verbo] && [$robj estasInfinitivo]} {
            return $a
        }
    }
    return
}
SintaksAsto::main instproc prenuNeInfVerbo {} {
    my instvar astoj
    foreach a $astoj {
        set robj [$a prenuRadiko]
        if {[$robj istype GP::Verbo] && ![$robj estasInfinitivo]} {
            return $robj
        }
    }
    return
}
SintaksAsto::main instproc prenuSubjekton {} {
    my trovuKunFunkcio subj
}
SintaksAsto::main instproc prenuUnuanNeSimbolo {} {
    set unua [my prenuUnuan]
    if {$unua eq "" || ![$unua istype GP::Simbolo]} {
        return $unua
    }
    $unua prenuSekvaElemento
}
SintaksAsto::main instproc pritraktuDumKajGxis {} {
    my instvar astoj
    # hipotezo dum kaj gxis en unua pozicio kaj post komo estas frazkondukiloj
    set unua [lindex $astoj 0]
    set dua [lindex $astoj 1]
    set tria [lindex $astoj 2]
    # nur kazo kun personal pronomo
    # dum mi lernis, li ludis.

    # 03.08.2008
    # La solenajxo, dum kiu mi legis libron, estis tre longa

    if {[$unua istype GP::Elemento] && [$unua estasVortoj {dum ĝis}] && $dua ne "" && [$dua istype GP::PersonPronomo]} {
        $unua class GP::Interjekcio
    }
    set i 0
    foreach {elem selem} $astoj {
        incr i
        if {$selem eq "" || ![$elem istype GP::Elemento]} continue
        if {![$selem istype GP::Elemento]} continue
        if {[$elem estasVorto ,] && [$selem estasVortoj {dum ĝis}]} {
            set se [lindex $astoj [expr {$i+2}]]
            set se1 [lindex $astoj [expr {$i+1}]]
            if {[$selem estasVorto dum] && $se ne "" && [$se istype GP::Elemento] && [$se estasVortoj {kiu kiuj}]} {
                # La solenajxo, dum kiu mi legis libron, estis tre longa
            } elseif {[$selem estasVorto ĝis] && $se1 ne "" && [$se1 istype GP::Elemento] && [$se1 estasVortoj {kiam}]} {
                # Mi scias, ĝis kiam mi tion faros.
                # , gxis kiam
            } else {
                # TODO La frato, kiu estis la plej juna, dum tuta nokto kaj tago parolis pri libroj.
                $selem class GP::Interjekcio
            }
        }
    }
}
SintaksAsto::main instproc provuKorektonSenSubjekto {} {
    # subjekto ne estis trovita
    # kazoj
    # 1) Post tagmezo, Petro kaj mi volis ripozi.
    # 2) Greenpeace volis tion.
    my instvar astoj
    foreach e $astoj {
        # aspektas kiel adjektivo aux adverbo sed estas nekonata (nomo) konstanto
        if {([$e istype GP::Adverbo] || [$e istype GP::Adjektivo]) && [$e estasUnuaGrandSkribita] && [$e estasNekonata]} {
            $e funkcio subj
            $e class GP::Konstanto
            return
        }
    }
    # Post tagmezo, Petro kaj mi volis ripozi.
    if {[my selektuVero {
        0 {filtruVeron istype SintaksAsto::pp}
        1 {filtruVeron istype SintaksAsto::konj}
        {filtruVeronKaj {selektuVero {1 {filtruVeron estasVorto ,}}}
            {selektuVero {2 1 {filtruVeron estasVorto kaj}}}}}]} {
                set pp [my selektu 0]
                set subj [my selektu {0 prenuNPParton 2}]
                set nppartoVera [my selektu {0 1 0}]
                set komo [my selektu {0 1 1}]
                $subj funkcio subj
                my movuAlAbsPozicio $subj 1
                my movuAlAbsPozicio $komo 1
                $pp tausxuAstojId 1 $nppartoVera
             }
}
SintaksAsto::main instproc raportuEraroAkuzativo {kolektilo elementoj proponoj} {
    set subj [my prenuSubjekton]
    if {$subj eq ""} return
    if {[$subj istype GP::TabloVorto] && ([$subj estasArto o] || ([$subj estasArto u] && [$subj estasBazo ki]))} {
        $kolektilo aliguEraron $subj "uzu akuzativon" [$subj set vorto]n
    } else {
        $kolektilo aliguEraron $elementoj "uzu akuzativon" $proponoj
    }
}
SintaksAsto::main instproc sercxiSenkomajSubfrazoj {} {
    my instvar radiko astoj
    set ri [lsearch $astoj $radiko]
    set duaVerbo ""
    set sedVortoIndex -1
    # Se vi konas la libron kiun vi aĉetis certe mi estus feliĉa.
    set diski 0
    for {set i [expr {$ri+1}]} {$i<[llength $astoj]} {incr i} {
        set arad [lindex $astoj $i]
        set e [$arad prenuRadiko]
        if {[$arad hasclass SintaksAsto] && ([$arad istype SintaksAsto::disk] || [$arad trovuUnunanInfanonKiu elem {[$elem istype SintaksAsto::disk]}] ne "")} {
            set diski $i
        } else {
            set le [$arad prenuLastan]
            if {[$le istype GP::Simbolo] && [$le estasVorto ,]} {
                break
            }
        }
        if {[$e istype GP::Konjunkcio] && [$e estasVorto sed]} {
            set sedVortoIndex $i
        }
        if {[$e istype GP::Verbo] && ![$e estasInfinitivo]} {
            set duaVerbo $arad
            set duaVerboIdx $i
            break
        }
    }
    if {$duaVerbo ne ""} {
        # Kiam mi laboras mi ne parolas.
        if {([my estasDemandaKomenco] && ![my estasDemando]) || ([[set unua [my prenuUnuanNeSimbolo]] hasclass GP::Konjunkcio] && [$unua estasCertaSubfrazo])} {
            if {$diski>0} {
                set di $diski
                incr di
                if {$di<=$duaVerboIdx} {
                    set trovita 1
                } else {
                    set trovita 0
                }
            } else {
                set trovita 0
                for {set di [expr {$i-1}]} {$di>$ri} {incr di -1} {
                    set e [lindex $astoj $di]
                    set eobj [$e prenuRadiko]
                    if {[$eobj hasclass GP::Substantivo] || ([$eobj hasclass GP::Adjektivo] && [$e istype SintaksAsto::np])} {
                        if {[$eobj prenuKazon] eq "nominativo"} {
                            set trovita 1
                            break
                        }
                    }
                }
            }
            if {$trovita} {
                set frazo [my info parent]
                set s1 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj 0 [expr {$di-1}]] -funkcio subfrazo -parenco [self]]
                set s2 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $di end] -funkcio subfrazo -parenco [self]]
                my debugAnalizo 0 $di "senkomaj subfrazoj 1"
                set astoj [list $s1 $s2]
                my class SintaksAsto::mainc
                $s1 sxercxiFrazokapon
                $s2 sxercxiFrazokapon
            }
        } elseif {$sedVortoIndex>0} {
            set frazo [my info parent]
            set s1 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj 0 [expr {$sedVortoIndex-1}]] -funkcio subfrazo -parenco [self]]
            set s2 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $sedVortoIndex  end] -funkcio subfrazo -parenco [self]]
            my debugAnalizo 0 [lindex $astoj $sedVortoIndex] "senkomaj subfrazoj 2"
            set astoj [list $s1 $s2]
            my class SintaksAsto::mainc
            $s1 sxercxiFrazokapon
            $s2 sxercxiFrazokapon
        }
    }
}
@ SintaksAsto::main instproc sxercxiCxefrazoj {} {
description {cxefrazoj estas gramatike plenaj sendependaj frazoj
ili estas deivigita je
, ke , cxar, kaj
frazoj kuniloj
}
}
SintaksAsto::main instproc sxercxiCxefrazoj {} {
    next
    my instvar astoj

    # kunligu "nur cxar"
    set nbr 0
    while {[set subFrazoAnalizoRez [my sxercxiSubfrazoj 4]]==1 && $nbr<100} {
        incr nbr
    }

    set frazo [my info parent]
    set flisto [list]
    # , kaj ke ĉu ĉar se sed dum ĝis
    # , (por sen krom anstataŭ malgraŭ) ke
    # , (post de) kiam
    # , nur kiam
    # , kiam
    # , sed se
    # , nur se
    # , nur cxar
    # , kiel se
    # Refactoring
    for {set x 0} {$x<[llength $astoj]-2} {incr x} {
        set elem [lindex $astoj $x]
        if {[$elem istype GP::Simbolo] && [$elem vorto] eq ","} {
            set selem [lindex $astoj [expr {$x+1}]]
            if {[$selem istype GP::Konjunkcio] && [$selem estasCertaSubfrazo]} {
                 $selem funkcio fkonj
                 $elem funkcio fkonj
                 lappend flisto $elem
                 incr x 2
            } elseif {[$selem istype GP::Prepozicio] && [$selem estasTempoebla]} {
                set sselem [lindex $astoj [expr {$x+2}]]
                if {[$sselem istype GP::TabloVorto] && [$sselem estasVorto kiam]} {
                     $selem funkcio fkonj
                     $sselem funkcio fkonj
                     $elem funkcio fkonj
                     lappend flisto $elem
                     incr x 2
                }
            } elseif {[$selem istype GP::TabloVorto] && [$selem estasVortoj {kiam}]} {
                 #$elem funkcio adv
                 # kio, kion ankaux poves tie esti
                 # mi scias, kion vi volas
                 # sed ne
                 # tion, kio estas necesa, oni devas fari.
                 $elem funkcio fkonj
                 lappend flisto $elem
                 incr x
            } elseif {[$selem istype SintaksAsto::grupo] && [$selem funkcio] eq "fkonj"} {
                 lappend flisto $elem
                 incr x
            }
        } elseif {[$elem istype SintaksAsto::grupo] && [$elem funkcio] eq "fkonj"} {
            lappend flisto $elem
        } elseif {([$elem istype GP::Prepozicio] && [$elem estasTempoebla]) || ([$elem istype GP::PrimitivaAdverbo] && [$elem estasVorto nur])} {
            set selem [lindex $astoj [expr {$x+1}]]
            # TODO kie kaj kiam vi lernas.
            if {[$selem istype GP::TabloVorto] && [$selem estasVorto kiam]} {
                $elem funkcio fkonj
                $selem funkcio fkonj
                lappend flisto $elem
                incr x
            }
        } elseif {[$elem istype GP::Elemento] && [$elem estasVortoj {ke ĉar ĉu kiam se kvankam}] && (![$elem exists funkcio] || [$elem funkcio] ne "fkonj")} {
            # mi sciis ke vi venos (sen komo)
            $elem funkcio fkonj
            lappend flisto $elem
            incr x
        }
    }
    if {[llength $flisto]>0} {
        set komenco 0
        foreach komo $flisto {
            set i [lsearch $astoj $komo]
            if {$i==0} {
                return 0
            }
            my debugAnalizo 0 $i "cxefrazoj"
            set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $komenco [expr {$i-1}]]]
            if {$komenco==0} {
                $f funkcio cxeffrazo
            } else {
                $f funkcio subfrazo
            }
            lappend lfrazoj $f
            set komenco $i
        }
        set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $komenco end] -funkcio subfrazo]
        lappend lfrazoj $f
        set astoj $lfrazoj
        my class SintaksAsto::mainc
        foreach f $lfrazoj {
            set trovita 0
            foreach a [$f astoj] {
                set robj [$a prenuRadiko]
                if {[$robj istype GP::Verbo]} {
                    set trovita 1
                    break
                }
            }
            if {!$trovita} {
                $f class SintaksAsto::npmain
                $f init
            }
        }
        return 1

    }
    return 0
}
@ SintaksAsto::main instproc sxercxiDialogoPriskribo {} {
description {Frazoj kiel priskribo de dialogo

Patro: Mi volas tion.
Filo: Mi tion niniam faros.}
}
SintaksAsto::main instproc sxercxiDialogoPriskribo {} {
    next
    my instvar astoj
    set x 0
    set frazo [my info parent]
    foreach a $astoj {
        if {[$a istype GP::Simbolo] && [$a vorto] eq ":"} {
            # frazo finas je : do ignoru
            if {$x == [llength $astoj]-1} {
                break
            }
            # frazoj laux tipo. Petro: Mi tion volas.
            if {$x==1 && [llength $astoj]>2} {
                set s1 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj 0 $x] -funkcio main]
                set s2 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj [expr {$x+1}] end] -funkcio dialogo]
                set astoj [list $s1 $s2]
                my funkcio baza
                my class SintaksAsto::mainc
                return
            } else {
                # frazoj laux tipo. Petro aldonis: Mi tion ankaux volas.
                foreach v [lrange $astoj 0 [expr {$x-1}]] {
                    if {[$v istype GP::Verbo] && [$v estasEldiro]} {
                        set s1 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj 0 $x] -funkcio main]
                        set s2 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj [expr {$x+1}] end] -funkcio dialogo]
                        set astoj [list $s1 $s2]
                        my funkcio baza
                        my class SintaksAsto::mainc
                        return
                    }
                }
                # du frazoj separitaj je :
                # ekz: La ĉefa sentenco estas: La venko venos certe.
                set s1 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj 0 $x] -funkcio main]
                set s2 [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj [expr {$x+1}] end] -funkcio main]
                set astoj [list $s1 $s2]
                my funkcio baza
                my class SintaksAsto::mainc
                return
            }
        }
        incr x
    }
}
SintaksAsto::main instproc sxercxiErarojn kolektilo {
    next
    my instvar astoj funkcio radiko
    if {![my exists radiko] || [my radiko] eq ""} {
        my sxercxiErarojnSenVerbo $kolektilo
        return
    }
    set radobj [$radiko prenuVerbRadiko]
    set havasSubjekton 0
    set havasNfvp 0
    set havasObjekton [expr {[my trovuKunFunkcio obj] ne ""}]
    foreach a [my astoj] {
        if {$a eq $radiko} continue
        if {[$a istype GP::Simbolo]} {
            if {[$a vorto] eq "," && ![$a havasFunkcion]} {
                $kolektilo aliguEraron $a "nenio funkcio por tiu komo trovita"
            }
            continue
        }
        if {![$a havasFunkcion]} {
            $kolektilo aliguEraron $a "nenio gramatika funkcio por elemento [$a prenuNomo] trovita"
            continue
        }
        switch [$a funkcio] {
            subj {
                set havasSubjekton 1
            }
            obj {
                if {![$radobj eblasObjekto]} {
                    if {[$radobj estasEst]} {
                        set rad [$a prenuRadiko]
                        if {[$a istype SintaksAsto::np]} {
                            foreach {k f prop} [$a prenuFrazpartoKazoNombro 0 [$rad estasPluralo]] {}
                            if {$k ne ""} {
                                $kolektilo aliguEraron [list $k $f] "post '[$radobj prenuBazanFormon]' uzu nominativon kiel komplementon" [list $prop]
                            }
                        } elseif {[$rad hasclass GP::NombroKazo]} {
                            $kolektilo aliguEraron $rad "post '[$radobj prenuBazanFormon]' uzu nominativon kiel komplementon" [list [esp::prenuKazoNombro [$rad prenuBazanFormon] 0 [$rad estasPluralo]]]
                        } else {
                            $kolektilo aliguEraron $rad "post '[$radobj prenuBazanFormon]' uzu nominativon kiel komplementon"
                        }
                    } else {
                        $radobj eraroNeTransitivaKunObjekto $kolektilo $a
                    }
                }
                set objobj $a
                set havasObjekton 1
            }
            iobj {
                # ignoru cxar iobj ekzistas nur cxar verbo tion ebligis
            }
            np {
               set necesasAkuzativon 0
               if {[$radobj eblasObjekto] && $havasObjekton==0} {
                   set necesasAkuzativon 1
               } else {
                   set nr [$a selektu prenuAntauxElemento]
                   if {$nr ne "" && [$nr istype GP::Verbo] && [$nr estasInfinitivo] && [$nr eblasObjekto]} {
                        set necesasAkuzativon 1
                   }
                }
                if {$necesasAkuzativon} {
                    set nrad [$a prenuRadiko]
                    if {[$a istype SintaksAsto::np]} {
                        foreach {k f prop} [$a prenuFrazpartoKazoNombro 1 [$nrad estasPluralo]] {}
                        if {$k ne ""} {
                            my raportuEraroAkuzativo $kolektilo [list $k $f] [list $prop]
                        } else {
                            $kolektilo aliguEraron [$a prenuRadiko] "substantiva frazo sen funkcio"
                        }
                    } elseif {[$a istype SintaksAsto::subsup]} {
                        set nrad [$a prenuRadiko]
                        $kolektilo aliguEraron $nrad "uzu akuzativon" [$nrad vorto]n
                    } else {
                        $kolektilo aliguEraron [$a prenuRadiko] "substantiva frazo sen funkcio"
                    }
                } else {
                    if {[EsperantoConf set gramRaportuCxion]} {
                        $kolektilo aliguEraron [$a prenuRadiko] "substantiva frazo sen funkcio"
                    }
                }
            }
            nfvp {
                if {![$radobj estasModVerbo]} {
                    # ignoru se infinitivo ne estas konata
                    if {[$a selektu {prenuRadiko estasNekonata}] ne "1"} {
                        $kolektilo aliguEraron [$a prenuRadiko] "verbo '[$radobj prenuBazanFormon]' ne ebligas infinitivan verban objekton"
                    }
                }
                set havasNfvp 1
            }
            adjp {
                my testuElementoSenFunkcio $kolektilo [$a prenuRadiko] $radobj $havasObjekton $havasSubjekton
            }
            advp -
            adv -
            attr -
            pp -
            fkonj -
            tempo -
            ignor -
            padv -
            padj -
            oattr -
            ocomp -
            ppinf -
            long -
            direkto -
            nfvpobj -
            ono -
            psubj {}
            comp {
                if {![$radobj eblasComp]} {
                    $kolektilo aliguEraron $a "verbo ne ebligas comp-objekton"
                }
            }
            default {
                my testuElementoSenFunkcio $kolektilo $a $radobj $havasObjekton $havasSubjekton
            }
        }
    }
    my testuSubjekton $havasSubjekton $havasObjekton $radiko $radobj $kolektilo
    # sensubjektaj verboj povas havi ankaux subjekto
    #else {
        #if {$havasSubjekton} {
            #$kolektilo aliguEraron $radiko "verbo ne akceptas subjekton"
        #}
    #}
    # Mi eblas fari tion.
    # Mi estas ebla fari tion.
    if {[$radobj estasBasaVorto ebli] && $havasSubjekton && $havasNfvp} {
        $kolektilo aliguEraron $radobj "eblas = estas ebla; uzu verbon 'povi' tie" [$radobj prenuGramatikeAnalogan povi]
    }

    # Somero komencas morgaux
    if {$radobj ne "" && !$havasObjekton && !$havasNfvp && [$radobj eblasObjekto] && ![$radobj estasOrdono]} {
        if {[$radobj estasBazajVortoj {balanci etendi fermi fini fleksi hejti klini
            kolekti komenci mezuri montri movi paŝti renversi rompi ruli skui streĉi
            svingi ŝanceli ŝanĝi ŝiri turni veki verŝi disvolvi nomi nomigi}] && ![my havasKeSubfrazon]} {

            set bbaza [$radobj prenuBazanFormon]
            if {[string range $bbaza end-2 end] eq "igi"} {
                set baza [string range $bbaza 0 end-3]i
            } else {
                set baza $bbaza
            }
            $kolektilo aliguEraron $radobj "la verbo '$bbaza' estas transitiva; eble uzu la 'iĝ' verbon" [$radobj prenuGramatikeAnalogan ${baza}ĝi]
        }
    }
    # mi volas, ke li legas la libron
    if {$funkcio eq "subfrazo" && [my selektu {prenuUnuanNeSimbolo {filtruVeron estasVorto ke}}] ne ""  && ![$radobj estasOrdono]} {
        if {[my selektu {prenuCxeffrazon prenuRadiko {filtruVeron estasBazajVortoj {deziri voli postuli}}}] ne ""} {
            $kolektilo aliguEraron $radobj "la verbo devas esti en ordona ordo ĉe deziri kaj voli" [string range [$radobj prenuBazanFormon] 0 end-1]u
        }
    }

    my testuKomenco $kolektilo
    if {$funkcio eq "subfrazo"} {
        my testuSubfrazon $kolektilo
    }
}
SintaksAsto::main instproc sxercxiErarojnSenVerbo kolektilo {
    my instvar astoj funkcio parenco
    # Mi ne scias, kion fari.
    if {![my estasDemando] && ![my estasEkkrio] && ![my estasKromaSenverba]} {
        foreach v $astoj {
            set v [$v prenuRadiko]
            if {[$v istype GP::Verbo]} {
                set b [string range [$v prenuBazanFormon] 0 end-1]
                # Mi volas, ke li legi la libron
                if {[my selektu {prenuCxeffrazon prenuRadiko {filtruVeron estasBazajVortoj {voli deziri postuli}}}] ne ""} {
                    set p [list ${b}u]
                } else {
                    set p [list ${b}as  ${b}is ${b}os ${b}us ${b}u]
                }
                $kolektilo aliguEraron $v "neinfinitiva verbo ne trovita" $p
                return
            }
        }
        $kolektilo aliguEraron [my prenuLastan] "finita verbo (kun finaĵoj -as, -is, -os, -us aŭ -u) ne trovita"
    } else {

    }
    return
}
SintaksAsto::main instproc sxercxiFrazokapon {} {
    next
    my instvar astoj funkcio parenco
    set verbo ""

    foreach elem $astoj {
        set e [$elem prenuRadiko]
        if {[$e hasclass GP::Verbo] && ![$e estasInfinitivo]} {
            set verbo $elem
            break
        }
    }
    if {[my vortoNombro $astoj]==1 && $verbo eq ""} {
        my class SintaksAsto::npmain
        my init
        return
    }
    set estasDemando [my estasDemando]
    if {$verbo eq ""} {
        if {$estasDemando} {
            foreach elem $astoj {
                set e [$elem prenuRadiko]
                if {[$e hasclass GP::Verbo] && [$e estasInfinitivo]} {
                    # En demandoj ankuax infinitivo povas roli kiel radiko
                    # EKZ: Kion fari tiuokaze?
                    set verbo $elem
                    $verbo funkcio radiko
                    my radiko $verbo
                    my definuFunkcioj
                    return
                }
            }
        }
        if {[info exists funkcio] && $funkcio in {ignor dialogo}} {
            my class SintaksAsto::npmain
        } elseif {![[my prenuLastan] istype GP::Simbolo] && !([info exists parenco] && $parenco ne "")} {
            # nomoj de cxapitroj ekzemple ne estas plenaj frazoj ekz. <h1></h1>
            my class SintaksAsto::npmain
        }
        my init
        return
    }
    $verbo funkcio radiko
    my radiko $verbo
    my sxercxiVerboFrazoj
    my kunliguDuoblajKonjunkcioj
    # por trink kaj por mangxi
    my kunliguKonjunkcioj
    my sercxiSenkomajSubfrazoj
    my definuFunkcioj
}
@ SintaksAsto::main instproc sxercxiIgnorPartoj {} {
description {Sercxas elemtoj limigitaj per interpukciaj simboloj

"" () - -

Ekzemple

la vorto "fino" estas mallonga.
Tiu persono (Artur Trzewik) estas viro.
La libro - plej parte - estas malbona.}
}
SintaksAsto::main instproc sxercxiIgnorPartoj {{starto 0}} {
    my instvar astoj
    set frazo [my info parent]
    set malfermi {( \" „ “ — [ «}
    set femi {) \" ” ” — ] »}
    set funkcioj {ignor citajxo citajxo citajxo dialogo ignor ignor}
    while 1 {
        set oi -1
        for {set i $starto} {$i<[llength $astoj]} {incr i} {
            set e [lindex $astoj $i]
            if {$i==0 && [my exists funkcio] && [my funkcio] eq "ignor"} continue
            if {![$e istype GP::Elemento]} continue
            if {[set oi [lsearch -exact $malfermi [$e vorto]]]>=0} {
                set komenco $i
                break
            }
        }
        if {$oi>=0} {
            set fino -1
            for {set i [expr {$i+1}]} {$i<[llength $astoj]} {incr i} {
                set e [lindex $astoj $i]
                if {![$e istype GP::Elemento]} continue
                if {[$e vorto] eq [lindex $femi $oi]} {
                    set fino $i
                    break
                }
            }
            if {$fino>0} {
                if {$fino==[llength $astoj]-1 && $komenco==0} {
                    # frazo estas nur ignor parto, do ignoru
                    return
                }
                set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $komenco $fino] -funkcio [lindex $funkcioj $oi]]
                if {[$f prenuNeInfVerbo] eq ""} {
                    $f class SintaksAsto::npmain
                    $f init
                } else {
                    $f sxercxiIgnorPartoj 1
                    $f sxercxiPlenajFrazoj
                    $f sxercxiCxefrazoj
                }
                set enfrazo 0
                # nur mallongaj cxitajxoj povas esti vera parto de frazo
                # kaj nur "
                # la antauxa vorto devas ne esti substantivo
                # mi parolis pri vorto "amo".
                set preIndekso [expr {$komenco-1}]
                if {$fino-$komenco<5 && $oi in {1 2 3} && ($preIndekso<0 || [my selektu [list $preIndekso prenuLastan {filtruVeron istype GP::Substantivo} {filtruVeron estasNePronomo}]] eq "")} {
                    $f analizu
                    $f mixin add SANePluAnalizuMix
                    set enfrazo 1
                }
                if {[llength [$f set astoj]]==3 && $enfrazo} {
                    # citajxo estas normala parto de frazo
                    # mi parolis pri "la bona lingvo".
                    $f set radiko [lindex [$f set astoj] 1]
                    [lindex [$f set astoj] 1] funkcio radiko
                    [lindex [$f set astoj] 1] funkcio parto
                    set astoj [lreplace $astoj $komenco $fino $f]
                } else {
                    # la frazo komencas je ignorparto, do alligu ignorparto al sekvanta elemento
                    if {$preIndekso<0} {
                        set preIndekso [expr {$fino+1}]
                        set preElemnto [lindex $astoj $preIndekso]
                        incr preIndekso [expr {$komenco-$fino-1}]
                        set iastoj [list $f $preElemnto]
                    } else {
                        set preElemnto [lindex $astoj $preIndekso]
                        set iradiko $preElemnto
                        set iastoj [list $preElemnto $f]
                    }
                    my debugAnalizo 0 $preIndekso "ignorparto"
                    set astoj [lreplace $astoj $komenco $fino]
                    set g [SintaksAsto::ignor new -childof $frazo -astoj $iastoj -funkcio ignor -radiko $preElemnto]
                    lset astoj $preIndekso $g
                }
            } else {
                set malfermi [lreplace $malfermi $oi $oi]
                set femi [lreplace $femi $oi $oi]
                continue
            }
        } else {
            return
        }
    }
}
@ SintaksAsto::main instproc sxercxiKajKomaSubfrazoj {} {
description {La metodo sxcarcxas subfrazoj separitaj per komo aux "kaj".
La subfrazoj devas havi neinfinitivan verbon kaj subjekton.
Ekzemplo:
   Li laboris kaj ŝi ripozis.
   Li laboris, ŝi ripozis}
}
SintaksAsto::main instproc sxercxiKajKomaSubfrazoj {{nurPlenajFrazoj 0}} {
    # sercxas subfrazoj de fino
    # subfrazoj havas verbon kaj substantivon
    # Mi estas programisto kaj vi estas instruisto.
    # escepetoj
    # Ĉie troviĝis dikaj arboj kaj arbustoj, malantaŭ kiuj oni povis kaŝi sin.
    # Mi estas programisto kaj vi estas instruisto, kiu lernas.
    # my halt

    # nurPlenajFrazoj 1
    # - nur "aux" kaj "kaj" kiel konjunkcio
    # - havas verbon kaj subjekton

    my instvar astoj
    set frazo [my info parent]
    # subj verbo konj
    set kelemento [list {{} {} {}}]
    set i 0
    set subj ""
    set verb ""
    set x 0
    set estisKomo 0

    # ignoru lastan elemenon
    foreach e [lrange $astoj 0 end-1] {
        incr x
        # la frazo povas komenci per , - ignoru
        # nur kiam verbo kaj subjekto ekzistas
        if {$x!=1 && [$e istype GP::Konjunkcio] && [$e estasVortoj {kaj aŭ}]} {
            if {$nurPlenajFrazoj && $estisKomo} {
                set estisKomo 0
                continue
            }
            set estisKomo 0

            lappend kelemento {{} {} {}}
            incr i
            lset kelemento $i 2 $e
            set subj ""
            set verb ""
            $e funkcio fkonj
            continue
        }
        if {$nurPlenajFrazoj==0 && [$e istype GP::Simbolo] && ([lsearch {, \; - —} [$e vorto]]>=0)} {
            if {$x==1} {
                set x 0
            } else {
                lappend kelemento {{} {} {}}
                incr i
                lset kelemento $i 2 $e
                set subj ""
                set verb ""
                $e funkcio fkonj
            }
            continue
        } elseif {[$e istype GP::Simbolo] && [$e vorto] eq "," && $x>1} {
            if {$i>0} {
                # por: Ĉie troviĝis dikaj arboj kaj arbustoj, malantaŭ kiuj oni povis kaŝi sin.
                # testu:
                if {$verb ne ""} {
                    # Mi estas programisto kaj vi estas instruisto, kiu lernas.
                    lappend kelemento {{} {} {}}
                    incr i
                    lset kelemento $i 2 $e
                    $e funkcio fkonj
                } else {
                    # ignoru. estas eble relativa frazo (testu cxe nurPlenajFrazoj 0)
                    set kelemento [lrange $kelemento 0 end-1]
                    incr i -1
                }
                set subj ""
                set verb ""
                continue
            } else {
                # testu: Mi konas librojn, kiujn ricxaj kaj edukitaj homoj legas.
                # TODO
                set estisKomo 1
            }
        }
        set eobj [$e prenuRadiko]
        if {[$eobj hasclass GP::Verbo] && ![$eobj estasInfinitivo]} {
           if {$verb eq ""} {
                set verb $e
                lset kelemento $i 1 $e
                continue
            } else {
                # Kiam Nikodemo batas Jozefon, tiam Nikodemo estas la batanto kaj Jozefo estas la batato.
                set estisKomo 0
            }
        }
        if {$subj eq "" && [$eobj hasclass GP::Substantivo] && [$eobj prenuKazon] eq "nominativo"} {
            lset kelemento $i 0 $e
            set subj $e
            continue
        }
    }
    # forigi partoj sen verbo kaj sen subjekto
    if {$nurPlenajFrazoj} {
        set nelemento [list]
        foreach n $kelemento {
            if {[lindex $n 0] ne "" && [lindex $n 1] ne ""} {
                lappend nelemento $n
            }
        }
        set kelemento $nelemento
    }
    if {[llength $kelemento]<=1} return
    set nelem [list]
    set lastaSubfrazo [lindex $kelemento 0]
    set lastaIndeko 0
    set subjFrazo ""
    foreach komo [lrange $kelemento 1 end] {
        set i [lsearch $astoj [lindex $komo 2]]
        # marku konjunkcioj post "," kiel havanta funkcio
        my debugAnalizo 0 $i "kajkomasubfrazoj"
        set iobj [lindex $astoj $i]
        if {[$iobj istype GP::Simbolo] && [$iobj vorto] eq ","} {
            set iobj [lindex $astoj [expr {$i+1}]]
            if {[$iobj istype GP::Konjunkcio]} {
                $iobj funkcio fkonj
            }
        }
        set tastoj [lrange $astoj $lastaIndeko [expr {$i-1}]]
        if {[my vortoNombro $tastoj]==1} {
            set typ npmain
        } else {
            if {[lindex $lastaSubfrazo 0] ne ""} {
                set typ main
            } else {
                set typ smain
            }
        }
        set f [SintaksAsto::$typ new -childof $frazo -astoj $tastoj]
        $f funkcio $typ
        lappend lfrazoj $f
        # partoj povas esti ankaux npmain (sen verba parto)
        # normale tio estas ignorpartoj
        # vidu sxercxiIgnorPartoj
        if {[$f hasclass SintaksAsto::main] && [$f prenuNeInfVerbo] eq ""} {
            $f class SintaksAsto::npmain
            $f init
        }
        set lastaIndeko $i
        set lastaSubfrazo $komo
    }
    set tastoj [lrange $astoj $lastaIndeko end]
    if {[my vortoNombro $tastoj]==1} {
        set typ npmain
    } else {
        if {[lindex $lastaSubfrazo 0] ne ""} {
            set typ main
        } else {
            set typ smain
        }
    }
    set f [SintaksAsto::$typ new -childof $frazo -astoj $tastoj]
    $f funkcio $typ
    lappend lfrazoj $f
    set astoj $lfrazoj
    my class SintaksAsto::mainc
    return 1
}
@ SintaksAsto::main instproc sxercxiKajSubfrazojDeFino {} {
description {sxercas verbaj frazoj kun unu subjekto laux
   Li volis mangxi vespere kaj iri hejmen}
}
SintaksAsto::main instproc sxercxiKajSubfrazojDeFino {} {
    my instvar astoj
    set frazo [my info parent]
    set start [expr {[llength $astoj]-1}]
    set fino [expr {[llength $astoj]-1}]
    if {[[lindex $astoj $fino] istype GP::Simbolo]} {
        incr fino -1
    }
    while 1 {
        for {set x $start} {$x>0} {incr x -1} {
            set elem [lindex $astoj $x]
            if {[$elem istype GP::Konjunkcio] && ([$elem vorto] eq "kaj" || [$elem vorto] eq "aŭ")} {
                break
            }
            if {[$elem istype GP::Simbolo] && [$elem vorto] eq ","} {
                break
            }
        }
        if {$x==0} return
        set f1 [lrange $astoj 0 [expr {$x-1}]]
        set f2 [lrange $astoj $x $fino]

        set verbof1 [ide::ldetect elem $f1 {[[set r [$elem prenuRadiko]] istype GP::Verbo] && ![$r estasInfinitivo]}]
        set verbof2  [ide::ldetect elem $f2 {[[set r [$elem prenuRadiko]] istype GP::Verbo] && [$r estasInfinitivo]}]
        # frazo: Mi povas kanti kaj li povas muzikumi.
        set verbof3 [ide::ldetect elem $f2 {[[set r [$elem prenuRadiko]] istype GP::Verbo] && ![$r estasInfinitivo]}]
        if {$verbof1 ne "" && $verbof2 ne "" && $verbof3 eq ""} {
            set f1rad [$verbof1 prenuRadiko]
            if {[$f1rad estasModVerbo]} {
                my debugAnalizo 0 $x "kajsubfrazojdefino"
                set f2 [SintaksAsto::nfvp new -childof [my info parent] -astoj $f2]
                $f2 initParencon {}
                $f2 sxercxiFrazokapon
                $f2 funkcio nfvp
                [lindex [$f2 set astoj] 0] funkcio fkonj
                #$f1rad aliguKajFrazo $f2
                set astoj [lreplace $astoj $x $fino $f2]
                set start [expr {[llength $f1]-1}]
                set fino $start
                continue
            }
        }
        break
    }
}
@ SintaksAsto::main instproc sxercxiKomaIgnorfrazoj {} {
description {Sercxas komaj ensxutoj. Ekzemplo:
   Mi konas la aktorinon, filinon de nia instruisto, jam ok jarojn.}
}
SintaksAsto::main instproc sxercxiKomaIgnorfrazoj {} {
    my instvar astoj
    set frazo [my info parent]
    # la komando unue dividas frazo je partoj kiu estas separita per , aux kaj.
    set subfrazoj [list]
    set subfrazo [list]
    # subjekto verbo infinitivaverbo
    set subfrazojDet [list]
    set kelemento [list {} {} {}]
    set x 0
    set verbo ""
    set subj ""
    foreach e $astoj {
        incr x
        if {[$e istype GP::Simbolo] && [$e vorto] eq ","} {
            # ignoru ankaux ", kaj"
            if {$x==1} {
                set x 0
            } else {
                lappend subfrazoj $subfrazo
                lappend subfrazojDet $kelemento
                set kelemento [list {} {} {}]
                set subfrazo [list]
                $e funkcio fkonj
                set verbo ""
                set subj ""
            }
            lappend subfrazo $e
            continue
        }
        lappend subfrazo $e
        set eobj [$e prenuRadiko]
        if {$verbo eq "" && [$eobj hasclass GP::Verbo] && ![$eobj estasInfinitivo]} {
            set verbo $e
            lset kelemento 1 $e
            continue
        }
        if {$subj eq "" && [$eobj hasclass GP::Substantivo] && [$eobj prenuKazon] eq "nominativo"} {
            lset kelemento 0 $e
            set subj $e
            continue
        }
    }
    if {[llength $subfrazo]>1} {
        lappend subfrazoj $subfrazo
        lappend subfrazojDet $kelemento
    }
    if {[llength $subfrazoj]==1} {return 0}
    set x 0
    set rezfrazoj [list]
    foreach disk $subfrazojDet {
        set subfrazo [lindex $subfrazoj $x]
        # subfrazo havas nur unu frazparton aux ne havas verbon
        if {[my vortoNombro $subfrazo]==1 || [lindex $disk 1] eq ""} {
            if {$x==0} {
                lappend rezfrazoj $subfrazo
            } else {
                # prenu komo de sekvanta frazo al tiu frazo
                set estasLasta [expr {$x+1==[llength $subfrazoj]}]
                if {!$estasLasta} {
                    set sekfrazo [lindex $subfrazoj [expr {$x+1}]]
                }
                # se sekvanta frazo ankaux ne havas verbon ignoru, kaj lasta frazo ankaux
                set preVerb [lindex [lindex $subfrazojDet [expr {$x-1}]] 1]
                set postVerb [lindex [lindex $subfrazojDet [expr {$x+1}]] 1]
                if {!$estasLasta && (($preVerb eq "" && $postVerb eq "") || ($preVerb ne "" && $postVerb ne ""))} {
                    lappend rezfrazoj $subfrazo
                } else {
                    if {!$estasLasta} {
                        lappend subfrazo [lindex $sekfrazo 0]
                    }
                    # sxercxi aligoelemento
                    set prefrazo [lindex $rezfrazoj end]
                    set aelemento [lindex $prefrazo end]
                    my debugAnalizo 0 [lsearch $astoj [lindex $subfrazo 0]] "komaingrosubfrazo"
                    set dfrazo [SintaksAsto::npmain new -childof $frazo -astoj $subfrazo -funkcio npmain]
                    set nelem [$aelemento generuDiskripto $dfrazo]
                    if {$nelem ne $aelemento} {
                        lset prefrazo end $nelem
                    }
                    # kunligita frazo
                    if {$estasLasta} {
                        set nfrazo $prefrazo
                    } else {
                        set nfrazo [concat $prefrazo [lrange [lindex $subfrazoj [expr {$x+1}]] 1 end]]
                    }
                    lset rezfrazoj end $nfrazo
                    set astoj [list]
                    foreach f $rezfrazoj {
                        foreach e $f {
                            lappend astoj $e
                        }
                    }
                    foreach f [lrange $subfrazoj [expr {$x+2}] end] {
                        foreach e $f {
                            lappend astoj $e
                        }
                    }
                    break
                }
            }
        } else {
            lappend rezfrazoj $subfrazo
        }
        incr x
    }
    if {![info exists nfrazo]} {return 0}
    while {[my sxercxiKomaIgnorfrazoj]} {}
    return 1
}
SintaksAsto::main instproc sxercxiPlenajFrazoj {} {
    next
    my instvar astoj
    set frazFiniloj [list . ? ! \;]
    set frazo [my info parent]
    set flisto [list]
    for {set x 1} {$x<[llength $astoj]-2} {incr x} {
        set elem [lindex $astoj $x]
        if {[$elem istype GP::Simbolo] && [lsearch $frazFiniloj [$elem vorto]]>=0} {
            lappend flisto $elem
        }
    }
    if {[llength $flisto]>0} {
        set komenco 0
        foreach komo $flisto {
            set i [lsearch $astoj $komo]
            my debugAnalizo 0 $komenco "plenaj frazoj"
            set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $komenco [expr {$i-1}]]]
            if {$komenco==0} {
                $f funkcio cxeffrazo
            } else {
                $f funkcio subfrazo
            }
            lappend lfrazoj $f
            set komenco $i
        }
        set f [SintaksAsto::main new -childof $frazo -astoj [lrange $astoj $komenco end] -funkcio main]
        lappend lfrazoj $f
        set astoj $lfrazoj
        my class SintaksAsto::mainc
        return 1

    }
}
@ SintaksAsto::main instproc sxercxiRilativanFrazon {} {
description {Sercxas relativajn subfrazojn kun ekzemple:
Nur relativajn frazojn kun: kiu, kies, kia, kie, (ki*) kaj ankaux prepozicio+ki*

Mi legis la libron, kiun mi acxetis hieraux.
}
}
SintaksAsto::main instproc sxercxiRilativanFrazon {} {
    my instvar astoj
    set frazo [my info parent]
    set flisto [list]
    set komo 0
    set elem [lindex $astoj 0]
    if {[$elem istype GP::Simbolo] && [$elem vorto] eq ","} {
        set start 2
    } else {
        set start 1
    }
    for {set x $start} {$x<[llength $astoj]-2} {incr x} {
        set elem [lindex $astoj $x]
        if {[$elem istype GP::Simbolo] && [$elem vorto] eq ","} {
            set selem [lindex $astoj [expr {$x+1}]]
            set uselem [$selem prenuUnuan]
            if {[$uselem istype GP::TabloVorto] && [$uselem bazo] eq "ki"} {
                 set komo $x
                 break
            }
            if {[$selem istype SintaksAsto::pp]} {
                set sselem [lindex [$selem astoj] end]
                if {[$sselem istype GP::TabloVorto] && [$sselem bazo] eq "ki"} {
                     set komo $x
                     break
                }
            }
        } elseif {[$elem istype GP::TabloVorto] && [$elem bazo] eq "ki"} {
            set komo $x
            break
        } elseif {[$elem istype SintaksAsto::pp]} {
                set sselem [lindex [$elem astoj] end]
                if {[$sselem istype GP::TabloVorto] && [$sselem bazo] eq "ki"} {
                     set komo $x
                     break
                }
        }
    }
    if {$komo>0} {
        my aliguRilativanFrazon $komo
        while {[my sxercxiRilativanFrazon]} {}
        return 1
    }
    return 0
}
@ SintaksAsto::main instproc sxercxiVerboFrazoj {} {
description {Sxercxi "not finite" verbofrazoj.
verbo kaj infinitivo povas ne esti kune}
}
SintaksAsto::main instproc sxercxiVerboFrazoj {} {
    my instvar astoj radiko
    set frazo [my info parent]
    lappend vlist [list]
    set i 0
    set startindex -1
    # tiu metodo provas kreski nfvp frazparton
    # mi volas [legi tiun libron] morgaux
    # mi volas [legi tiun libron morgaux]
    set radvorto [my selektu {prenuRadiko prenuBazanFormon}]
    set radobj [my selektu prenuRadiko]

    # sercxu de dekstra flanko pro "mi volas havi la okazon legi la libron"
    for {set i [expr {[llength $astoj]-1}]} {$i>=0} {incr i -1} {
        set a [lindex $astoj $i]
        if {$a eq ""} {
            continue
        }
        if {[$a istype SintaksAsto::ktempo]} {
            set aobj [$a prenuEsti]
        } else {
            set aobj [$a prenuRadiko]
        }
        if {[$aobj istype GP::Verbo] && [$aobj estasInfinitivo]} {
             set verboi $i
             set livaLimo $i
             incr i
             set havasObjekton 0
             # dekstra limo
             while {$i<[llength $astoj]} {
                 set relem [lindex $astoj $i]
                 set elem [$relem prenuRadiko]
                 if {[$elem istype GP::Simbolo] || [$elem istype GP::Konjunkcio] || [$relem istype GP::Prepozicio] || ([$elem istype GP::TabloVorto] && [$elem estasBazo ki])} {
                     break
                 }
                 if {[$elem istype GP::Verbo] && !([$elem estasInfinitivo] && [$aobj estasModVerbo])} {
                     break
                 }
                 # Tial por iri en la familion mi petis forpermeson.
                 # Mi venis por farbi la domon blua.
                 # Mi volas nomi lin komputisto
                 # Mi lernis por esti komputisto.
                 if {[$elem hasclass GP::NombroKazo] && [$elem estasNominativo] && !([$aobj estasEst] || [$aobj havasDerivoPriskribon socomp])  && !([$aobj havasDerivoPriskribon aocomp] && [$elem istype GP::Adjektivo])} {
                     break
                 }
                 if {[$elem hasclass GP::NombroKazo] && [$elem estasAkuzativo]} {
                     set havasObjekton 1
                 }
                 incr i
             }
             incr i -1
             # cxe tiuj verboj ne pligrandigi al maldekstra flanko
             # mi vidis lin [mangxi bulkon]
             # aliekaze
             # mi petas [lin vidi cxiam]
             set limo ""
             if {$radobj ne "" && [$radobj havasDerivoPriskribon objmod]} {
                 set t [expr {$verboi-1}]
                 # li promesis tion por helpi vin.
                 # Ŝi opiniis sin nekonvena respondi pri tio.
                 if {$t>$startindex} {
                     set unua [lindex $astoj $t]
                     if {([$unua istype GP::Prepozicio] && [$unua eblasKunInf]) || ([$unua exists funkcio] && [$unua set funkcio] eq "fkonj")} {
                         set startindex [expr {$t-1}]
                         set limo prepozicio
                     } elseif {[[set dunua [$unua prenuLastan]] istype GP::Adjektivo] && [$dunua havasDerivoPriskribon mod]} {
                         # Li estas kapabla fari tion.
                         set startindex [expr {$t-1}]
                         set limo adjektivo
                     } else {
                         set startindex [expr {$verboi-1}]
                     }
                 } else {
                     set startindex [expr {$verboi-1}]
                 }
             } else {
                 # trovu solan "por" ... kiu ankaux estas maldekstra limo de nfvp
                 set t [expr {$verboi-1}]
                 while {$t>$startindex} {
                     set unua [lindex $astoj $t]
                     # ([$unua istype GP::Prepozicio] && [$unua eblasKunInf]) || ([$unua exists funkcio] && [$unua set funkcio] eq "fkonj")
                     # Subite regis silento, ĉar paroli estis malpermesite de post la krucosigno.
                     if {[$unua istype SintaksAsto::grupo] && [$unua havasMerkmalon antauxol]} {
                         # Vi pagas antaŭ ol preni la varon.
                         set startindex [expr {$t-1}]
                         set limo prepozicio
                         break
                     } elseif {([$unua istype GP::Prepozicio] && [$unua eblasKunInf])} {
                         # Mi venas por vidi vin.
                         set startindex [expr {$t-1}]
                         set limo prepozicio
                         break
                     } elseif {[[set dunua [$unua prenuLastan]] istype GP::Substantivo] && [$dunua havasDerivoPriskribon mod]} {
                         # Mi havas la okazon vidi vin.
                         set startindex [expr {$t-1}]
                         set limo substantivo
                         break
                     } elseif {[[set dunua [$unua prenuRadiko]] istype GP::Substantivo] && [$dunua havasDerivoPriskribon mod]} {
                         # Mi scis pri kopodo de frato vidi vin.
                         set startindex [expr {$t-1}]
                         set dunua $unua
                         set limo substantivo
                         break
                     } elseif {[[set dunua [$unua prenuLastan]] istype GP::Adjektivo] && [$dunua havasDerivoPriskribon mod]} {
                         # Li estas kapabla fari tion.
                         set startindex [expr {$t-1}]
                         set limo adjektivo
                         break
                     } elseif {[[set dunua [$unua prenuLastan]] istype GP::Adverbo] && [$dunua havasDerivoPriskribon imod]} {
                         set startindex [expr {$t-1}]
                         set limo adverbo
                         break
                     } elseif {[[set dunua [$unua prenuLastan]] istype GP::Adverbo] && [$dunua hasclass GP::Partizipo] && [$dunua havasDerivoPriskribon mod]} {
                         # Mi faris tion celante plibonigi la programon
                         set startindex [expr {$t-1}]
                         set limo adverbo
                         break
                     }
                     set urad [$unua prenuRadiko]
                     # Li volis permesi lin legi tiun libron
                     if {[$urad hasclass GP::NombroKazo] && ([$urad estasNominativo] || [$urad estasAkuzativo] && (![$aobj eblasObjekto] || $havasObjekton))} {
                          incr t
                          set startindex [expr {$t-1}]
                          break
                     }
                     if {[$urad istype GP::Simbolo] || [$urad istype GP::Konjunkcio] || [$urad istype GP::Verbo] || [$unua istype GP::Prepozicio]} {
                         incr t
                         set startindex [expr {$t-1}]
                         break
                     }
                     incr t -1
                 }
             }
             if {$i>$startindex} {
                 if {$i-1==$startindex && [$a istype SintaksAsto::nfvp]} {
                     set startindex -1
                     # incr i
                     continue
                 }
                 set unua [lindex $astoj [expr {$startindex+1}]]
                 my debugAnalizo 0 [expr {$startindex+2}] "nfvp $limo"
                 if {$startindex+1!=$i && $limo eq "prepozicio"} {
                     # mi venis por vidi vin
                     set f [SintaksAsto::nfvp new -childof $frazo -astoj [lrange $astoj [expr {$startindex+2}] $i] -radiko $a -funkcio nfvp]
                     set ppinf [SintaksAsto::ppinf new -childof $frazo -astoj [list $unua $f] -radiko $unua -funkcio ppinf]
                     set astoj [lreplace $astoj [expr {$startindex+1}] $i $ppinf]
                     $f sxercxiFrazokapon
                 } else {
                     if {$limo eq "substantivo"} {
                         set f [SintaksAsto::nfvp new -childof $frazo -astoj [lrange $astoj [expr {$startindex+2}] $i] -radiko $a -funkcio nfvp]
                         set astoj [lreplace $astoj [expr {$startindex+2}] $i]
                         set subsup [SintaksAsto::subsup new -childof $frazo -astoj [list $dunua $f] -radiko $dunua -funkcio [$dunua prenuFunkcioNomo]]
                         [$dunua parenco] tausxuAstoj $dunua $subsup
                         $f sxercxiFrazokapon
                     } elseif {$limo eq "adjektivo"} {
                         set f [SintaksAsto::nfvp new -childof $frazo -astoj [lrange $astoj [expr {$startindex+2}] $i] -radiko $a -funkcio nfvp]
                         set astoj [lreplace $astoj [expr {$startindex+2}] $i]
                         set subsup [SintaksAsto::adjsup new -childof $frazo -astoj [list $dunua $f] -radiko $dunua -funkcio [$dunua prenuFunkcioNomo]]
                         [$dunua parenco] tausxuAstoj $dunua $subsup
                         $f sxercxiFrazokapon
                     } elseif {$limo eq "adverbo"} {
                         set f [SintaksAsto::nfvp new -childof $frazo -astoj [lrange $astoj [expr {$startindex+2}] $i] -radiko $a -funkcio nfvp]
                         set astoj [lreplace $astoj [expr {$startindex+2}] $i]
                         set subsup [SintaksAsto::advsup new -childof $frazo -astoj [list $dunua $f] -radiko $dunua -funkcio [$dunua prenuFunkcioNomo]]
                         [$dunua parenco] tausxuAstoj $dunua $subsup
                         $f sxercxiFrazokapon
                     } else {
                         set f [SintaksAsto::nfvp new -childof $frazo -astoj [lrange $astoj [expr {$startindex+1}] $i] -radiko $a -funkcio nfvp]
                         set astoj [lreplace $astoj [expr {$startindex+1}] $i $f]
                         $f sxercxiFrazokapon
                     }
                 }
                 set startindex -1
             }
             # Mi volas helpi lerni tion.
             set i [expr $livaLimo]
        }
    }
}
SintaksAsto::main instproc testuElementoSenFunkcio {kolektilo elemento radobj havasObjekton havasSubjekton} {
    set a $elemento
    if {[$a istype GP::Nekonata]} {
        return
    }
    if {[$a havasMerkmalon ignoruparto]} {
        return
    }
    # cxiuj la homoj
    if {[$a hasclass GP::Substantivo] || ([$a hasclass GP::Adjektivo] && [$radobj istype GP::Verbo] && [$radobj estasEst])} {
        set folioj [my prenuFoliojn]
        foreach e1 $folioj e2 [lrange $folioj 1 end]  {
            if {$e1 ne "" && [$e1 estasBasaVorto ĉiu] && $e2 ne "" && [$e2 estasVorto la]} {
                $kolektilo aliguEraron $e2 "[$e1 prenuVorton] estas difinilo. 'La' estas superflua" "{}"
                return
            }
        }
    }

    if {[$a hasclass GP::Substantivo] && [$radobj eblasObjekto] && $havasObjekton==0} {
        set nr [$a selektu prenuAntauxElemento]
        if {$nr ne "" && [$nr istype GP::PersonPronomo] && [$a prenuKazon] eq [$nr prenuKazon] && [$a estasNePronomo]} {
            # mi patro -> mia patro
            # sed ne  mi vi vidas -> mia vi vidas
            set f ""
            regexp {.+?(j|n|jn)$} [$a vorto] _ f
            $kolektilo aliguEraron $nr "uzu personan pronomon por priskribi la substantivon" [$nr prenuBazanFormon]a$f
            return
        }
        my raportuEraroAkuzativo $kolektilo [$a prenuRadiko] [$a set vorto]n
        return
    } elseif {[$a istype GP::Substantivo] || [$a istype SintaksAsto::subsup]} {
        if {[$a istype SintaksAsto::subsup]} {
            set a [$a prenuRadiko]
        }
        set nr [$a selektu prenuAntauxElemento]
        if {$nr ne "" && [$nr istype GP::TabloVorto] && [$nr estasArto o] && [$a prenuKazon] eq [$nr prenuKazon]} {
            # tio libro -> tiu libro
            set f ""
            regexp {.+?(j|n|jn)$} [$a vorto] _ f
            $kolektilo aliguEraron $nr "uzu u-formon por priskribi substantivon " [$nr set bazo]u$f
            return
        } elseif {$nr ne "" && [$nr istype GP::PersonPronomo] && [$a prenuKazon] eq [$nr prenuKazon]} {
            # mi patro -> mia patro
            set f ""
            regexp {.+?(j|n|jn)$} [$a vorto] _ f
            $kolektilo aliguEraron $nr "uzu personan pronomon por priskribi substantivon " [$nr prenuBazanFormon]a$f
            return
        } elseif {$nr ne "" && [$nr istype GP::TabloVorto] && [$nr estasArto u] && [$a prenuKazon] eq "nominativo" && [$nr prenuKazon] eq "akuzativo"} {
            # tiun laboro
            regexp {.+?(j|n|jn)$} [$nr vorto] _ f
            $kolektilo aliguEraron $a "uzu akuzativon " [$a prenuBazanFormon]$f
        } elseif {$nr ne "" && [$nr istype GP::Verbo] && [$nr estasInfinitivo] && [$nr eblasObjekto]} {
            $kolektilo aliguEraron $a "uzu akuzativon" [$a set vorto]n
            return
        } elseif {[$radobj eblasObjekto] && !$havasObjekton} {
            $a aliguKazoEraro $kolektilo 1 "uzu akuzativon"
            return
        }

        if {[$a istype GP::PersonPronomo] || [[$a prenuRadiko] istype GP::PersonPronomo]} {
            # Mi vidis mi junulinon.
            set se [$a selektu {prenuSekvanFraton prenuRadiko}]
            if {$se ne "" && [$se istype GP::Substantivo]} {
                set r [$a prenuRadiko]
                # Sed ne - Mi vidis mi tiun junulinon.
                if {[$se estasNeDifinita [$se miAuxRadikaElemento] [$se prenuKazon]]} {
                    $kolektilo aliguEraron $r "uzu posesivprononom" [esp::prenuKazoNombro [$r prenuBazanFormon]a [$se estasAkuzativo] [$se estasPluralo]]
                    return
                }
            }
        }
    } elseif {[$a istype GP::Verbo] && [$radobj estasModVerbo]} {
        $kolektilo aliguEraron [$a prenuRadiko] "uzu infinitivon tie" [$a prenuBazanFormon]
        return
    } elseif {[$a istype GP::Prepozicio]} {
        if {![$a estasDusignifa]} {
            set nr [$a selektu prenuSekvanFraton]
            if {$nr ne "" && [set rad [$nr prenuRadiko]] ne "" && [$rad hasclass GP::NombroKazo] && [$rad estasAkuzativo]} {
                $nr aliguKazoEraro $kolektilo 0 "prepozicio '[$a vorto]' nur kun nominativo"
                return
            }
        }
        set sr [$a selektu prenuSekvaElemento]
        if {$sr ne "" && [$sr istype GP::Adverbo]} {
            set ssr [$sr selektu prenuSekvaElemento]
            if {$ssr ne "" && [$ssr hasclass GP::Substantivo]} {
                $kolektilo aliguEraron $sr "uzu adjektivon" [string range [$sr set vorto] 0 end-1]a[string range [$ssr prenuGramFinilon] 1 end]
                return
            }
        }
        if {$sr ne "" && [$sr istype GP::Verbo] && [$sr estasInfinitivo]} {
            set v [string range [$sr prenuBazanFormon] 0 end-1]
            if {[string range $v end-1 end] ne "ad"} {
                append v ad
            }
            append v o
            $kolektilo aliguEraron $sr "uzu substantivon post prepozio" $v 1
            set vrad [$sr miAuxRadikaElemento]
            if {[$vrad istype SintaksAsto::nfvp]} {
                set obj [$vrad trovuKunFunkcio obj]
                if {$obj ne ""} {
                    if {[$obj istype SintaksAsto::subsup]} {
                        set obj [$obj radiko]
                    }
                    if {[$obj istype SintaksAsto::np] || [$obj hasclass GP::NombroKazo]} {
                        set objr [$obj prenuRadiko]
                        $kolektilo aliguEraron $obj "uzu formon substantivo + de ..." [list "de [lindex [$obj prenuFrazpartoKazoNombro 0 [$objr estasPluralo]] 2]"]
                    }
                }
            }
            return
        }
    } elseif {[$a istype GP::Adjektivo] && ![$radobj estasEst] && ![$a havasDerivoPriskribon pverbo]} {
        set se [$a selektu prenuSekvaElemento]
        if {$se ne "" && [$se istype GP::Substantivo]} {
            set f ""
            regexp {.+?(j|n|jn)$} [$se vorto] _ f
            $kolektilo aliguEraron $a "uzu ĝustan kazon aŭ nombron" [$a prenuBazanFormonKazoNombro]$f
        } else {
            set korekto [string range [$a prenuBazanFormonKazoNombro] 0 end-1]e
            $kolektilo aliguEraron $a "uzu adverbon por priskribi la agon" $korekto
        }
        return
     } elseif {[$a istype GP::PosesivPronomo] && ![$radobj estasEst]} {
        set se [$a selektu prenuSekvaElemento]
        if {$se ne "" && [$se hasclass GP::NombroKazo]} {
            set f ""
            regexp {.+?(j|n|jn)$} [$se vorto] _ f
            $kolektilo aliguEraron $a "uzu ĝustan kazon aŭ nombron" [$a prenuBazanFormonKazoNombro]$f
            return
        }
    } elseif {[$a istype GP::Difinilo] && [$a estasVorto la]} {
        set sr [$a selektu prenuSekvaElemento]
        if {$sr ne "" && [$sr istype GP::PosesivPronomo]} {
            $kolektilo aliguEraron $a "'la' ne povas stari kune kun posesiva pronomo" [list {}]
            return
        }
        if {$sr ne "" && [$sr istype GP::Adverbo]} {
            set ssr [$sr selektu prenuSekvaElemento]
            if {$ssr ne "" && [$ssr hasclass GP::Substantivo]} {
                $kolektilo aliguEraron $sr "uzu adjektivon" [string range [$sr set vorto] 0 end-1]a[string range [$ssr prenuGramFinilon] 1 end]
                return
            }
        }
    } elseif {[$a istype GP::TabloVorto] || [[$a prenuRadiko] istype GP::TabloVorto]} {
        # Mi vidis iu junulinon.
        # Mi vidis iu ajn junulinon.
        set se [$a selektu {prenuSekvanFraton prenuRadiko}]
        if {$se ne "" && [$se istype GP::Substantivo]} {
            set r [$a prenuRadiko]
            # Sed ne - Mi vidis iu tiun junulinon.
            if {[$se estasNeDifinitaPP [$se miAuxRadikaElemento]]} {
                $kolektilo aliguEraron $r "uzu ĝustan kazon aŭ nombron" [esp::prenuKazoNombro [$r prenuBazanFormon] [$se estasAkuzativo] [$se estasPluralo]]
            }
        }
    }

    if {[EsperantoConf set gramRaportuCxion]} {
       $kolektilo aliguEraron [$a prenuRadiko] "frazoparto sen funkcio en verbofrazo" {} 5
    }
}
SintaksAsto::main instproc testuKomenco kolektilo {
    my instvar parenco
    if {[my funkcio] eq "subfrazo"} {
        set f [my prenuUnuan]
        if {![EsperantoConf set gramTestuKomojn]} return
        if {!([$f istype GP::Simbolo] || [$f istype GP::Konjunkcio] && [$f estasVortoj {kaj aŭ}])} {
            set ae [$f prenuAntauxElemento]
            if {$ae ne "" && ![$ae istype GP::Simbolo]} {
                $kolektilo aliguEraron $ae "atendas komon en komenco de subfrazo" [list ", "]
            }
        }
        set f [my prenuLastan]
        if {![$f istype GP::Simbolo]} {
            set pe [$f prenuSekvaElemento]
            if {$pe ne "" && ![$pe istype GP::Simbolo] && !([$pe istype GP::Konjunkcio] && [$pe estasVortoj {kaj aŭ}])} {
                $kolektilo aliguEraron $f "atendas komon en fino de subfrazo" [list ", "]
            }
        }
        return
    }
    if {[my funkcio] ne "main" && [my funkcio] ne "baza"} return
    if {$parenco ne ""} return
    set f [my prenuUnuan]
    if {![$f istype GP::Simbolo] && ![string is upper [string index [$f set vorto] 0]] && ![string is digit [string index [$f set vorto] 0]]} {
        $kolektilo aliguEraron $f "komenco de frazo devas esti grandskribita" [esp::grandskribi [$f prenuVorton]]
    }
    # signo ? en fino
    if {[my estasDemando]} {
        set komenco [my selektu {0 prenuRadiko}]
        if {![my estasDemandaKomenco]} {
            set f [my prenuUnuan]
            $kolektilo aliguEraron $f "demando devas komenci per 'ĉu' aŭ k-tablovorto" [list "Ĉu [$komenco prenuVorton]"]
            return
        }
        if {[my estasOrdonoSenSubjekto]} {
            set rad [my prenuRadiko]
            $kolektilo aliguEraron $rad "En sensubjekta demando devas esti infinitivo" [$rad prenuBazanFormon]
        }
    } else {
        # demando sen signo ?
        if {[EsperantoConf set gramTestuSignojn] && [my estasDemandaKomenco]} {
            set lasta [my prenuLastan]
            if {[$lasta estasVorto .]} {
                $kolektilo aliguEraron [my prenuLastan] "demando sen signo?" ?
            }
        }
    }
    if {[EsperantoConf set gramTestuSignojn] && [my estasOrdonoSenSubjekto]} {
        set lasta [my prenuLastan]
        if {[$lasta estasVorto .]} {
            $kolektilo aliguEraron [my prenuLastan] "ordono sen signo!" !
        }
    }
}
SintaksAsto::main instproc testuSubfrazon kolektilo {
    my instvar astoj
    # por ke + vokativo
    if {[llength $astoj]>3 && [[lindex $astoj 1] prenuVortoj] eq "por ke"} {
        set v [my prenuRadiko]
        if {$v ne "" && [$v hasclass GP::Verbo]} {
            if {![$v estasOrdono]} {
                $kolektilo aliguEraron $v "atendas vokativon ĉe 'por ke'" [string range [$v prenuBazanFormon] 0 end-1]u
            }
        }
    }
}
SintaksAsto::main instproc testuSubjekton {havasSubjekton havasObjekton radiko radobj kolektilo} {
    if {[$radobj necesasSubjekton] && ![$radobj estasOrdono]} {
        if {!$havasSubjekton} {
            # okazas nenion
            if {$havasObjekton} {
                set obj [my trovuKunFunkcio obj]
                if {$obj ne ""} {
                    if {[$obj istype GP::Elemento]} {
                        $kolektilo aliguEraron $obj "uzu nominativon por subjekto" [string trimright [$obj set vorto] n]
                    } elseif {[$obj istype SintaksAsto::np]} {
                        set nrad [$obj prenuRadiko]
                        foreach {k f prop} [$obj prenuFrazpartoKazoNombro 0 [$nrad estasPluralo]] {}
                        if {$k ne ""} {
                            $kolektilo aliguEraron [list $k $f] "uzu nominativon por subjekto" [list $prop]
                        }
                    }
                }
            } else {
                $kolektilo aliguEraron $radiko "subjekto por verbo ne trovita"
            }
        }
    }
    if {$havasSubjekton && [[$radiko prenuRadiko] estasInfinitivo]} {
        set radiko [$radiko prenuRadiko]
        if {[my estasDemando]} {
            $kolektilo aliguEraron $radiko "verbo ne en infinitivo" [string range [$radiko prenuBazanFormon] 0 end-1]u
        } else {
            $kolektilo aliguEraron $radiko "verbo ne en infinitivo" [string range [$radiko prenuBazanFormon] 0 end-1]as
        }

    }
}
SintaksAsto::main instproc vortoNombro elems {
    set nombro 0
    foreach e $elems {
        if {![$e istype GP::Simbolo]} {
            if {[$e istype GP::Elemento]} {
                incr nombro 1
            } else {
                incr nombro [my vortoNombro [$e prenuFoliojn]]
            }
        }
    }
    return $nombro
}
@ Class SintaksAsto::mainc {
description {Cxeno de frazo.
Frazo povas enhavi samnivalaj frazoj aux cxef- kaj subfrazoj.
La astoj de mainc povas esti nur main frazoj}
}
Class SintaksAsto::mainc -superclass ::SintaksAsto
@ ::SintaksAsto::mainc idemeta component EspSintaksaAnalizo
SintaksAsto::mainc instproc analizu {} {
    next
    my instvar astoj
    set subjfrazo ""
    # Mi vidis la domon kaj iris al domo.
    foreach a $astoj {
        if {[$a istype SintaksAsto::main]} {
            set asub [$a prenuSubjekton]
            if {$asub ne ""} {
                set subjfrazo $a
            } else {
                if {[$a exists radiko]} {
                    if {![$a istype SintaksAsto::mainc]} {
                        # Mi pensas, ke estas bone.
                        if {[$a selektu {prenuRadiko estasEst}] ne "1"} {
                            $a class SintaksAsto::smain
                        }
                    }
                    if {$subjfrazo ne "" && [$a istype SintaksAsto::smain]} {
                        $a subjfrazo $subjfrazo
                    }
                }
            }
        }
        if {[$a istype SintaksAsto::npmain]} {
            $a sxercxiKompleksajSubjektivanSuplementon
        }
    }
}
SintaksAsto::mainc instproc definuFunkcioj {} {
    # nenio
}
SintaksAsto::mainc instproc havasKeSubfrazon {} {
    foreach a [my astoj] {
        if {[$a istype SintaksAsto::main]} {
            # ", ke" aux "ke"
            foreach f [$a prenuFoliojn] {
                if {[$f istype GP::Simbolo]} continue
                if {[$f estasVorto ke]} {
                    return 1
                }
                break
            }
        } elseif {[$a istype SintaksAsto::mainc]} {
            # Ĝi montros, ke vi havas seriozajn intencojn kaj markos vian oficialan eniron en mian familian rondon.
            # Eraro 716
            if {[$a havasKeSubfrazon]} {
                return 1
            }
        }
    }
    return 0
}
SintaksAsto::mainc instproc sxercxiIgnorPartoj {} {
    foreach a [my astoj] {
        if {[$a istype SintaksAsto::main]} {
            $a sxercxiIgnorPartoj
        }
    }
}
SintaksAsto::mainc instproc sxercxiKompleksajSubjektivanSuplementon {} {
    foreach a [my astoj] {
        if {[$a istype SintaksAsto::amain]} {
            $a sxercxiKompleksajSubjektivanSuplementon
        }
    }
}
@ Class SintaksAsto::ne {
description {Primitiva Adverbo "ne" kunligas cxiam kun sekvanta elemento.
Ekzemplo:
''Ne mi'' laboras.}
}
Class SintaksAsto::ne -superclass ::SintaksAsto
@ ::SintaksAsto::ne idemeta component EspSintaksaAnalizo
SintaksAsto::ne instproc init {} {
    my instvar astoj
    my radiko [lindex $astoj 1]
    [my radiko] set funkcio radiko
}
SintaksAsto::ne instproc prenuNomo {} {
    [my prenuRadiko] prenuNomo
}
SintaksAsto::ne instproc radikoEstasVortoj vortoj {
    [my prenuRadiko] estasVortoj $vortoj
}
@ Class SintaksAsto::nfvp {
description {"Not finite" verbal fazo.
Mi volas ''iri hejmen'' kaj ''kanti kantojn''}
}
Class SintaksAsto::nfvp -superclass ::SintaksAsto
@ ::SintaksAsto::nfvp idemeta component EspSintaksaAnalizo
SintaksAsto::nfvp instproc estasDauraTempo {} {
    my instvar parenco astoj
    set t [my trovuKunFunkcio tempo]
    if {$t ne "" && [$t istype SintaksAsto::np]} {
        return 1
    }
    if {[$parenco istype SintaksAsto::main]} {
        set v [$parenco prenuRadiko]
        if {$v ne "" && [$v istype GP::Verbo] && [$v estasBazajVortoj {ekkomenci rekomenci komenci ŝajni daŭri ĉesi fini rezigni}]} {
            return 1
        }
    }
    foreach a $astoj {
        set r [$a prenuRadiko]
        if {[$r estasVortoj {dum longe ĉiam foje daŭre ripete kutime}]} {
            return 1
        }
    }
    return 0
}
SintaksAsto::nfvp instproc estasKompleksaTempo {} {
    return 0
}
SintaksAsto::nfvp instproc estasKuneblaj {elem ligilo stupo} {
    expr {[my prenuNomo] eq [$elem prenuNomo]}
}
SintaksAsto::nfvp instproc estasPasivaFrazo {} {
    my havasMerkmalon pasivo
}
SintaksAsto::nfvp instproc estasPunktaTempo {} {
    return 0
}
SintaksAsto::nfvp instproc init {} {
    next
    my instvar astoj
    set l [list]
    # forigu subaj nfvp struktujoj
    # [nfvp rapide [nfvp legi libron]] al
    # [nfvp rapide legu libron]
    #foreach a $astoj {
        #if {[$a istype SintaksAsto::nfvp]} {
            #foreach a2 [$a astoj] {
                #lappend l $a2
            #}
            #$a destroy
        #} else {
            #lappend l $a
        #}
    #}
    #set astoj $l

    set trovita 0
    foreach e $astoj {
        # radiko estas la infinitivo
        if {[$e istype ::GP::Verbo] && [$e estasInfinitivo]} {
            my radiko $e
            set trovita 1
            break
        }
    }
    if {!$trovita} {
        foreach e $astoj {
            # radiko estas la infinitivo
            set rad [$e prenuRadiko]
            if {[$rad istype ::GP::Verbo] && [$rad estasInfinitivo]} {
                my radiko $e
                set trovita 1
                break
            }
        }
    }
    if {!$trovita && [llength $astoj]>0} {
        my radiko [lindex $astoj 0]
    }
    if {[my exists radiko]} {
        [my radiko] funkcio radiko
    }
}
@ SintaksAsto::nfvp instproc prenuCentranVerbon {} {
description {La metodo trovas la verbon, kiu regas la i-frazparton.
Ekzemple: "mi volas {nfvp vidi vin}". Tiu verbo estas "volas"
}
}
SintaksAsto::nfvp instproc prenuCentranVerbon {} {
    my instvar parenco
    set v [$parenco prenuRadiko]
    if {$v ne "" && [$v istype GP::Verbo]} {
        return $v
    }
    return
}
SintaksAsto::nfvp instproc sxercxiErarojn kolektilo {
    next
    if {![my exists radiko] || [my radiko] eq ""} {
        $kolektilo aliguEraron [self] "verbo ne trovita"
        return
    }
    my instvar radiko astoj
    set radobj [$radiko prenuRadiko]
    set havasSubjekton 0
    foreach a [my astoj] {
        if {$a eq $radiko} continue
        if {[$a istype GP::Simbolo]} {
            if {[$a vorto] eq "," && ![$a havasFunkcion]} {
                $kolektilo aliguEraron $a "nenio funkcio por tiu komo trovita"
            }
            continue
        }
        if {![$a havasFunkcion]} {
            $kolektilo aliguEraron $a "nenio gramatika funkcio por elemento [$a prenuNomo] trovita"
            continue
        }
        switch [$a funkcio] {
            subj {
                set havasSubjekton 1
            }
            obj {
                if {![$radobj eblasObjekto]} {
                    if {[$radobj estasEst]} {
                        set rad [$a prenuRadiko]
                        if {[$a istype SintaksAsto::np]} {
                            foreach {k f prop} [$a prenuFrazpartoKazoNombro 0 [$rad estasPluralo]] {}
                            if {$k ne ""} {
                                $kolektilo aliguEraron [list $k $f] "post '[$radobj prenuBazanFormon]' uzu nomintativon kiel komplemento" [list $prop]
                            }
                        } else {
                            $kolektilo aliguEraron $rad "post '[$radobj prenuBazanFormon]' uzu nomintativon kiel komplemento" [list [esp::prenuKazoNombro [$rad prenuBazanFormon] 0 [$rad estasPluralo]]]
                        }
                    } else {
                        $radobj eraroNeTransitivaKunObjekto $kolektilo $a
                    }

                }
            }
            iobj {
                # ignoru cxar iobj ekzistas nur cxar verbo tion ebligis
            }
            np {
                $kolektilo aliguEraron $a "substantiva frazparto sen funkcio"
            }
            adjp {
                $kolektilo aliguEraron $a "adjektiva frazparto sen funkcio"
            }
            advp -
            adv -
            attr -
            pp -
            fkonj -
            tempo -
            ignor -
            padv -
            padj -
            oattr -
            ocomp -
            nfvp -
            nfvpobj -
            ppinf -
            ono -
            psubj {}
            comp {
                if {![$radobj eblasComp]} {
                    $kolektilo aliguEraron $a "verbo ne ebligas comp-objekton"
                }
            }
            default {
                $kolektilo aliguEraron $a "frazo '[$a funkcio]' sen funkcio en verbofrazo"
            }
        }
    }
}
SintaksAsto::nfvp instproc sxercxiFrazokapon {} {
    # sercxi lokaj objektoj
    next
    my instvar astoj radiko
    if {![info exists radiko]} {
        return
    }

    set havisObjekton 0
    # Tion mi volas scii.
    if {[my havasMerkmalon obj]} {
        set havisObjekton 1
    }
    set havisIndirektanObjekton 0
    set havisPSubjekton 0
    set radobj [$radiko prenuRadiko]
    set estasEst [$radobj estasEst]
    set havisComp [expr {![$radobj eblasComp]}]
    set havisOComp [expr {![$radobj eblasObjComp]}]
    set havisOAttr [expr {![$radobj eblasObjAdjComp]}]
    set havisAttr [expr {![$radobj eblasAdjComp]}]
    set havisModVerbo [expr {![$radobj estasModVerbo]}]

    set estasKomenco 1
    set initListo [list]
    foreach e $astoj {
        set eobj [$e prenuRadiko]
        if {[$e istype SintaksAsto::np]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$eobj hasclass GP::Substantivo]} {
            if {[$eobj prenuKazon] eq "akuzativo"} {
                if {[$eobj istype GP::Substantivo] && [$eobj estasTempo]} {
                    $e funkcio tempo
                } elseif {[$eobj istype GP::Substantivo] && [$eobj estasLongeco]} {
                    $e funkcio long
                } elseif {[$radobj estasMuvigo] && [$eobj istype GP::Substantivo] && [$eobj estasLoko]} {
                    $e funkcio direkto
                } else {
                    if {!$havisObjekton} {
                        set havisObjekton 1
                        $e funkcio obj
                    }
                }
            } elseif {[$eobj istype GP::Konstanto]} {
                if {!$havisObjekton} {
                    set havisObjekton 1
                    $eobj kazo akuzativo
                    $e funkcio obj
                }
            } elseif {[$eobj havasMerkmalon numel]} {
                # tri el libroj
                set havisObjekton 1
                $e funkcio obj
                $eobj kazo akuzativo
            } else {
                if {!$havisComp} {
                    $e funkcio comp
                    set compObjekto $e
                    set havisComp 1
                } elseif {!$havisOComp && $havisObjekton} {
                    # mi volis nomi lin programisto.
                    $e funkcio ocomp
                    set havisOComp 1
                }
            }
            continue
        }
        if {[$e istype SintaksAsto::subsup]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$e prenuNomo] eq "Adverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$e prenuNomo] eq "PrimAdverbo" && ![$e havasFunkcion]} {
            $e funkcio adv
            continue
        }
        if {[$eobj istype GP::Adjektivo]} {
            if {!$havisAttr || [$eobj havasDerivoPriskribon pverbo]} {
                $e funkcio attr
                set attrObjekto $e
                set havisAttr 1
            } elseif {!$havisOAttr} {
                $e funkcio oattr
                set havisOAttr 1
            }
            continue
        }
        if {[$e istype SintaksAsto::subsup]} {
            if {[$e estasDato]} {
                $e funkcio tempo
                continue
            }
        }
        if {[$e hasclass SintaksAsto::advsup] && [$e eblasKielSubstantivo]} {
            $e set funkcio obj
            set havisObjekton 1
            continue
        }
        # Kiel vi tion faris?
        if {[$eobj istype GP::TabloVorto] && [$eobj estasArto el]} {
            $e funkcio adv
            $eobj mixin add GP::Adverbo
        }
        if {[$eobj hasclass GP::Adverbo]} {
            $e funkcio adv
            continue
        }
        if {[$eobj hasclass GP::PrimitivaAdverbo]} {
            if {[$eobj estasTempo]} {
                $e funkcio tempo
            } elseif {[$eobj estasSolaAdverbo]} {
                $e funkcio adv
            }
            continue
        }
        if {[$e havasFunkcion] && [$e funkcio] eq "pp"} {
            if {[$eobj prenuVorton] eq "al" && [$radobj eblasIndirektaObjekto]} {
                if {!$havisIndirektanObjekton} {
                    $e funkcio iobj
                    set havisIndirektanObjekton 1
                    continue
                }
            }
        }
        if {[$e istype GP::Onomatopeo]} {
            $e funkcio ono
        }
    }
   # komputu pasivan merkmalon
   if {[$radobj estasBasaVorto esti] && $havisAttr} {
       set attrobj [my trovuKunFunkcio attr]
       if {$attrobj ne ""} {
            set rad [$attrobj prenuRadiko]
            if {[$rad estasNeTranzitivaPartizipo]} {
                my aliguMerkmalon pasivo
            }
       }
   }

}
SintaksAsto::nfvp instproc tranformuNFVPAlSubfrazo {} {
    my instvar parenco astoj
    set verbo [my prenuCentranVerbon]
    if {$verbo eq ""} {return}
    set verbovorto [$verbo prenuBazanFormon]

    # trovu objekton de centra frazo
    if {[lsearch {rifuzi pensi ĝoji domeĝi eviti promesi rezigni} $verbovorto]>=0} {
        set obj [$parenco trovuKunFunkcio subj]
    } else {
        set obj [$parenco trovuKunFunkcio obj]
    }
    if {$obj eq ""} {return}
    set obj [$obj prenuRadiko]

    if {[lsearch {peti alvoki konvinki devigi inviti} $verbovorto]>=0} {
        set arto volo
        # ke + u
    } elseif {[lsearch {vidi aŭskulti observi} $verbovorto]>=0} {
        set arto raporto
        # kiam + s
    } elseif {[lsearch {promesi rifuzi rezigni ebligi pensi preti interesiĝi} $verbovorto]>=0} {
        set arto intenco
        # ke + os
    } elseif {[lsearch {ĝoji igi domeĝi eviti} $verbovorto]>=0} {
        set arto grundo
        # ke + s
    } else {
        return
    }

    set frazoobj [my info parent]
    set main [SintaksAsto::main new -childof $frazoobj -funkcio subfrazo]
    $main set originaElemento [self]
    set nastoj [list]
    set simbolo [GP::Simbolo new -childof $frazoobj -funkcio fkonj -vorto ,]
    $simbolo set originaElemento [my prenuUnuan]
    $simbolo set komenco 0
    $simbolo set fino 0
    lappend nastoj $simbolo
    if {$arto eq "raporto"} {
        set elem [GP::TabloVorto new -childof $frazoobj -funkcio adv -vorto kiam -bazo ki -arto am -mixin GP::Adverbo]
        $elem aliguMerkmalon raporto
    } else {
        set elem [GP::Interjekcio new -childof $frazoobj -funkcio fkonj -vorto ke -radiko Radiko::ke]
    }
    $elem set originaElemento [my prenuUnuan]
    $elem set komenco 1
    $elem set fino 1
    lappend nastoj $elem

    foreach a $astoj {
        # konstru normalan verbon de "i-verbo"
        if {[$a funkcio] eq "radiko" && [$a istype GP::Verbo]} {
            if {$arto eq "raporto" || $arto eq "grundo"} {
                set tempo [$verbo set tempo]
            } elseif {$arto eq "intenco"} {
                set tempo os
            } else {
                set tempo u
            }
            # kontrui subjekton de objekto "li", "sxi", "ili" aux "gxi"
            if {[$obj istype GP::PersonPronomo]} {
                set pronvorto [$obj prenuBazanFormon]
            } else {
                if {[$obj nombro] eq "pluralo"} {
                    set pronvorto ili
                } elseif {[$obj istype GP::Substantivo] && [$obj estasPersono]} {
                    if {[$obj estasInaPersono]} {
                        set pronvorto ŝi
                    } else {
                        set pronvorto li
                    }
                } else {
                    set pronvorto ĝi
                }
            }
            set pron [GP::PersonPronomo new -childof $frazoobj -funkcio subj -vorto $pronvorto -radiko Radiko::$pronvorto -kazo nominativo -nombro [$obj nombro]]
            lappend nastoj $pron
            $pron set originaElemento $a
            $pron aliguMerkmalon $arto
            $pron set komenco 2
            $pron set fino 2

            set vorto [string range [$a prenuBazanFormon] 0 end-1]$tempo
            set va [GP::Verbo new -childof $frazoobj -funkcio radiko -vorto $vorto -radiko [$a radiko] -derivolisto [$a derivolisto] -tempo $tempo]
            $main radiko $va
            $va set originaElemento $a
            $va set komenco 3
            $va set fino 3
            lappend nastoj $va
        } else {
            lappend nastoj $a
        }
    }
    $main astoj $nastoj
    $main initKunteksto $parenco
    $main initParencon $parenco
    $parenco tausxuAstoj [self] $main
    return $main
}
@ Class SintaksAsto::nomo {
description {Strukturo por nomoj, ekz:
  * ''Artur Trzewik''
  * ''Sinjoro Trzewik''}
}
Class SintaksAsto::nomo -superclass ::SintaksAsto
@ ::SintaksAsto::nomo idemeta component EspSintaksaAnalizo
SintaksAsto::nomo instproc igiKonstanto {} {
    my instvar astoj radiko
    foreach a $astoj {
        if {[$a istype GP::Elemento] && ![$a istype GP::Substantivo] && ([$a estasNomo] || [$a estasEblaNomo])} {
            $a class GP::Konstanto
            set radiko $a
        }
    }
}
SintaksAsto::nomo instproc init {} {
    if {![my exists radiko]} {
        my radiko [lindex [my astoj] 0]
    }
}
SintaksAsto::nomo instproc initKunteksto parenco {
    next
    # [my radiko] initKunteksto $parenco
    [my radiko] set funkcio radiko

}
SintaksAsto::nomo instproc prenuCxefRadiko {} {
    my prenuRadiko
}
SintaksAsto::nomo instproc prenuRelFrazoRadiko {} {
    if {[my exists radiko]} {
        my radiko
    } else {
        [lindex [my astoj] 0] prenuRelFrazoRadiko
    }
}
@ Class SintaksAsto::np {
description {Nominal subfrazo
radiko estas substantivo

ekzemplo:
'''mia bela domo'''}
}
Class SintaksAsto::np -superclass ::SintaksAsto
@ ::SintaksAsto::np idemeta component EspSintaksaAnalizo
SintaksAsto::np instproc aliguKazoEraro {kolektilo estasAkuzativo teksto} {
    set rad [my prenuRadiko]
    foreach {k f prop} [my prenuFrazpartoKazoNombro $estasAkuzativo [$rad estasPluralo]] {}
    if {$k ne ""} {
        $kolektilo aliguEraron [list $k $f] $teksto [list $prop] 1
        return
    }
}
SintaksAsto::np instproc estasAkuzativo {} {
    set radobj [my prenuRadiko]
    $radobj estasAkuzativo
}
SintaksAsto::np instproc estasDato {} {
    my instvar astoj radiko
    if {[$radiko istype SintaksAsto::subsup]} {
        return [$radiko estasDato]
    }
    return 0
}
SintaksAsto::np instproc estasDifinita {} {
    my instvar astoj
    set u [lindex $astoj 0]
    # preskaux mia libro
    # la plej bona libro
    if {[$u istype SintaksAsto::adjp]} {
        set unuaElemento [$u prenuUnuan]
    } else {
        set unuaElemento [$u prenuRadiko]
    }
    if {![$unuaElemento istype GP::Difinilo] && ![$unuaElemento istype GP::PosesivPronomo] && ![$unuaElemento istype GP::TabloVorto]} {
        return 0
    }
    return 1
}
SintaksAsto::np instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::np instproc estasNeDifinita {} {
    my instvar astoj
    set k [lindex $astoj 0]
    if {[$k istype SintaksAsto::grupo] || [$k istype SintaksAsto::konj] || [$k istype SintaksAsto::num]} {
        set k [$k prenuRadiko]
    }
    expr {[$k istype GP::Adjektivo] || [$k istype SintaksAsto::adjp] || [$k istype SintaksAsto::adjsup] || [$k istype GP::Substantivo] || [$k istype GP::Konstanto] || [$k istype GP::Numeralo] || ([$k istype GP::Difinilo] && [$k estasVorto ambaŭ])}
}
SintaksAsto::np instproc estasNeDifinitaDekstra {} {
    my instvar astoj
    set k [lindex $astoj end]
    expr {[$k istype GP::Substantivo]}
}
SintaksAsto::np instproc estasNeDifinitaNum {} {
    my instvar astoj
    set k [lindex $astoj 0]
    # du miaj libroj
    if {[$k istype SintaksAsto::grupo]} {
        set k [$k prenuRadiko]
    }

    expr {[$k istype GP::Adjektivo] || [$k istype SintaksAsto::adjp] || [$k istype SintaksAsto::adjsup] || [$k istype GP::Substantivo] || [$k istype GP::Konstanto] || [$k istype GP::Numeralo] || [$k istype GP::PosesivPronomo] || [$k istype GP::TabloVorto]}
}
SintaksAsto::np instproc estasNeDifinitaPP {} {
    my instvar astoj
    set k [lindex $astoj 0]
    if {[$k istype GP::Adjektivo] || [$k istype GP::Substantivo] || [$k istype GP::Konstanto] || [$k istype GP::PosesivPronomo] || [$k istype SintaksAsto::konj] || [$k istype GP::Numeralo]} {
        return 1
    }
    set kr [$k prenuRadiko]
    if {$kr ne $k && ([$kr istype GP::Adjektivo] || [$kr istype GP::Substantivo] || [$kr istype GP::PosesivPronomo])} {
        return 1
    }
    return 0
}
SintaksAsto::np instproc estasNombraAkuzativa {} {
    my instvar astoj radiko
    expr {[[[lindex $astoj 0] prenuRadiko] istype GP::Numeralo] &&
        [my estasAkuzativo]}
}
SintaksAsto::np instproc estasOrdaNumero {} {
    set radobj [my prenuRadiko]
    expr {[$radobj istype GP::Numeralo] && [$radobj estasSubstantiva]}
}
SintaksAsto::np instproc faruKontantoj {} {
    foreach f [my prenuFoliojn] {
        $f class GP::Konstanto
    }
}
SintaksAsto::np instproc havasAdjektivon {} {
    my instvar astoj
    [[lindex $astoj 0] prenuRadiko] istype GP::Adjektivo
}
SintaksAsto::np instproc igiPluralo {} {
    my instvar astoj
    [lindex $astoj 0] set nombro pluralo
}
SintaksAsto::np instproc init {} {
    next
    my instvar astoj radiko

    set l [list]
    # forigu subaj np struktujoj
    # [np tiu [np bona homo]] al
    # [np tiu bona homo]
    foreach a $astoj {
        if {[$a istype SintaksAsto::np]} {
            foreach a2 [$a astoj] {
                lappend l $a2
            }
            $a destroy
        } else {
            lappend l $a
        }
    }
    set astoj $l

    foreach a $astoj {
        if {[$a hasclass GP::Substantivo] || [$a istype GP::PersonPronomo]} {
            set radiko $a
            return
        }
        set aobj [$a prenuRadiko]
        if {[$aobj hasclass GP::Substantivo]} {
            set radiko $a
            return
        }
    }
    set radiko [lindex $astoj end]
    if {[$radiko istype GP::Adjektivo]} {
        # changxu ajektivo al substantivo
        # ekzemple - la alia, la unua
        # $radiko class GP::Substantivo
        # sxangx de klaso al substantivo farigos problemojn cxe
        # tradukado cxar "alia" efektive restos adjektivo ne substantivo
        $radiko aliguMerkmalon substantivaRolo
    } elseif {[$radiko istype GP::Numeralo]} {
        $radiko estuSubstantiva
    }
    set radiko [$radiko prenuRadiko]
    if {[$radiko istype GP::Adjektivo]} {
        # changxu ajektivo al substantivo
        # ekzemple - la alia, la unua
        # $radiko class GP::Substantivo
        # sxangx de klaso al substantivo farigos problemojn cxe
        # tradukado cxar "alia" efektive restos adjektivo ne substantivo
        $radiko aliguMerkmalon substantivaRolo
    } elseif {[$radiko istype GP::Numeralo]} {
        $radiko estuSubstantiva
    }
}
SintaksAsto::np instproc initKunteksto parenco {
    next
    [my radiko] set funkcio radiko
}
SintaksAsto::np instproc kolektuSubstantivoj {} {
    my instvar radiko
    $radiko kolektuSubstantivoj
}
SintaksAsto::np instproc prenuAdjektivon {} {
    my instvar astoj
    set r [my prenuRadiko]
    foreach a $astoj {
        set ar [$a prenuRadiko]
        if {$r eq $ar} continue
        if {[$ar istype GP::Adjektivo]} {
            return $ar
        }
    }
    return
}
SintaksAsto::np instproc prenuFrazpartoKazoNombro {estasAkuzativo estasPluralo} {
    my instvar astoj
    set ret {}
    set komenco {}
    set fino {}
    foreach f [my astoj] {
        if {[$f hasclass GP::NombroKazo]} {
            if {$komenco eq ""} {
                set komenco $f
            }
            if {[$f hasclass GP::Partizipo]} {
                set bf [$f prenuParticipanBazanFormon]
            } else {
                set bf [$f prenuBazanFormon]
            }
            lappend ret [esp::prenuKazoNombro $bf $estasAkuzativo $estasPluralo]
            set fino $f
            continue
        } else {
            if {[$f istype SintaksAsto::subsup] || [$f istype SintaksAsto::disk]} {
                set f [$f prenuRadiko]
                if {$komenco eq ""} {
                    set komenco $f
                }
                if {[$f hasclass GP::Partizipo]} {
                    set bf [$f prenuParticipanBazanFormon]
                } else {
                    set bf [$f prenuBazanFormon]
                }
                lappend ret [esp::prenuKazoNombro $bf $estasAkuzativo $estasPluralo]
                set fino $f
            }
        }
        if {$komenco ne ""} {
            break
        }
    }
    list $komenco $fino [join $ret]
}
SintaksAsto::np instproc prenuSubsupRadiko {} {
    my instvar parenco
    if {$parenco ne "" && [$parenco istype SintaksAsto::pp]} {
        $parenco prenuSubsupRadiko
    } else {
        next
    }
}
SintaksAsto::np instproc sxercxiErarojn kolektilo {
    next
    my instvar radiko
    # japanajn lingvon kaj kulturon
    if {[$radiko istype SintaksAsto::konj]} {
        set radobj $radiko
        set estasKonj 1
    } else {
        set radobj [$radiko prenuRadiko]
        set estasKonj 0
    }
    set kazo [$radobj prenuKazon]
    set nombro [$radobj prenuNombron]
    foreach e [my chiuElementoj] {
        if {[$e hasclass GP::NombroKazo] || [$e istype SintaksAsto::adjp]} {
            set ekazo [$e prenuKazon]
            set enombro [$e prenuNombron]
            if {$kazo ne "" && $kazo ne $ekazo} {
                set re [$e prenuRadiko]
                $kolektilo aliguEraron $e "kazo ne similas" [esp::prenuKazoNombro [$re prenuBazanFormon] [expr {$kazo eq "akuzativo"}] [expr {$nombro eq "pluralo"}]]
                return
            }
            if {$nombro ne "" && $nombro ne $enombro} {
                # japanan lingvon kaj kulturon
                if {$estasKonj && $enombro eq "singularo"} continue
                set re [$e prenuRadiko]
                $kolektilo aliguEraron $re "nombro ne similas" [esp::prenuKazoNombro [$re prenuBazanFormon] [expr {$kazo eq "akuzativo"}] [expr {$nombro eq "pluralo"}]]
                return
            }
        }
    }
}
SintaksAsto::np instproc testuSintakso elem {
    if {[lindex $elem 0] eq "Substantivo" && [lindex $elem 1] eq "estasNePronomo"} {
        # !!! ne pura programado
        my estasNeDifinita
    } elseif {[lindex $elem 0] eq "Substantivo" && [lindex $elem 1] eq "estasNePronomoNum"} {
        my estasNeDifinitaNum
    } else {
        next
    }
}
@ Class SintaksAsto::npmain {
description {Subfrazoj (enjxetoj) kiu ne havas verboj aux subjektoj.
Plejparte simpla np aux pp frazo, Ili povas esti ignoritaj en la analizo.

*Certe*, mi tion havas.
Mi estis, *malgraux la ago*, tre vigla.
}
}
Class SintaksAsto::npmain -superclass ::SintaksAsto::amain
@ ::SintaksAsto::npmain idemeta component EspSintaksaAnalizo
SintaksAsto::npmain instproc analizu {} {
    next
    my instvar astoj radiko
    if {[llength $astoj]==1 || ![[lindex $astoj 0] istype GP::Simbolo]} {
        set radiko [lindex $astoj 0]
    } else {
        set radiko [lindex $astoj 1]
    }
    my initParencon {}
    my sxercxiKompleksajSubjektivanSuplementon
}
SintaksAsto::npmain instproc init {} {
    my radiko [lindex [my astoj] 0]
    [my radiko] funkcio radiko
}
SintaksAsto::npmain instproc prenuInfVerbo {} {
    return
}
SintaksAsto::npmain instproc prenuRadiko {} {
    if {[my exists radiko]} {
        next
    } else {
        return
    }
}
@ Class SintaksAsto::num {
description {grupo de numeraloj}
}
Class SintaksAsto::num -superclass ::SintaksAsto
@ ::SintaksAsto::num idemeta component EspSintaksaAnalizo
SintaksAsto::num instproc init {} {
    my instvar astoj
    my radiko [lindex $astoj 1]
}
SintaksAsto::num instproc sxercxiErarojn kolektilo {
    my instvar parenco astoj
    if {$parenco ne "" && ![$parenco istype SintaksAsto::num]} {
        set elementoj astoj
        foreach e [lrange $elementoj 0 end-1] {
            if {[$e istype GP::Numeralo] && ![$e estasNurNumero]} {
                #my halt
                $kolektilo aliguEraron $e "atendas puran numeron cxi tie"
                return
            }
        }
    }
    next
}
@ Class SintaksAsto::padj {
description {komperativo de adjektivo
ekz: pli bela}
}
Class SintaksAsto::padj -superclass ::SintaksAsto
@ ::SintaksAsto::padj idemeta component EspSintaksaAnalizo
SintaksAsto::padj instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::padj instproc estasPlej {} {
    my instvar astoj
    expr {[[[lindex $astoj 0] prenuRadiko] prenuVorton] eq "plej"}
}
SintaksAsto::padj instproc estasPli {} {
    my instvar astoj
    expr {[[[lindex $astoj 0] prenuRadiko] prenuVorton] eq "pli"}
}
SintaksAsto::padj instproc estasPliKajPli {} {
    my instvar astoj
    if {[[set k [lindex $astoj 0]] istype SintaksAsto::konj]} {
        if {[$k prenuVortoj] eq "pli kaj pli"} {
            return 1
        }
    }
    return 0
}
SintaksAsto::padj instproc init {} {
    my instvar astoj radiko
    set radiko [lindex $astoj 1]
    $radiko set funkcio radiko
}
@ Class SintaksAsto::padv {
description {komperativo de adverbo
ekz: pli rapide}
}
Class SintaksAsto::padv -superclass ::SintaksAsto
@ ::SintaksAsto::padv idemeta component EspSintaksaAnalizo
SintaksAsto::padv instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::padv instproc estasPli {} {
    my instvar astoj
    expr {[[[lindex $astoj 0] prenuRadiko] prenuVorton] eq "pli"}
}
SintaksAsto::padv instproc estasPliKajPli {} {
    my instvar astoj
    if {[[set k [lindex $astoj 0]] istype SintaksAsto::konj]} {
        if {[$k prenuVortoj] eq "pli kaj pli"} {
            return 1
        }
    }
    return 0
}
SintaksAsto::padv instproc init {} {
    my instvar astoj radiko
    set radiko [lindex $astoj 1]
    $radiko set funkcio radiko
}
@ Class SintaksAsto::pp {
description {Prepozicio subfrazo

radiko estas prepozicio

al mia domo}
}
Class SintaksAsto::pp -superclass ::SintaksAsto
@ ::SintaksAsto::pp idemeta component EspSintaksaAnalizo
SintaksAsto::pp instproc estasHoro {} {
    set radObj [my prenuRadiko]
    if {![$radObj estasVorto je]} {
        return 0
    }
    set np [my prenuNPParton]
    if {[$np istype SintaksAsto::np] && [$np estasOrdaNumero]} {
        return 1
    }
    set rad [$np prenuRadiko]
    if {[$rad estasVorto horo]} {
        return 1
    }
    return 0
}
SintaksAsto::pp instproc estasKuneblaj {elem ligilo stupo} {
    expr {[my prenuNomo] eq [$elem prenuNomo]}
}
SintaksAsto::pp instproc estasNeKiu {} {
    my selektuNeVero {prenuNPParton prenuRadiko {filtruVeron estasBasaVorto kiu}}
}
SintaksAsto::pp instproc estasPrepozicio vorto {
    expr {[[my prenuRadiko] prenuVorton] eq $vorto}
}
SintaksAsto::pp instproc estasPrepozicioj vortoj {
    expr {[lsearch $vortoj [[my prenuRadiko] prenuVorton]]>=0}
}
SintaksAsto::pp instproc igiKonst {} {
    my selektu {prenuNPParton prenuRadiko {class GP::Konstanto}}
}
SintaksAsto::pp instproc init {} {
    my instvar astoj
    my radiko [lindex $astoj 0]
}
SintaksAsto::pp instproc initKunteksto parenco {
    next
    my instvar radiko funkcio
    if {[$radiko istype GP::Elemento] &&
        [$radiko prenuVorton] eq "de" &&
        [$parenco istype SintaksAsto::adjp]} {
        # farita de homo
        set funkcio psubj
    } else {
        $radiko funkcio radiko
    }
}
SintaksAsto::pp instproc prenuNPParton {} {
    my instvar radiko astoj
    set  ppobj [lindex $astoj end]
    foreach a $astoj {
        if {$a ne $radiko} {
            set ppobj $a
        }
    }
    return $ppobj
}
SintaksAsto::pp instproc prenuSubsupRadiko {} {
    my instvar parenco
    if {[my prenuFunkcioNomo] eq "pos"} {
        $parenco prenuSubsupRadiko
    } else {
        next
    }
}
SintaksAsto::pp instproc sxercxiErarojn kolektilo {
    next
    my instvar radiko astoj
    set ppobj [my prenuNPParton]
    set pnprad [$ppobj prenuRadiko]
    if {![$pnprad hasclass GP::NombroKazo]} {
        set kazo ""
    } else {
        set kazo [[$ppobj prenuRadiko] kazo]
    }
    if {$kazo eq "akuzativo" && ![[$radiko prenuRadiko] estasDusignifa]} {
        $kolektilo aliguEraron $radiko "prepozicio [[$radiko prenuRadiko] vorto] ne akzeptas akuzativon"
        return
    }
    # mi metas la libron sur la tablo
    if {[[$radiko prenuRadiko] estasDusignifa] && $kazo eq "nominativo"} {
        set main [my trovuMainVerboAston]
        if {$main ne "" && [set rmain [$main prenuRadiko]] ne "" && [$rmain estasBazajVortoj {meti loki}]} {
            $ppobj aliguKazoEraro $kolektilo 1 "uzu eble akuzativon, se vi volas esprimi la movon"
        }
    }
    if {[[$radiko prenuRadiko] prenuVorton] eq "po"} {
        set ok 0
        if {[$ppobj istype SintaksAsto]} {
            foreach elem [$ppobj set astoj] {
                set radelem [$elem prenuRadiko]
                if {[$radelem istype GP::Numeralo] && [$radelem estasNurNumero]} {
                    set ok 1
                    break
                }
                if {[$radelem istype GP::Adjektivo] && [$radelem estasPseudoNumeralo]} {
                    set ok 1
                    break
                }

            }
        }
        if {[$ppobj istype GP::Elemento] && [$ppobj estasBazajVortoj {unu kelka plura multa}]} {
            set ok 1
        }
        if {[$ppobj istype GP::Numeralo]} {
            set ok 1
        }
        if {!$ok} {
            $kolektilo aliguEraron [my prenuRadiko] "prepozicio 'po' bezonas numeralon; eble uzu 'por'" por
        }
    }
}
SintaksAsto::pp instproc testuCxuTempo {} {
    my instvar radiko
    set radobj [$radiko prenuRadiko]
    if {[$radobj istype GP::Substantivo] && [$radobj estasTempo]} {
        return 1
    }
    return 0
}
SintaksAsto::pp instproc testuSintakso elem {
    if {[my prenuNomo] ne [lindex $elem 0] && ![my hasclass GP::[lindex $elem 0]]} {
        return 0
    }
    if {[llength $elem]>1} {
        return [my {*}[lrange $elem 1 end]]
    }
    return 1
}
@ Class SintaksAsto::ppinf {
description {Strukturo por: pp + info
Ekzemple: Mi laboros ''por havi monon''.}
}
Class SintaksAsto::ppinf -superclass ::SintaksAsto
@ ::SintaksAsto::ppinf idemeta component EspSintaksaAnalizo
SintaksAsto::ppinf instproc estasKuneblaj {elem ligilo stupo} {
    expr {[my prenuNomo] eq [$elem prenuNomo]}
}
@ Class SintaksAsto::smain {
description {Sensubjekta verb subfrazo. La subjekto venas de alia main elemento

ekzemplo:
Mi pensas pri tiu laboro kaj ne vidas la finon.

"kaj ne vidas la finon" - estu smain sub frazo. Subjekto estas "Mi"}
}
Class SintaksAsto::smain -superclass ::SintaksAsto::main -parameter subjfrazo
@ ::SintaksAsto::smain idemeta component EspSintaksaAnalizo
SintaksAsto::smain instproc definuFunkcioj {} {
    next
    # Malsupreniri estis facile, ni eĉ devis bremsi la ringon por kapabli sekvi ĝin.
    if {[my trovuKunFunkcio subj] ne ""} {
        my class SintaksAsto::main
    }
}
SintaksAsto::smain instproc estasOrdonoKunBonvolu {} {
    set r [my prenuRadiko]
    expr {$r ne "" && [$r estasOrdono] && [$r estasBasaVorto bonvoli]}
}
SintaksAsto::smain instproc estasOrdonoSenSubjekto {} {
    set r [my prenuRadiko]
    expr {$r ne "" && [$r estasOrdono]}
}
SintaksAsto::smain instproc prenuSubjekton {} {
    my instvar parenco
    if {[$parenco istype SintaksAsto::mainc]} {
        foreach a [$parenco astoj] {
            if {[$a istype SintaksAsto::main] && ![$a istype SintaksAsto::smain] && [self] ne $a} {
                return [$a prenuSubjekton]
            }
        }
    }
    next
}
SintaksAsto::smain instproc testuKomenco kolektilo {
}
SintaksAsto::smain instproc testuSubjekton {havasSubjekton havasObjekton radiko radobj kolektilo} {
}
@ Class SintaksAsto::subsup {
description {substantiva suplemento
ekz: libro de frato}
}
Class SintaksAsto::subsup -superclass ::SintaksAsto
@ ::SintaksAsto::subsup idemeta component EspSintaksaAnalizo
SintaksAsto::subsup instproc aliformuStrukturon {funkcio_p parenco pozicioKomenco pozicioFino postAktiono} {
    if {$postAktiono eq "initDePP"} {
        set tastoj [lrange [$parenco set astoj] $pozicioKomenco $pozicioFino]
        $parenco set astoj [lreplace [$parenco set astoj] $pozicioKomenco $pozicioFino [lindex $tastoj 0]]
        set pp [lindex $tastoj 0]
        my instvar astoj funkcio
        set funkcio $funkcio_p
        set astoj [list [lindex [$pp set astoj] 1] [lindex $tastoj 1]]
        [lindex $tastoj 1] set funkcio pos
        $pp set astoj [lreplace [$pp set astoj] 1 1 [self]]
        my init
    } else {
        next
    }
}
SintaksAsto::subsup instproc aliguKazoEraro {kolektilo estasAkuzativo teksto} {
    my instvar radiko
    $radiko aliguKazoEraro $kolektilo $estasAkuzativo $teksto
}
SintaksAsto::subsup instproc estasDato {} {
    my instvar astoj estasDato
    set radObj [my prenuRadiko]
    # la trian de decembro
    if {![$radObj istype GP::Numeralo] || ![$radObj estasSubstantiva]} {
        return 0
    }
    if {[$radObj estasOnoj]} {
        return 0
    }
    set pp [lindex $astoj end]
    set radObj [$pp prenuRadiko]
    if {![$radObj estasVorto de]} {
        return 0
    }
    if {![$pp istype SintaksAsto::pp]} {
        return 0
    }
    set np [$pp prenuNPParton]
    set radObj [$np prenuRadiko]
    if {[$radObj istype GP::Substantivo] && [$radObj estasMonato]} {
        return 1
    }
    return 0
}
SintaksAsto::subsup instproc estasDePronomo {} {
    my instvar astoj
    set e [lindex $astoj 1]
    if {[$e istype SintaksAsto::pp]} {
        set np [[lindex $astoj 1] prenuNPParton]
        expr {[[$e prenuRadiko] estasVorto de] && [$np istype GP::PersonPronomo]}
    } else {
        return 0
    }
}
SintaksAsto::subsup instproc estasKuneblaj {elem ligilo stupo} {
    [my prenuRadiko] estasKuneblaj $elem $ligilo $stupo
}
SintaksAsto::subsup instproc estuDato {} {
    my instvar funkcio
    #my halt
    set funkcio tempo
}
SintaksAsto::subsup instproc faruDeNumeralo {} {
    my instvar astoj radiko
    set r [$radiko prenuRadiko]
    if {[$r hasclass GP::Numeralo]} {
        $r estuSubstantiva
        $r set kazo nominativo
        $r set nombro pluralo
        $r aliguMerkmalon numel
    }
}
SintaksAsto::subsup instproc init {} {
    my instvar astoj radiko
    set radiko [lindex $astoj 0]
    $radiko set funkcio radiko
    [lindex $astoj end] set funkcio pos
    if {[[lindex $astoj end] istype SintaksAsto::konj]} {
        foreach e [[lindex $astoj end] astoj] {
            $e set funkcio pos
        }
    }
    if {[[$radiko prenuRadiko] estasVorto unu]} {
        $radiko aliguMerkmalon numel
    }
}
SintaksAsto::subsup instproc initDePP {} {

}
SintaksAsto::subsup instproc initKunteksto parenco {
    next
    my instvar astoj
    [lindex $astoj end] set funkcio pos
}
SintaksAsto::subsup instproc kolektuSubstantivoj {} {
    concat [[my prenuRadiko] kolektuSubstantivoj] [my selektu {end prenuNPParton kolektuSubstantivoj}]
}
SintaksAsto::subsup instproc prenuNomo {} {
    #my halt
    return Substantivo
}
SintaksAsto::subsup instproc prenuPPParton {} {
    my instvar astoj
    set e [lindex $astoj 1]
    if {[$e istype SintaksAsto::pp]} {
        return $e
    }
}
SintaksAsto::subsup instproc prenuSubsupRadiko {} {
    my prenuRadiko
}
SintaksAsto::subsup instproc tranformuPronomoAlPropraPronomo {} {
    my instvar parenco astoj

    set frazoobj [my info parent]
    set nastoj [list]

    set oprop [[lindex $astoj 1] prenuNPParton]
    set rad [my prenuRadiko]
    set pronvorto [$oprop prenuBazanFormon]a
    if {[$rad estasPluralo]} {
        append pronvorto j
    }
    if {[$rad estasAkuzativo]} {
        append pronvorto n
    }

    set pron [GP::PosesivPronomo new -childof $frazoobj -funkcio parto -vorto $pronvorto -radiko [$oprop radiko] -kazo [$rad kazo] -nombro [$rad nombro]]
    $pron set komenco 0
    $pron set fino 0

    $pron set originaElemento [lindex $astoj 1]

    lappend nastoj $pron
    if {[[lindex $astoj 0] istype GP::Elemento]} {
        lappend nastoj [lindex $astoj 0]
    } else {
        foreach e [[lindex $astoj 0] astoj] {
            lappend nastoj $e
        }
    }
    set main [SintaksAsto::np new -childof $frazoobj -funkcio subfrazo -astoj $nastoj]
    $main set originaElemento [self]
    $main initKunteksto $parenco
    $main initParencon $parenco
    $parenco tausxuAstoj [self] $main
    return $main
}
Class SintaksAstoDebugMix
@ ::SintaksAstoDebugMix idemeta component EspSintaksaAnalizo
SintaksAstoDebugMix instproc debugAnalizo {stupo poziciono mustero} {
    SintaksDebugger debugAston [self] $poziciono $mustero
    next
}
SintaksAstoDebugMix proc malSxaktuDebug {} {
    if {[lsearch [SintaksAsto instmixin] [SintaksAstoDebugMix]]>=0} {
        SintaksAsto instmixin delete [SintaksAstoDebugMix]
    }
}
SintaksAstoDebugMix proc sxaktuDebug {} {
    if {[lsearch [SintaksAsto instmixin] [SintaksAstoDebugMix]]<0} {
        SintaksAsto instmixin add SintaksAstoDebugMix
    }
}
Class SintaksaAnalizo -parameter frazo
@ ::SintaksaAnalizo idemeta component EspSintaksaAnalizo
SintaksaAnalizo instproc analizu {} {
    my instvar frazo

    set radiko [SintaksAsto::main new -childof $frazo -astoj [$frazo elementoj] -funkcio baza]
    $frazo sintaksoarbo $radiko
    $radiko sxercxiIgnorPartoj
    $radiko sxercxiDialogoPriskribo
    # por divigi ; simboloj
    $radiko sxercxiPlenajFrazoj
    $radiko sxercxiCxefrazoj
    $radiko analizu

    $radiko initParencon {}
}
SintaksaAnalizo instproc analizuFS {} {
    my instvar frazo

    set radiko [SintaksAsto::main new -childof $frazo -astoj [$frazo elementoj] -funkcio baza]
    $frazo sintaksoarbo $radiko
    $radiko initParencon {}
    
    FSDefino analizu $radiko
}
SintaksaAnalizo instproc appendMesagxo mes {
    my lappend mesagxoj $mes
}
SintaksaAnalizo proc initializeAfterLoad {} {
    my metuSubfrazoj
}
SintaksaAnalizo proc metuSubfrazoj {} {
    # defino de sintakso por sintaksa analizo
    # Artur Trzewik
    lappend s0 {{nomo igiKonstanto} {{Elemento estasEblaNomo} {Elemento estasEblaNomo}} nurBazajElementoj}
    lappend s0 {{nomo igiKonstanto} {{Elemento estasEblaNomoAuxNomo} {Elemento estasVortoj {de von van}} {Elemento estasEblaNomo}} nurBazajElementoj}
    lappend s0 {{nomo igiKonstanto} {{Elemento estasNomo} {Elemento estasEblaNomo}} nurBazajElementoj}
    # Marko la Tria
    lappend s0 {{nomo igiKonstanto} {{Elemento estasEblaNomo} {Difinilo estasVorto la} {Numeralo estasAdjektivaGrandskribita}}}
    lappend s0 {{nomo igiKonstanto} {{Elemento estasNomo} {Difinilo estasVorto la} {Numeralo estasAdjektivaGrandskribita}}}
    # Prezidanto Bush
    lappend s0 {ident {{Substantivo estasIdentEbla} Konstanto}}
    # sinjorino Zminska
    # sinjorino Jonaso
    lappend s0 {ident {{Substantivo estasIdentEbla} {Elemento estasEblaNomo}}}
    # urbo varsovio
    lappend s0 {ident {{Substantivo estasIdentEbla} {Substantivo estasPropraNomo}}}
    # lingvo esperanto
    lappend s0 {ident {{Substantivo estasVorto lingvo} {Substantivo estasVorto esperanto}}}

    lappend s0 {ignor {{Elemento estasElemento %e} {Simbolo estasVorto ...}}}
    # la tri cent dua
    # unu triono
    # lappend s1 {num {{Numeralo estasNurNumero} {Numeralo estasOnoj}}}
    # proksimume du, dua
    lappend s0 {{grupo igiRadikoLasta} {{Adverbo estasVorto proksimume} {Numeralo estasNeSubstantiva}}}
    lappend s0 {adjp {{Difinilo estasVorto la} {PrimitivaAdverbo estasVortoj {malplej plej}} Adjektivo}}
    lappend s0 {advp {{Difinilo estasVorto la} {PrimitivaAdverbo estasVortoj {malplej plej}} Adverbo}}
    # ecx dek unu homoj
    # ecx granda homo
    lappend s0 {grupo {{PrimitivaAdverbo estasDirektaElementoPriskribo} {Elemento estasNeSimboloNeVerbo}}}
    lappend s0 {grupo {{Adverbo estasVorto eble} {Elemento estasNeVerbo}}}
    # en aprilo 1990
    lappend s0 {{grupo igiRadikoUnua} {{Substantivo estasMonato} {Numeralo estasNurNumero}}}
    lappend s0 {grupo {{Numeralo estasNurNumero} {Prepozicio estasVorto ĝis} {Numeralo estasNurNumero}}}
    lappend s0 {{grupo igiRadikoUnua} {{Substantivo estasVorto jaro} {Numeralo estasNurNumero}}}
    lappend s0 {grupo {{TabloVorto estasVorto neniam} {PrimitivaAdverbo estasVorto plu}}}
    lappend s0 {{grupo igiRadikoUnua} {{PersonPronomo estasVortoj {ili ni vi}} {Difinilo estasVorto ambaŭ}}}
    # , kiuj ambaux ....
    lappend s0 {{grupo igiRadikoUnua} {{TabloVorto estasVortoj {kiuj kiujn}} {Difinilo estasVorto ambaŭ}}}
    # duopaj prepozicioj
    lappend s0 {{grupo igiRadikoUnua} {{Prepozicio estasVortoj {al de el}} {Prepozicio estasVortoj {trans malantaŭ post sub}}}}
    lappend s0 {{grupo igiRadikoUnua} {{Prepozicio estasVortoj {al de}} {Prepozicio estasVortoj {ĉe super ĉirkaŭ sur antaŭ apud inter en}}}}
    # frazajxoj
    lappend s0 {frazj {{Numeralo estasVorto unu} Prepozicio {Difinilo estasVorto la} {Adjektivo estasVortoj {alia aliaj}}}}
    lappend s0 {frazj {{Numeralo estasVorto unu} Prepozicio {Adjektivo estasVorto alia}}}
    lappend s0 {frazj {{Numeralo estasVorto unu} {Difinilo estasVorto la} {Adjektivo estasVortoj {alian aliajn}}}}
    lappend s0 {frazj {{PrimitivaAdverbo estasVorto jen} {Konjunkcio estasVorto kaj} {PrimitivaAdverbo estasVorto jen}}}
    lappend s0 {frazj {{TabloVorto estasVorto iom} {Prepozicio estasVorto post} {TabloVorto estasVorto iom}}}
    lappend s0 {frazj {{Prepozicio estasVorto de} {Adverbo estasVortoj {alte sube supre}}}}
    # inter alie
    lappend s0 {frazj {{Prepozicio estasVorto inter} {Adverbo estasVorto alie}}}
    lappend s0 {{grupo igiRadikoLasta} {{PrimitivaAdverbo estasVortoj {pli malpli}} {Konjunkcio estasVorto ol} {Numeralo estasNurNumero}}}
    # cxi tie
    lappend s0 {grupo {{PrimitivaAdverbo estasVorto ĉi} {TabloVorto estasArtoj {e u o a}}}}

    lappend s1 {num {{Numeralo estasNurNumero} {Numeralo estasNeSubstantiva}}}
    # li tro laboras.
    lappend s1 {grupo {{PrimitivaAdverbo estasVortoj {tre tro}} Verbo}}
    lappend s1 {grupo {{Adverbo estasVortoj {multe malmulte multege malmultege iomete}} {PrimitivaAdverbo estasVortoj {pli malpli}}}}
    lappend s1 {grupo {{TabloVorto estasVorto {iom}} {PrimitivaAdverbo estasVortoj {pli malpli}}}}

    # lappend s1 {grupo {{Verbo eblasFor} {PrimitivaElemento estasVorto for}}}
    # antaŭ ol
    lappend s1 {padv {{PrimitivaAdverbo estasVortoj {pli plej malplej malpli}} Adverbo}}
    lappend s1 {padj {{PrimitivaAdverbo estasVortoj {pli plej malplej malpli}} Adjektivo}}
    lappend s1 {padj {{Konjunkcio estasVortoj {ju des}} :padj}}
    lappend s1 {padv {{Konjunkcio estasVortoj {ju des}} :padv}}
    lappend s1 {grupo {{Konjunkcio estasVortoj {ju des}} {PrimitivaAdverbo estasVortoj {pli malpli}}}}
    # suficxe bona
    lappend s1 {advp {{Adverbo estasAdvAdv} Adverbo}}
    lappend s1 {adjp {{Adverbo estasAdvAdv} Adjektivo}}
    lappend s1 {adjp {{:TabloVorto estasVortoj {ĉiam neniam iam tiel}} Adjektivo}}
    # bone sciate
    lappend s1 {advp {Adverbo {Adverbo estasPartizipo}}}
    # bone konata
    # sed ne vidante konatan ...
    lappend s1 {adjp {{Adverbo estasNeParticipo} {Adjektivo estasPartizipo}}}
    lappend s1 {advp {{:TabloVorto estasVortoj {kiel tiel iel}} Adverbo}}
    lappend s1 {advp {{:ne radikoEstasVortoj {kiel tiel iel}} Adverbo}}

    lappend s1 {advp {{PrimitivaAdverbo estasVortoj {tre tro apenaŭ preskaŭ kvazaŭ}} Adverbo}}
    lappend s1 {adjp {{PrimitivaAdverbo estasVortoj {tre tro apenaŭ preskaŭ kvazaŭ}} Adjektivo}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} Verbo}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} Adverbo}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} Adjektivo}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} Prepozicio}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} {TabloVorto estasBazo ĉi}}}
    # unue kiel ne havas la "adverban" karakteron
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} {TabloVorto estasArto el}}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} PrimitivaAdverbo}}
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} PosesivPronomo}}
    # tio estas ne homo.
    lappend s1 {ne {{PrimitivaAdverbo estasVorto ne} Substantivo}}
    lappend s1 {konj {{Adjektivo estasNeTablovorto} {Simbolo estasVorto ,} {Adjektivo estasNeTablovorto}}}
    # la nun forgesita libro
    lappend s1 {grupo {{PrimitivaAdverbo estasVortoj {nun jam ĵus almenaŭ ankaŭ apenaŭ preskaŭ tuj baldaŭ tamen}} {Adjektivo estasPartizipo}}}
    lappend s1 {grupo {{TabloVorto estasArtoj {e u o a}} {PrimitivaAdverbo estasVorto ĉi}}}
    lappend s1 {grupo {{TabloVorto estasBazoj {ki i neni ĉi}} {PrimitivaAdverbo estasVorto ajn}}}
    lappend s1 {grupo {{Interjekcio estasVortoj kvazaŭ} {Elemento estasElemento %e}} nePostKomo}

    # post kiam
    lappend s1 {advp {{Prepozicio estasTempoebla} {TabloVorto estasArto am}}}
    # de kie
    lappend s1 {advp {{Prepozicio estasLokoebla} {TabloVorto estasArto e}}}

    # cxirkaux dek
    lappend s1 {{grupo igiRadikoLasta} {{Prepozicio estasVorto ĉirkaŭ} {Numeralo estasNurNumero}}}
    # entute dek
    lappend s1 {{grupo igiRadikoLasta} {{Adverbo estasVorto entute} {Numeralo estasNurNumero}}}
    # krom al
    lappend s1 {{grupo igiRadikoLasta} {{Prepozicio estasVortoj {krom anstataŭ}} Prepozicio}}

    lappend s2 {{np igiPluralo} {{PersonPronomo estasVortoj {ni vi ili}} {TabloVorto estasVorto ĉiuj}}}
    lappend s2 {{np igiPluralo} {{PersonPronomo estasVortoj {nin vin ilin}} {TabloVorto estasVorto ĉiujn}}}
    lappend s2 {grupo {Substantivo {PrimitivaAdverbo estasVorto mem}}}
    # la nenion faranta homo
    # sed ne: mi opinis tiun taskon funkcianta
    # lappend s4 {advp {{Substantivo estasAkuzativo} {Adverbo estasTranzitivaPartizipo}} sekvasSubstantivo}
    lappend s2 {advp {{Substantivo estasAkuzativo} {Adjektivo estasTranzitivaPartizipo}} sekvasSubstantivo}

    lappend s2 {np {Difinilo Adjektivo {Substantivo estasNePronomo}}}
    lappend s2 {pp {{Prepozicio estasVortoj {en post de ĝis ekde}} {Numeralo estasJaroNumero}}}
    lappend s2 {np {Numeralo {Substantivo estasNePronomoNum}}}
    lappend s2 {np {{Difinilo estasVorto ambaŭ} {Substantivo estasNePronomoNum}}}
    lappend s2 {np {PosesivPronomo Adjektivo {Substantivo estasNePronomo}} samaNombroKazo}
    lappend s2 {np {Difinilo {Substantivo estasNePronomo}}}
    lappend s2 {np {Adjektivo {Substantivo estasNeDifinita %e ""}} samaNombroKazo}
    # lappend s2 {np {Substantivo {Adjektivo estasNeParticipo}} samaNombroKazo}
    # lappend s2 {np {{Substantivo estasNeDifinita %e nominativo} {Adjektivo estasNominativoNeParticipo}}}
    lappend s2 {np {PosesivPronomo {Substantivo estasNePronomo}} samaNombroKazo}
    lappend s2 {np {{TabloVorto estasArto u} {Substantivo estasNeDifinitaPP %e}} samaNombroKazo}
    lappend s2 {np {{TabloVorto estasArto es} {Substantivo estasNeDifinitaPP %e}}}
    # Mi havas multajn tiujn librojn.
    lappend s2 {np {{Adjektivo estasPseudoNumeralo} {Substantivo estasNePronomoNum}} samaNombroKazo}

    # estas farinta
    lappend s2 {ktempo {{Verbo estasBasaVorto esti} {Adjektivo estasTranzitivaPartizipo}}}

    # li estas kiel granda domo
    # li estas ne kiel granda domo
    lappend s2 {adjp {{:TabloVorto estasVortoj {kiel tiel iel}} {Adjektivo neHavasMerkmalon substantivaRolo}}}
    lappend s2 {adjp {{:ne radikoEstasVortoj {kiel tiel iel}} {Adjektivo neHavasMerkmalon substantivaRolo}}}

    lappend s2 {adjp {Adverbo {Adjektivo estasPartizipo}}}
    lappend s2 {adjp {:padj {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    lappend s2 {adjp {:padj {Konjunkcio estasVorto ol} {PrimitivaAdverbo estasTempo}}}
    lappend s2 {adjp {:padj {Konjunkcio estasVorto ol} Adjektivo}}
    lappend s2 {advp {:padv {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    lappend s2 {advp {:padv {Konjunkcio estasVorto ol} {PrimitivaAdverbo estasTempo}}}

    # pli frue ol tiam
    lappend s2 {advp {:padv {Konjunkcio estasVorto ol} {TabloVorto estasVortoj {tiam ĉiam tie}}}}
    # pli ol la inctruisto, pli ol la aliaj
    lappend s2 {advp {{PrimitivaAdverbo estasVortoj {pli malpli}} {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    # ne tre bone cxar ne funkcias por germana lingvo
    lappend s2 {{grupo radikoSurVerbo} {{PrimitivaAdverbo estasVortoj {pli malpli}} Verbo {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    # Mi povas pli multe legi ol vi
    lappend s2 {{grupo radikoSurVerbo} {:padv Verbo {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    lappend s2 {np {{PrimitivaAdverbo estasVortoj {pli malpli}} {:np havasAdjektivon}}}
    lappend s2 {grupo {{Difinilo estasVorto la} {Adjektivo estasBazajVortoj sama}}}
    # mi volas "la bonan". "la duan"
    lappend s2 {np {{Difinilo estasVorto la} {Adjektivo estasElemento %e}}}
    # la dudek unua
    lappend s2 {np {{Difinilo estasVorto la} {Numeralo estasAdjektiva}}}

    lappend s2 {np {{TabloVorto estasArto o} Adjektivo} samaNombroKazo}
    lappend s2 {np {{TabloVorto estasArto u} Adjektivo} samaNombroKazo}

    # la sepa kaj dek
    # lappend s2 {horo {{Difinilo estasVorto la} {Numeralo estasAdjektiva} {?Substantivo estasVorto horo} {?Konjunkcio estasVorto kaj} {Numeralo estasNurNumero} {?Substantivo estasVorto minutoj}}}
    # lappend s2 {horo {{Difinilo estasVorto la} {Numeralo estasAdjektiva} {?Substantivo estasVorto horo} {?Konjunkcio estasVorto kaj} {Substantivo estasVortoj {duono kvarono}}}}
    # lappend s2 {horo {{Numeralo estasNurNumero} {?Substantivo estasVorto minutoj} {Prepozicio estasVortoj {post antaŭ}} {Difinilo estasVorto la} {Numeralo estasAdjektiva} {?Substantivo estasVorto horo}}}
    # lappend s2 {horo {{Difinilo estasVorto la} {Numeralo estasAdjektiva} {?Substantivo estasVorto horo}}}

    # lappend s2 {horo {{Difinilo estasVorto la} {Numeralo estasAdjektiva} {?Substantivo estasVorto horo} {Numeralo estasNurNumero}}}
    # lappend s2 {horo {{Numeralo estasLaAdjektiva} {Numeralo estasNurNumero}}}
    # lappend s2 {horo {{Substantivo estasVorto horo} {Numeralo estasNurNumero}}}
    # lappend s2 {horo {{Numeralo estasLaAdjektiva} {Konjunkcio estasVorto kaj} {Numeralo estasNurNumero}}}
    # lappend s2 {horo {{Substantivo estasVorto horo} {Konjunkcio estasVorto kaj} {Numeralo estasNurNumero}}}

    # io bona, ion bonan

    lappend s3 {pp {Prepozicio {Substantivo estasNominativo}}}
    lappend s3 {pp {{Prepozicio estasDusignifa} {Substantivo estasAkuzativo}}}
    lappend s3 {pp {Prepozicio {PersonPronomo estasNominativo}}}
    lappend s3 {pp {{Prepozicio estasDusignifa} {PersonPronomo estasAkuzativo}}}
    lappend s3 {pp {Prepozicio {Adjektivo estasNominativoSubRolo}}}
    lappend s3 {pp {{Prepozicio estasDusignifa} {Adjektivo estasAkuzativoSubRolo}}}
    lappend s3 {pp {{Prepozicio estasVorto po} {Numeralo estasNurNumero}}}
    lappend s3 {{pp igiKonst} {Prepozicio {Elemento estasNekonataGrandskribitaAuxNomo}}}

    lappend s3 {adjp {{:pp estasPrepozicio de} {Adjektivo estasParticipoPasiva}}}

    # ni esperantistoj
    lappend s3 {ident {{PersonPronomo estasBasaVorto ni} Substantivo} samaNombroKazo}

    # antaux longe, nelonge
    lappend s3 {frazj {{Prepozicio estasVorto antaŭ} {Adverbo estasVortoj {longe nelonge}}}}

    lappend s4 {adjp {{Adjektivo estasPartizipo} {:pp estasNeKiu}}}
    # problemo pro: Mi volas trovi libron de patro kaj libron de frato.
    # lappend s4 {nfvp {{Verbo estasInfinitivoTransitiva} {Substantivo estasAkuzativo}}}
    lappend s4 {nfvp {{Verbo estasInfinitivoEst} Adjektivo}}
    # havanta domon
    lappend s4 {adjp {{Adjektivo estasTranzitivaPartizipo} {Substantivo estasAkuzativo}}}
    lappend s4 {advp {{Adverbo estasTranzitivaPartizipo} {Substantivo estasAkuzativo}}}


    # homo havanta
    lappend s4 {np {Substantivo {Adjektivo estasPartizipo}} samaNombroKazo}
    lappend s4 {{advp estuTempo} {{Prepozicio estasTempoebla} {PrimitivaAdverbo estasTempo}}}
    # de longe
    lappend s4 {{advp estuTempo} {{Prepozicio estasVorto de} {Adverbo estasVortoj {longe proksime malproksime alte malantaŭe ekstere komence antaŭe interne}}}}
    # [kiel domo] granda - rapida [kiel tigriso] - homo [kiel prezidanto]
    lappend s4 {kadv {{:TabloVorto estasVorto kiel} Substantivo} kielNeDemando}
    lappend s4 {kadv {{:TabloVorto estasVorto kiel} {Adjektivo havasMerkmalon substantivaRolo}} kielNeDemando}
    lappend s4 {kadv {{:TabloVorto estasVorto kiel} :pp} kielNeDemando}
    # Mi ne faros kiel gxis nun
    lappend s4 {kadv {{:TabloVorto estasVorto kiel} {:advp havasMerkmalon tempo}} kielNeDemando}
    lappend s4 {kadv {{:ne radikoEstasVortoj {kiel}} Substantivo} kielNeDemando}
    lappend s4 {kadv {{:Konjunkcio estasVorto ol} Substantivo} kielNeDemando}
    lappend s4 {kadv {{:Konjunkcio estasVorto ol} :pp} kielNeDemando}
    lappend s4 {kadv {{:Konjunkcio estasVorto ol} Adverbo} kielNeDemando}
    lappend s4 {kadv {{:Konjunkcio estasVorto ol} {:advp havasMerkmalon tempo}} kielNeDemando}
    lappend s4 {adjsup {:kadv Adjektivo}}
    lappend s4 {advsup {:kadv Adverbo}}
    lappend s4 {adjsup {Adjektivo :kadv}}
    lappend s4 {advsup {Adverbo :kadv}}
    lappend s4 {subsup {Substantivo :kadv} samaNombroKazo}
    # iu el kontaj personoj
    lappend s4 {subsup {{TabloVorto estasArto u} {:pp estasPrepozicio el}}}
    # tri el la libroj estas bonaj
    lappend s4 {{subsup faruDeNumeralo} {{Numeralo estasNurNumero} {:pp estasPrepozicio el}}}
    lappend s4 {advsup {{Adverbo estasVortoj {responde koncerne spite danke}} {Substantivo estasAkuzativo}}}
    lappend s4 {advsup {{Adverbo estasVortoj {danke fronte rilate omaĝe profite malprofite konforme proksime malproksime vice spite}} {:pp estasPrepozicio al}}}
    lappend s4 {advsup {{Adverbo estasDaSubj} {:pp estasPrepozicio da}}}
    lappend s4 {advsup {{PrimitivaAdverbo estasVortoj {tro pli malpli}} {:pp estasPrepozicio da}}}
    # kaze de dangxero vi devas forkuri.
    lappend s4 {advsup {{Adverbo eblasSuplementoPerDe} {:pp estasPrepozicio de}}}
    # li estas for de mi
    lappend s4 {advsup {{PrimitivaAdverbo estasVorto for} {:pp estasPrepozicio de}}}
    lappend s4 {adjsup {{Adjektivo estasBazajVortoj {plena malplena inda malinda enda malenda}} {:pp estasPrepozicio de}}}
    lappend s4 {adjsup {{Adjektivo estasBazajVortoj {ebla malebla}} {:pp estasPrepozicio por}}}
    lappend s4 {adjsup {{Adjektivo estasBazajVortoj {soifa riĉa plena malplena inda simila malinda malsimila malriĉa avida malavida malsana dika fiera malfiera indiferenta}} {:pp estasPrepozicio je}}}
    lappend s4 {adjsup {{:np estasNombraAkuzativa} {Adjektivo estasBazajVortoj {longa peza mallonga aĝa}}}}
    lappend s4 {adjsup {Adjektivo {:pp estasPrepozicio por}}}


    # Tio estas pli grava por mi ol tio.
    lappend s4 {adjp {{:adjsup estasPadj} {Konjunkcio estasVorto ol} {NombroKazo estasSubstantiva}}}
    lappend s4 {adjp {{:adjsup estasPadj} {Konjunkcio estasVorto ol} {PrimitivaAdverbo estasTempo}}}
    lappend s4 {adjp {{:adjsup estasPadj} {Konjunkcio estasVorto ol} Adjektivo}}

    # la mondo libera
    # problemo: la mondo plena de homoj estas maltrankvila
    # problemo 2: libro de frato maljuna
    lappend s4 {np {{Substantivo estasNeDifinitaDekstra %e akuzativo} {Adjektivo estasAkuzativo}}}
    lappend s4 {np {{Substantivo estasNeDifinitaDekstra %e nominativo} {Adjektivo estasNominativo}}}


    lappend s4 {advsup {{TabloVorto estasArto om} {:pp estasPrepozicio da}}}
    lappend s4 {pp {Prepozicio {:advsup eblasKielSubstantivo}}}
    lappend s4 {advp {{Substantivo estasTempoAkuzativo} {Adverbo estasVortoj {poste frue}}}}
    lappend s4 {subsup {{Substantivo estasDistanco} {PrimitivaAdverbo estasVorto for}}}

    #lappend s4 {{subsup initDePP} {:pp {:pp estasPrepozicioj {de kun sen}}}}

    # Atendu ke infinitivaj verbo frazoj "vidi vin" kaj substantivaj suplementoj "libro de patro"
    # estas prilaboritaj speciale
    # vidu metodon: sxercxiKompleksajSubjektivanSuplementon

    # antaux ol
    lappend s5 {{grupo igiAntauOl} {{Prepozicio estasVorto antaŭ} {Konjunkcio estasVorto ol}}}
    # [por sen krom antstatux malgraux] ke
    lappend s5 {{grupo igiFkonj} {{Prepozicio estasVortoj {por sen krom anstataŭ malgraŭ}} {Interjekcio estasVorto ke}}}
    # ke se
    lappend s5 {{grupo igiFkonj} {{Interjekcio estasVorto ke} {Interjekcio estasVorto se}}}
    # ol ke
    lappend s5 {{grupo igiFkonj} {{Konjunkcio estasVorto ol} {Interjekcio estasVorto ke}}}
    # ol kiam
    lappend s5 {{grupo igiFkonj} {{Konjunkcio estasVorto ol} {TabloVorto estasVorto kiam}}}
    # sed kiam
    lappend s5 {{grupo igiFkonj} {{Konjunkcio estasVorto sed} {TabloVorto estasVorto kiam}}}
    # kaj ke
    # sed ke
    lappend s5 {{grupo igiFkonj} {{Konjunkcio estasVortoj {kaj sed}} {Interjekcio estasVorto ke}}}
    # nur se
    # nur cxar
    # ecx se
    # ecx cxar
    lappend s5 {{grupo igiFkonj} {{PrimitivaAdverbo estasVortoj {nur eĉ}} {Interjekcio estasVortoj {se ĉar}}}}
    # precipe ĉar
    # ne ĉar
    # ankaŭ ĉar
    # sed ĉar
    # ke ĉar
    # eble ĉar
    # ĝuste ĉar
    # simple ĉar
    # almenaŭ ĉar
    # ankaŭ ĉar
    # due ĉar
    # unue cxar
    lappend s5 {{grupo igiFkonj} {{Elemento estasVortoj {krom precipe ankaŭ sed ke eble ĝuste simple almenaŭ ankaŭ due unue ne}} {Interjekcio estasVorto ĉar}}}
    # kiel se
    # eĉ se
    # krom se
    # kaj se
    # ke se
    # ĉar se
    # do se
    # tamen se
    # aŭ se
    lappend s5 {{grupo igiFkonj} {{Elemento estasVortoj {eĉ krom kaj sed ke ĉar do tamen kiel nur}} {Interjekcio estasVorto se}}}
    # ne nur cxar
    lappend s5 {{grupo igiFkonj} {{PrimitivaAdverbo estasVorto ne} {PrimitivaAdverbo estasVorto nur} {Interjekcio estasVorto ĉar}}}
    # eĉ ne se
    lappend s5 {{grupo igiFkonj} {{PrimitivaAdverbo estasVorto eĉ} {PrimitivaAdverbo estasVorto ne} {Interjekcio estasVorto se}}}
    # sed ne se
    lappend s5 {{grupo igiFkonj} {{Interjekcio estasVorto sed} {PrimitivaAdverbo estasVorto ne} {Interjekcio estasVorto se}}}
    # certe ne se
    lappend s5 {{grupo igiFkonj} {{Adverbo estasVorto certe} {PrimitivaAdverbo estasVorto ne} {Interjekcio estasVorto se}}}

    my set subfrazoj [list $s1 $s2 $s3 $s4 $s5 $s0]
}
@ Class Vortaro {
description {Tio estas cxefa klaso por uzi la esperantan vortaron.
Cxiuj radikoj kaj derivajxoj  estas legitaj de radikoj.xotcl dosiero.
La klaso havas ankaux la fabrikan metodn Vortaro->prenuVortaron.
 set vortaro [Vortaro prenuVortaron]
 set rezulto [$vortaro estasVorto "vidas"]
 if {$rezulto == 2} { puts "normala esperanta vorto" }
Vortaro estas ankaux fabriko por objektoj de tipo GP::Elemento (Gramatika Elemento),
kiu laboras kiel markita (tagged) vorto.
}
}
Class Vortaro
@ ::Vortaro idemeta categories {morfologio init-release api gramatiko private konservado}
@ ::Vortaro idemeta categoriesMethods {{sxercxiPrefikso sxercxuErarojDerivajxoj sxercxiSufikson prenuVortfarado finaVortklaso prenuMorfcxeno estasPartizipo estasRadiko sxercxuKategorion testuVortfarado estasBasaVorto sxarguRadikoj} {initOftajnRadikojn initPrimitivajVortojn init} {prenuDerivoPropono prenuFiksaMorfcxeno prenuLingvo testuNumeralo prenuBazanFormon estasOftaRadiko estasVorteto estasVorto} {prenuGramfinajxo estasPrimitivaVorto prenuGramElemento prenuPrimitivaGramElemento} {sxercxiPartizipaVortparto sxercxiSufiksojn sxercxiSufiksonVortparto prenuNumeraloElemento metuKandidaton} {konservuPrivatanRadikonForigon konservuPrivatanDerivoDiskribo konservuPrivatanDerivoForigon konservuPrivatanDerivon konservuPrivatanRadikon prenuPrivatanVortaron alliguIgnorvorto konservuPrivatanRadikonEstuKutimaRadiko konservuPrivatanRadikonEstuPropraNomo sxarguIgnorvortoj malfermuPrivatanVortaron}}
@ ::Vortaro idemeta component EspSintaksaAnalizo
Vortaro instproc alliguIgnorvorto {vorto {nurNun 0}} {
    my instvar ignorVortoj
    lappend ignorVortoj [string tolower $vorto]
    if {!$nurNun} {
        IgnorvortoListo alliguIgnorvorto [string tolower $vorto] eo
    }
}
Vortaro instproc estasBasaVorto {aradiko basavorto} {
    my instvar sufiksoj prefiksoj prefikso sufikso radiko pradiko kandidatoj derivolisto vortktg
    set radiko $aradiko
    set radobj ""
    set estasradiko 0
    set pradiko ""
    set prefikso ""
    set sufikso ""
    set radobj [Radiko prenuRad $radiko]

    if {[Object isobject $radobj]} {
        if {[llength [set derivolisto [$radobj sxercxuDerivon $basavorto]]]>0} {
            my set derivo $basavorto
            return 2
        } else {
            lappend kandidatoj [list {} $radiko {} $vortktg]
            set estasradiko 1
        }
    }
    if {[my testuNumeralo $basavorto]} {
        return 2
    }
    # probu vorto je mustero [prefikso] vorto [sufikso1] [sufikso2] ĉiuj ebloj
    # sxercxi sufiksoj
    lappend vortfarodolisto $prefikso $radiko $sufikso
    set sufj [my sxercxiSufiksojn $radiko]
    if {[llength $sufj]>0} {
        foreach {erg sufikso} $sufj {
            lappend vortfarodolisto $prefikso $erg $sufikso
            if {[my estasRadiko $erg $basavorto estasradiko $prefikso $sufikso]} {
                return 2
            } else {
                # ŝerĉu prefikson
                set erg2 [my sxercxiPrefikso $erg]
                if {$erg2 ne ""} {
                    lappend vortfarodolisto $prefikso $erg2 $sufikso
                    if {[my estasRadiko $erg2 $basavorto estasradiko $prefikso $sufikso]} {
                        return 2
                    }
                }
                set prefikso ""
                # probu duan sufikson
                set erg2 [my sxercxiSufikson $erg]
                if {$erg2 ne ""} {
                    lappend vortfarodolisto $prefikso $erg2 $sufikso
                    if {[my estasRadiko $erg2 $basavorto estasradiko $prefikso $sufikso]} {
                        return 2
                    } else {
                        set erg3 [my sxercxiPrefikso $erg2]
                        lappend vortfarodolisto $prefikso $erg3 $sufikso
                        if {$erg3 ne ""} {
                            if {[my estasRadiko $erg3 $basavorto estasradiko $prefikso $sufikso]} {
                                return 2
                            }
                        }
                    }
                }
            }
        }
    } else {
        # sxercxi prefiksoj
        set erg [my sxercxiPrefikso $radiko]
        if {$erg ne ""} {
            lappend vortfarodolisto $prefikso $erg $sufikso
            if {[my estasRadiko $erg $basavorto estasradiko $prefikso $sufikso]} {
                    return 2
            }
        }
    }
    foreach {pre frad suf} $vortfarodolisto {
        set erg [my testuVortfarado $frad $basavorto $pre $suf]
        if {$erg==2} {
            set prefikso $pre
            set sufikso $suf
            return 2
        } elseif {$erg==1} {
            set estasradiko 1
        }
        # sxercxi partizipaj sufiksoj kiam suf ne ekzistas
        # ekzemple:
        # mortintino, devontigi
        set psuf [my sxercxiPartizipaVortparto $frad]
        if {[llength $psuf]>0} {
            if {[my estasRadiko [lindex $psuf 0] $basavorto estasradiko $prefikso [lindex $psuf 1]$suf]} {
                return 2
            } else {
                set erg [my testuVortfarado [lindex $psuf 0] $basavorto $pre [lindex $psuf 1]$suf]
                if {$erg==2} {
                    set prefikso $pre
                    set sufikso [lindex $psuf 1]$suf
                    return 2
                } elseif {$erg==1} {
                    set estasradiko 1
                }
            }
        }
    }
    # escepto. Landonomoj havas sufikso "i-o"
    if {[string range $basavorto end-1 end] eq "io"} {
        set radobj [Radiko prenuRad [string range $basavorto 0 end-2]]
	if {[Object isobject $radobj] && [llength [set derivolisto [$radobj sxercxuDerivon $basavorto]]]>0} {
	     set sufikso i
             set radiko [string range $basavorto 0 end-2]
             return 2
        }
    }
    return $estasradiko
}
@ Vortaro instproc estasOftaRadiko {} {
description {Testas cxu radiko apartenas al oftaj radikoj laux interna tabelo}
}
Vortaro instproc estasOftaRadiko radiko {
    my instvar oftajRadikoj
    expr {[lsearch -exact -sorted $oftajRadikoj $radiko]>=0}
}
Vortaro instproc estasPartizipo {} {
    expr {t in [my set zyklo]}
}
Vortaro instproc estasPrimitivaVorto {} {
    my instvar radiko derivo vortktg
    expr {$radiko eq $derivo || $vortktg eq ""}
}
Vortaro instproc estasPropraNomo {} {
    my instvar radiko derivolisto
    set radobj Radiko::$radiko
    expr {[Object isobject $radobj] &&  ([$radobj istype Propranono] || "pnomo" in [lindex $derivolisto 2])}
}
Vortaro instproc estasRadiko {radkandidato vorto estasRadiko_ref prefikso sufikso} {
    set radobj [Radiko prenuRad $radkandidato]
    my instvar derivolisto vortktg
    if {[Object isobject $radobj]} {
        if {[llength [set derivolisto [$radobj sxercxuDerivon $vorto]]]>0} {
            my set radiko $radkandidato
            my set derivo $vorto
            return 1
        }
        # elba miskomprenata participo okazinta (ekzistas radikoj okaz kaj okazint)
        if {$sufikso in {int ant ont it at ot}} {
            if {[llength [set derivolisto [$radobj sxercxuDerivon ${prefikso}${radkandidato}i]]]>0} {
                my sxercxuKategorion $vorto[string range [my prenuGramfinajxo] 1 end] 0
                my set radiko $radkandidato
                my set derivo ${prefikso}${radkandidato}i
                return 1
            }
        }
        upvar $estasRadiko_ref estasradiko
        set estasradiko 1
        my lappend kandidatoj [list $prefikso $radkandidato $sufikso $vortktg]
    }
    return 0
}
@ Vortaro instproc estasVorteto {} {
description {Testas cxu vorto estas vorteto (prononomo, rolvorteto, tablovorto, ...)}
}
Vortaro instproc estasVorteto vorteto {
    my instvar pronomoj
    expr {[lsearch -exact -sorted $pronomoj $vorteto]>=0}
}
@ Vortaro instproc estasVorto {} {
description {Resultoj
   0. radiko ne trovita
   1. trovita sed sen derivo
   2. trovita kun derivo
   3. vorto en ignorlisto
   4. numeralo (nomrmala number aux kun adjektiva fino '2-a')
   5. mallongigxo

La objekt vortaro havas poste la statoj en objektvariabloj:
  radiko vortktg sufikso prefikso}
}
Vortaro instproc estasVorto {vorto {ignoruStreko 1}} {
    my instvar sufiksoj prefiksoj pronomoj silaboj radiko prefikso sufikso vortktg ignorVortoj kandidatoj pradiko derivolisto estasNumeralo veraNombro tablovortoj
    set vorto [string tolower $vorto]
    set radiko $vorto
    set radobj ""
    set estasradiko 0
    set silaboj [list]
    set prefikso ""
    set sufikso ""
    set vortktg ""
    set kandidatoj [list]
    set pradiko ""
    set estasNumeralo 0
    set veraNombro ?
    my set derivo ""
    my set zyklo ""
    set derivolisto {{} {}}
    if {[lsearch -exact -sorted $ignorVortoj $vorto]>=0} {
        return 3
    }
    if {[string is double $vorto] || [regexp {(\d)+-?aj?n?} $vorto _ veraNombro]} {
        return 4
    }
    if {[string index $vorto end] eq "." && [Vortaro estasMallongigo [string range $vorto 0 end-1]] ne ""} {
        return 5
    }
    if {[string tolower $vorto] in {kg mm km}} {
        return 5
    }
    if {[string first - $vorto]>0 && $vorto in {s-ro s-rino s-ron s-rinon s-roj e-o e-on n-ro n-ron d-ro d-ron}} {
        return 5
    }

    if {[lsearch -sorted $pronomoj $vorto]>=0} {
        if {[lsearch -sorted $tablovortoj $vorto]>=0} {
            set radiko ""
        } else {
            set radiko $vorto
        }
        my set derivo $vorto
        return 2
    }
    # ekzemple cxi-jara = cxijara
    # provi forigi la strekon -
    set kunstrekoEbla 0
    if {$ignoruStreko && [string first - $vorto]>0} {
        set ret [my estasVorto [string map {- ""} $vorto]]
        if {$ret==2} {
            return $ret
        } else {
            set kunstrekoEbla 1
        }
        set kandidatoj [list]
    }
    set radiko [my sxercxuKategorion $vorto]
    set basavorto ${radiko}$vortktg

    if {[my testuNumeralo $vorto]} {
        return 2
    }

    set erg [my estasBasaVorto $radiko $basavorto]
    my instvar zyklo
    # cxu participa finajxo ne estas parto de radiko
    if {$vortktg eq "i" && [lindex $zyklo end] in {it ot at ant ont int}} {
        set t_zyklo $zyklo
        set t_vortktg $vortktg
        set t_radiko $radiko
        set t_basavorto $basavorto
        set t_derivolist $derivolisto
        set t_prefikso $prefikso
        set t_sufikso $sufikso
        set t_pradiko $pradiko
        for {set x [llength $zyklo]} {$x>=0} {incr x -1} {
            if {[lindex $zyklo $x] in {a e o}} {
                set vortktg [lindex $zyklo $x]
                set radiko [string range $vorto 0 end-[expr {$x+1}]]
                set zyklo [lrange $zyklo 0 $x]
                set basavorto ${radiko}$vortktg
                break
            }
        }
        set t_derivolisto $derivolisto
        set erg2 [my estasBasaVorto $radiko $basavorto]
        if {$erg2>$erg} {
            if {$erg2==1} {
                my metuKandidaton
            }
            return $erg2
        } else {
            set vortktg $t_vortktg
            set radiko $t_radiko
            set zykolo $t_zyklo
            set basavorto $t_basavorto
            set derivolisto $t_derivolisto
            set prefikso $t_prefikso
            set sufikso $t_sufikso
            set pradiko $t_pradiko
        }
        set derivolisto $t_derivolisto
        set zyklo $t_zyklo
        set vortktg i
    }
    if {$erg==2} {
        return $erg
    }
    if {$vortktg ne ""} {
       set e [my testuNumeralo $vorto]
       if {$e==2} {
           return $e
       }
    }
    if {$vortktg eq ""} {
        set erg 0
    }
    if {$erg==1} {
        set erg [my metuKandidaton]
    }
    if {$erg==0 && $kunstrekoEbla} {
        set erg [my estasVorto [string map {- ""} $vorto]]
    }
    return $erg
}
Vortaro instproc fermuVortaron {} {
    # ne fermu
}
Vortaro instproc finaVortklaso {} {
    foreach z [my set zyklo] {
        switch $z {
            s {
                return i
            }
            e {
                return e
            }
            o {
                return o
            }
            a {
                return a
            }
        }
    }
    return
}
Vortaro instproc init {} {
    my array set statoj {
        start {{0 j j} {0 o o} {0 a a} {0 e e} {0 s s} {0 i i} {0 u u} {0 n n}}
        s {{0 i is} {0 a as} {0 o os} {0 u us}}
        i {{check i}}
        u {{check i}}
        is {{check i}}
        as {{check i}}
        os {{check i}}
        us {{check i}}
        n {{0 e en} {0 a a} {0 o o} {0 j j}}
        en {{check en}}
        e {{check e} {0 t t}}
        o {{check o} {0 t t}}
        a {{check a} {0 t t}}
        j {{0 a a} {0 o o}}
        t {{0 i it} {0 o ot} {0 a at} {0 n nt}}
        nt {{0 i it} {0 o ot} {0 a at}}
        it {{check i}}
        ot {{check i}}
        at {{check i}}
    }
    my sxarguRadikoj

    my set sufiksoj [lsort {aran istin anin ulin emul aĉ ad aĵ an ar ĉj ebl ec eg ej em end er estr et id ig iĝ il in onig onum ind ing ism ist nj uj ul um}]
    my set prefiksoj [lsort {bo ĉef dis ek eks ge mal mis pra re ne sen}]
    my initPrimitivajVortojn
    my sxarguIgnorvortoj
    my initOftajnRadikojn
}
Vortaro instproc initOftajnRadikojn {} {
    # 2200 plej oftaj radikoj de http://www.u-matthias.de/vortaro/eo_de.htm
    # listo ne enhavas pronomoj
    my instvar oftajRadikoj
    set oftajRadikoj {abdik abdomen abel abi abism abomen abon abrikot abund acer acid aĉet administr admir admon ador adres advokat aer afabl afer afiks afiŝ ag agl agnosk agr agrabl aĝ aides akcel akcept akcident akcipitr akir akompan akr aktor akuŝ akuz akv ali alt alud alumet am amar amas ambasad amel amik amor ampleks ampol amuz anas angil angl angul anĝel anim anonc ans anser aparten aper aplik apog apr aprob ar arakid arane aranĝ arb arbust ard are arest argil arĝent ark arm art artikol asekur asert asoci aspekt atak atend atent ating atut av avantaĝ avar avel aven aventur avert aviad avid azen babil bak bal bala balbut balen balot ban bank bant bapt barb barel baston bat batal baz beat beb bed bek bel ben bend benk ber best betul bezon bicikl bien bier bild bilet bird biskvit blank blek blind blok blov blu boac boat bol bon bord bot botel bov brak bran branĉ brand brankard brasik brav breĉ bred brems bret brid brik bril brod bros brov bru brul brun brust brut buĉ buf buk buked bul bulk bunt bus buter butik buton ced cel centr cep cerb cert cerv ceter cifer cigared cign cikoni cim cinam cindr cir cirkl cirk cirkonstanc cit civit ĉagren ĉambr ĉap ĉapel ĉapitr ĉarm ĉarpent ĉast ĉek ĉel ĉemiz ĉen ĉeriz ĉerk ĉerp ĉes ĉeval ĉifon ĉin ĉiz damaĝ danc danĝer dank dat dec decid dediĉ defend deĵor deklar dekliv dekstr demand dens dent pend desegn desert destin detal detru dev dezert dezir diabl dimanĉ difekt diferenc difin digest dik diligent dimanĉ dir direkt disk diskut distr distribu diven divers divid dogan doktor dolĉ dolor dom domaĝ don donac dorlot dorm dors dosier drat drink driv dron dub duk dung duŝ eben ebon ebri ebur eduk edz efektiv efik egal ekip ekologi ekonomi ekran ekscit ekskurs ekspozici eksterm ekzakt ekzamen ekzempl ekzempler ekzerc ekzist elekt elektr embaras emfaz energi enigm entrepren enu envi erar escept esenc eskal eskap esper esplor esprim est estim esting estr etaĝ etend etern etos event eventual evident evit evolu fabel facil faden fajf fajr fak fakt faktur fal falĉ fald fals fam famili fand fanfaron far farun fart fask favor febr federaci fek feliĉ femur fend fenestr fer feri fervor fest fianĉ fid fidel fier fik fiks fil film fin fingr firma fiŝ flag flak flam flank flar flat flav fleg flor flos flu flug foir foj fojn fok foli fon fond font fontan forges forĝ fork form formik forn fort fortik fos fot fotel frag frakas fram framb franc frand frap frat fraz fremd frenez freŝ frid frit fromaĝ frost frot fru frukt frunt fuĝ fulard fulm fum funebr funel fung funkci furioz fuŝ gaj gajn gam gamb gant gard gas gast gazet gej gem genu german gest giĉet gist glaci glad glan gland glas glat glav glir glit glob glu glut golf gorĝ graci grajn grand gras gratul grat grav graved gren grimp grinc griz gros gru grup gruz gurd gust gut gvid ĝangal ĝarden ĝem ĝen ĝeneral ĝentil ĝib ĝinz ĝir ĝoj ĝu ĝust hajl hak haladz halt hamak har hard hast hav haven heder heĝ hejm hejt hel helik help hepat herb hered herni hero hezit hirt hirud hirund histori hok hom honest honor hont hor horloĝ hotel humor humur hund ĥor ide ideal ignor iluzi imag imit impertinent implik impost impres indiferent indign indiĝen indik indulg industri infan infer inflam influ inform ink inklin insekt insign inspir instig instru insul insult inteligent intenc interes intern intest invit ir jak jar jug jugland juĝ juk jun jung jup jur just ĵaluz ĵet ĵurnal kaban kac kaĉ kadr kaduk kaf kaĝ kajer kajt kakt kal kaldron kalendar kalik kalkan kalkul kalson kalumni kalv kamarad kamomil kamp kamufl kan kanajl kancelier kancer kandel kankr kanot kant kap kapabl kapr kapreol kapric kapt karapac karb kard kares karn karot karp kart karton kas kased kaserol kastel kastor kaŝ kat katar katen kav kavern kaz kaze kel kelk kest kilogram kilometr kirl kis klab klar klas klav kler klient klin klopod klub knab kobaj kojn kok koks kol kolaps kolbas kolekt koler kolomb kolor kolz komb komenc komerc komfort komisi komitat kompar kompat kompil komplez kompren komput komun komunik koncern konciz kondiĉ konduk konduktor kondut konfid konfirm kongres kongru konk konker konkret konkurs konsci konsent konserv konsider konsist konsol konstant konstat konstituci konstru kontakt kontent kontrakt kontrol konven konversaci konvink kopi kor korb korespond korn korp kort kost kostum koton kov kovert kovr kraĉ krajon kre kred krem kren kresk kret krev kri kribr kroĉ krokodil kruc kruĉ kruel krur krut kub kudr kuir kuk kukum kukurb kuler kulmin kulp kultur kunikl kupe kupon kurac kuraĝ kurent kurioz kurs kurten kusen kuŝ kutim kuv kuz kvadrat kvalit kvant kverel kverk kviet kvitanc labor lac lacert laĉ lad lag lakt laktuk lamp lan land lang lanug latun lard larĝ larm las last lav lecion led legom leĝ leon lepor lern lert leter lez liber libr lig lign lim lingv lini lip list lit liter literatur liver lok long lu lud lukt lul lum lun lund lup lupol magazen magazin maj majstr makul makzel malt mam man manĝ manier manik mank mantel map mar marĉ mard mark marŝ martel mas mason mastr maŝin maten material matur mebl medi mel meleagr membr memor menci mend mensog menton menu merg merit merkred mesaĝ metal meti metod mez mezur miel mien migr miks mild milit minac minut mir mirakl mirtel mister mizer mod modern modest mok mol moment mon monaĥ monat mond mont montr mord mort mov muel muk mult mur murd murmur mus muskol musli muŝ mut muze muzik naci naĝ najl nan nap nask natur naz nebul neces neĝ nep nest nev nigr nivel nokt nom nombr nord normal not nov nub nud nuk nuks numer nun nutr obe objekt obsed observ obstakl obstin obtuz odor ofer ofert ofic oft okaz okcident okul okup ole ombr ombrel ond onkl opini oportun or ord ordinar ordon orel orf organiz orient original ort ost ov pac pacienc paf pag paĝ pag pajl pak pal palp palpebr pan pane pantalon pap paper papili par paraŝut pardon parenc park parker parol part paser pastr paŝ pat patr pec pejzaĝ pek pel pelv pen pend penik pent pentr pep perd pere perfekt period permes persekut persik person pet petol pez pian pic pice piĉ pied pigr piĵam pik pilk pin pingl pint pip pir pitoresk piz plac plaĉ plad plafon plan plank plant plat plekt plen plend plet plezur plor plug pluk plum pluv poem poent poet poezi polic politik polv pom pont popol popular pord pork port posed posten postul poŝ poŝt pot potenc pov praktik prav precip prefer preĝ preleg premi pren prepar pres pret pretend prez prezent prezid princip printemp print probabl problem produkt profesi profund program progres projekt proksim promen promes prononc propon propr protekt prov proverb proviz prudent prujn prun prunt pruv publik pub pug pugn pulm pulvor pun punkt pup pur puŝ put rabot rad radi radik rafan rajd rajt rakont ramp rand rang rapid raport rav raz redakt redaktor region regn regul reĝ reklam rekomend rekt rel religi ren renkont renvers reprezent respekt respond rest ret rev revu rezign rezist rezult ricev riĉ rid rifuz rigard rikolt rilat rimark rimed ring ripar ripet ripoz riproĉ river riz rob rok roman romp rond ronk ros rost roz rub rubrik rubus ruĝ rukt rul ruz sabat sabl sag sagac saĝ sak sal salajr saliv salon salt salut sam san sang sankt sap sat sav scen sci scienc sciur seg seĝ sek sekret sekretari seks sekur sekv sel sem semajn senc send sens sent serĉ seri serioz serpent serur serv sever sezon sibl sid sign signif silent silk simi simil simpl sincer sinjor sistem sitel situaci skal skatol skrap skrib sobr soci soif sol soldat solen solv somer son sonĝ sonor sorĉ sort sovaĝ spac spec special spegul spekt spert spez spic spir spirit sport staci stak stal star stat stel stir stok stomak strang strat streĉ strek stri strig stud student stult sud sufer sufiĉ suk sukces suker sun sup supoz supr surd surpriz suspekt svelt sven sving ŝaf ŝajn ŝal ŝanc ŝanĝ ŝarĝ ŝark ŝat ŝel ŝelk ŝerc ŝip ŝir ŝirm ŝlos ŝnur ŝov ŝovel ŝpar ŝrank ŝtat ŝtel ŝtof ŝton ŝtorm ŝtrump ŝtup ŝu ŝuld ŝveb ŝvel ŝvit tabl tabul tag tajp talp tank tapiŝ tas task te teatr ted tegment tegol teks tekst telefon teler televid tem temp tend tensi tent teori ter tern terur testud tig tili tim tir tol tomb tond tondr torent tortur trab tradici traduk traf trajn trajt trakt tranĉ trankvil trem trezor trik trink tritik tromp trov tru trud trunk tub tuk tur turism turist turment turn tus tuŝ tut universal universitat ung unu urb urĝ urs util uz vagon val valid valiz valor van vang vant vapor varb varm vast vek vel ven vend vendred venĝ venk vent ventr ver verd verk verŝ vesper vest veter vetur vezik viand vic vid vigl vilaĝ vin vintr viol violon vir viŝ vitr viv viz vizaĝ vizit voĉ voj vojaĝ vok vol volont volv vom vor vort vost vual vulp vund zon zorg zum}
    set oftajRadikoj [lsort $oftajRadikoj]
}
Vortaro instproc initPrimitivajVortojn {} {
    my instvar pronomoj tablovortoj
    set pronomoj [list]
    foreach p [Pronomo cxiojPronomoj] {
        if {[$p prenuTypo] eq "Numeralo"} continue
        lappend pronomoj [$p prenuRadiko]
        if {[$p prenuRadiko] in {mi ni vi li ŝi ĝi ni ili oni si}} {
            foreach suf {a an aj ajn n} {
                lappend pronomoj [$p prenuRadiko]$suf
            }
        }
    }
    set tabvortoj [list ki ti i ĉi neni]
    set postpartoj [list u uj ujn un o on ojn oj a an ajn aj es e en am al el om oma]
    foreach p $tabvortoj {
        foreach postparto $postpartoj {
            lappend pronomoj ${p}$postparto
            lappend tablovortoj ${p}$postparto
        }
    }
    # !!! special faritaj primitivaj vortoj
    # kiu no povis esti devenaj de radikoj

    # "unuj" estas dubinda, sed cxar Zamanhof mem tion uzis mi definis gxin
    lappend pronomoj malpli malplej samkiel elde ekde unuj unujn unun disde plimalpli malkiel
    ide::lremove pronomoj ĉiel
    ide::lremove pronomoj ĉar
    set pronomoj [lsort -unique $pronomoj]
    set tablovortoj [lsort -unique $tablovortoj]
}
Vortaro instproc konservuPrivatanDerivoDiskribo {radobj prefikso sufikso disk} {
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] metuDerivoAttr [list $prefikso] [list $sufikso] [list $disk]"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanDerivoForigon {radobj prefikso sufikso} {
    if {$radobj eq ""} return
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] foriguDerivo [list $prefikso] [list $sufikso]"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanDerivon {radobj prefikso sufikso} {
    if {$radobj eq ""} return
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] addDerivo [list $prefikso] [list $sufikso]"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanRadikon radobj {
    set f [my prenuPrivatanVortaron]
    puts $f "[$radobj info class] kreuRadiko $radobj"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanRadikonEstuKutimaRadiko radobj {
    if {$radobj eq ""} return
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] estuKutimaRadiko"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanRadikonEstuPropraNomo radobj {
    if {$radobj eq ""} return
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] estuPropraNomo"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc konservuPrivatanRadikonForigon radobj {
    if {$radobj eq ""} return
    set f [my prenuPrivatanVortaron]
    puts $f "\[Radiko pr [namespace tail $radobj]\] forigu"
    my malfermuPrivatanVortaron $f
}
Vortaro instproc malfermuPrivatanVortaron f {
    EsperantoConf statAktiono RS
    close $f
}
Vortaro instproc metuKandidaton {} {
    my instvar radiko prefikso sufikso pradiko kandidatoj vortktg
    set akzeptuPronomoj 0
    set erg 0
    foreach kandidato $kandidatoj {
        set pradiko [lindex $kandidato 1]
        set radiko [lindex $pradiko end]
        set radobj [Radiko prenuRad $radiko]
        if {!$akzeptuPronomoj && [Object isobject $radobj] && [$radobj istype Pronomo]} {
            set pradiko ""
            set radiko ""
            set erg 0
            continue
        }
        set prefikso [lindex $kandidato 0]
        set sufikso [lindex $kandidato 2]
        if {[lindex $kandidatoj 3] ne ""} {
            set vortktg [lindex $kandidato 3]
        }
        set erg 1
        break
    }
    set purkandidatoj [list]
    set redkand [list]
    # purigu kandidato listo de dubletoj
    foreach kandidato $kandidatoj {
        set tpradiko [lindex $kandidato 1]
        set tradiko [lindex $tpradiko end]
        set radobj Radiko::$tradiko
        if {!$akzeptuPronomoj && [Object isobject $radobj] && [$radobj istype Pronomo]} {
            continue
        }
        set rkandidato [lindex $kandidato 0][lrange $tpradiko 0 end-1]-[lindex $tpradiko end]-[lindex $kandidato 2]
        if {$rkandidato in $redkand} {
            break
        }
        lappend redkand $rkandidato
        lappend purkandidatoj $kandidato
    }
    set kandidatoj $purkandidatoj
    return $erg
}
Vortaro instproc preniEblajnSufiksojn {} {
    my instvar sufiksoj
    set asufiksoj [list o a e i]
    foreach s1 $sufiksoj {
        foreach s3 {o a e i} {
            lappend asufiksoj $s1$s3
        }
        foreach s2 $sufiksoj {
            if {$s1 ne $s2} {
                foreach s3 {o a e i} {
                    lappend asufiksoj $s1$s2$s3
                }
            }
        }
    }
    foreach i [Radiko info instances] {
        if {[$i exists derivoj]} {
            foreach der [$i set derivoj] {
                foreach sufikso [lindex $der 1] {
                    if {[catch {incr sufiksoj($sufikso)}]} {
                        set esufiksojArr($sufikso) 1
                    }
                }
            }
        }
    }
    set esufiksoj [array names esufiksojArr]
    set rezulto [list]
    foreach s $esufiksoj {
        if {$s in $asufiksoj} {
            lappend rezulto $s
        }
    }
    return $rezulto
}
Vortaro instproc prenuBazanFormon {} {
    my instvar prefikso radiko sufikso pradiko vortktg estasNumeralo
    if {$estasNumeralo} {
        # Ne funkcias cxe numeroj
        return 2
    }
    if {$pradiko ne ""} {
        return ${prefikso}[join $pradiko ""][join $sufikso ""]$vortktg
    } else {
        return ${prefikso}$radiko[join $sufikso ""]$vortktg
    }
}
@ Vortaro instproc prenuDerivoPropono {} {
description {Rezultas liston kun
prefikos radiko sufikso
La listo povas esti uzato per defini novan derivon}
}
Vortaro instproc prenuDerivoPropono {} {
    set pre [my set prefikso][join [lrange [my set pradiko] 0 end-1 ] ""]
    set rad [lindex [my set radiko] end]
    set suf [join [my set sufikso] ""][my set vortktg]
    list $pre $rad $suf
}
Vortaro instproc prenuFiksaMorfcxeno {} {
    my instvar prefikso radiko sufikso pradiko
    if {$pradiko ne ""} {
        list $prefikso[join [lrange $pradiko 0 end-1] ""] $radiko $sufikso [my prenuGramfinajxo]
    } else {
        list $prefikso $radiko $sufikso [my prenuGramfinajxo]
    }
}
@ Vortaro instproc prenuGramElemento {} {
description {fabrika metodo por krei la objekton de tipo GP::Elemento por sintaksa analizo}
}
Vortaro instproc prenuGramElemento {parent vorto} {
    my instvar vortktg radiko estasNumeralo
    if {[my estasPrimitivaVorto]} {
        return [my prenuPrimitivaGramElemento $parent $vorto]
    }
    set radobj [Radiko prenuRad $radiko]
    if {[$radobj istype Pronomo] && [$radobj prenuTypo] eq "Numeralo" && $vortktg eq ""} {
        set estasNumeralo 1
        my set veraNombro [GP::Numeralo leguKunligitaNombro [string tolower $vorto]]
    }
    if {$estasNumeralo} {
        return [my prenuNumeraloElemento $parent $vorto]
    }
    my instvar vortktg radiko
    set finajxo [lindex [my prenuGramfinajxo] end]
    if {[string first s $finajxo]>=0 || $finajxo eq "u"} {
        set typo i
    } else {
        set typo [string index $finajxo 0]
    }
    switch $typo {
        o {
            set obj [::GP::Substantivo new -childof $parent [list -vorto $vorto]]
            $obj ekkoniFinajxo $finajxo
        }
        a {
            set obj [::GP::Adjektivo new -childof $parent [list -vorto $vorto]]
            $obj ekkoniFinajxo $finajxo
        }
        e {
            set obj [::GP::Adverbo new -childof $parent [list -vorto $vorto]]
            $obj ekkoniFinajxo $finajxo
        }
        i {
            set obj [::GP::Verbo new -childof $parent [list -vorto $vorto]]
            $obj ekkoniFinajxo $finajxo
        }
        default {
            error "typo $typo ne rekonata"
        }
    }
    if {[my estasPartizipo]} {
        $obj mixin add ::GP::Partizipo
        $obj ekkoniTempo [lindex [my prenuGramfinajxo] 0]
    }
    $obj radiko $radobj
    if {[llength [my set derivolisto]]==0} {
        # nekonata derivo (gravas por automata tradukado)
        my instvar kandidatoj
        if {[llength $kandidatoj]>0} {
            set kandidato [lindex $kandidatoj 0]
            $obj derivolisto [list [lindex $kandidato 0][join [lrange [lindex $kandidato 1] 0 end-1] ""] [lindex $kandidato 2][lindex $kandidato 3]]
        } else {
            $obj derivolisto [list {} $vortktg]
        }
    } else {
        $obj derivolisto [my set derivolisto]
    }
    return $obj
}
Vortaro instproc prenuGramfinajxo {} {
    my instvar zyklo
    set ret [list]
    set akt ""
    foreach z $zyklo {
        if {$z eq "t"} {
            set ret $akt
            set akt ""
        }
        set akt "[string range $z 0 0]$akt"
    }
    concat $akt $ret
}
Vortaro instproc prenuLingvo {} {
    return eo
}
Vortaro instproc prenuLingvon {} {
    return eo
}
Vortaro instproc prenuMorfcxeno {} {
    my instvar prefikso radiko sufikso pradiko
    if {$pradiko ne ""} {
        concat $prefikso $pradiko $sufikso [my prenuGramfinajxo]
    } else {
        concat $prefikso $radiko $sufikso [my prenuGramfinajxo]
    }
}
Vortaro instproc prenuNumeraloElemento {parent tvorto} {
    my instvar vortktg radiko veraNombro
    set radobj [Radiko prenuRad $radiko]
    set obj [::GP::Numeralo new -childof $parent [list -vorto $tvorto] [list -radiko $radobj]]
    $obj set veraNombro $veraNombro
    set l1 [string range $tvorto end end]
    set l2 [string range $tvorto end-1 end]
    set l3 [string range $tvorto end-2 end]
    if {$l1 eq "o" || $l2 eq "on" || $l2 eq "oj" || $l3 eq "ojn"} {
        $obj estuSubstantiva
        $obj ekkoniFinajxo [lindex [my prenuGramfinajxo] end]
    } elseif {$l1 eq "a" || $l2 eq "an" || $l2 eq "aj" || $l3 eq "ajn"} {
        $obj estuAdjektiva
        $obj ekkoniFinajxo [my prenuGramfinajxo]
    } elseif {$l1 eq "e"} {
        $obj estuAdverba
    }
    $obj rekoni
    return $obj
}
Vortaro instproc prenuPrimitivaGramElemento {parent tvorto} {
    my instvar vortktg radiko tablovortoj veraNombro derivolisto
    set vorto [string tolower $tvorto]
    if {$vorto eq "unuj" || $vorto eq "unujn" || $vorto eq "unun"} {
        set obj [::GP::Substantivo new -childof $parent [list -vorto $tvorto] [list -radiko Radiko::unu]]
        set finajxo ""
        regexp {j?n?$} $vorto finajxo
        $obj ekkoniFinajxo $finajxo
        return $obj
    }

    set radobj [Radiko prenuRad $radiko]
    if {[Object isobject $radobj]} {
        if {[$radobj exists typNombro]} {
            set typNombro [$radobj typNombro]
            if {$typNombro>0} {
                set type [Pronomo nomoPorTypoNombro $typNombro]
                set obj [::GP::$type new -childof $parent [list -vorto $tvorto] [list -radiko $radobj]]
                if {$type eq "PersonPronomo"} {
                    $obj kazo nominativo
                    if {$vorto in {mi vi ŝi li ĝi si oni}} {
                        $obj nombro singularo
                    } else {
                        $obj nombro pluralo
                    }
                }
                if {$type eq "Numeralo"} {
                    $obj set veraNombro $veraNombro
                    #[GP::Numeralo leguKunligitaNombro $vorto]
                }
                if {[llength $derivolisto]>0} {
                    $obj derivolisto $derivolisto
                }
                return $obj
            }
        }
    }
    if {[lsearch -sorted $tablovortoj $vorto]>=0} {
        set rez [GP::TabloVorto new -childof $parent [list -vorto $tvorto]]
        $rez rekoni
        return $rez
    }
    set t $radiko
    set rad [my sxercxuKategorion $vorto]
    set radobj Radiko::$rad
    if {$vortktg ne "" && [Object isobject $radobj]} {
        if {[$radobj exists typNombro]} {
            set typNombro [$radobj typNombro]
            if {$typNombro>0} {
                set type [Pronomo nomoPorTypoNombro $typNombro]
                if {$type eq "PersonPronomo"} {
                    set finajxo [lindex [my prenuGramfinajxo] end]
                    if {[string first s $finajxo]>=0} {
                        set typo i
                    } else {
                        set typo [string index $finajxo 0]
                    }
                    if {$typo eq "a"} {
                        set type PosesivPronomo
                        set obj [::GP::$type new -childof $parent [list -vorto $tvorto]]
                        set finajxo [lindex [my prenuGramfinajxo] end]
                        $obj ekkoniFinajxo $finajxo
                        $obj radiko $radobj
                        return $obj
                    }
                }
            }
        }
    }
    set radiko $t
    # personal pronomo akuzativo ?
    if {[string range $vorto end-1 end] eq "in"} {
        set pronomo [string range $vorto 0 end-1]
        set radobj Radiko::$pronomo
        if {[$radobj exists typNombro]} {
            set typNombro [$radobj typNombro]
            if {$typNombro>0} {
                set type [Pronomo nomoPorTypoNombro $typNombro]
                if {$type eq "PersonPronomo"} {
                    set type PersonPronomo
                    set obj [::GP::$type new -childof $parent [list -vorto $tvorto]]
                    $obj kazo akuzativo
                    if {$pronomo in {mi vi ŝi li ĝi si oni}} {
                        $obj nombro singularo
                    } else {
                        $obj nombro pluralo
                    }
                    $obj radiko $radobj
                    return $obj
                }
            }
        }
    }
    switch $vorto {
        malpli {
            set type PrimitivaAdverbo
            set derivolisto {mal {}}
            set radiko pli
        }
        malplej {
            set type PrimitivaAdverbo
            set derivolisto {mal {}}
            set radiko plej
        }
        elde {
            set type Prepozicio
            set derivolisto {el {}}
            set radiko de
        }
        ekde {
            set type Prepozicio
            set derivolisto {ek {}}
            set radiko de
        }
        disde {
            set type Prepozicio
            set derivolisto {dis {}}
            set radiko de
        }
        samkiel {
            set type PrimitivaAdverbo
            set derivolisto {{} kiel}
            set radiko sam
        }
        pli-malpli -
        plimalpli {
            set type PrimitivaAdverbo
            set derivolisto {plimal {}}
            set radiko pli
        }
        default {
            return [::GP::PrimitivaElemento new -childof $parent [list -vorto $tvorto]]
        }
    }
    set radobj Radiko::$radiko
    return [::GP::$type new -childof $parent [list -vorto $tvorto] [list -radiko $radobj] [list -derivolisto $derivolisto]]
}
Vortaro instproc prenuPrivatanVortaron {} {
    set file [Vortaro privatajRadikojDosiero]
    set f [open $file a]
    fconfigure $f -encoding utf-8
    if {![my exists estasUzita]} {
        global env
        if {[info exists env(USER)]} {
            set user $env(USER)
        } elseif {[info exists env(USERNAME)]} {
            set user $env(USERNAME)
        } else {
            set user ""
        }
        puts $f "# [clock format [clock seconds]] $user"
        my set estasUzita 1
    }
    return $f
}
Vortaro instproc prenuTipoNomo tipo {
    array set tipoj {o substantivo a adjektivo e adverbo i verbo pp prepozicio n numeralo p pronomo pos posesivpronomo t tablovorto ? nekonata kon konjunkcio int interjekcio ono onomatopeo sbj subjunkcio def definilo}
    return $tipoj($tipo)
}
Vortaro instproc prenuTipoPorVorto vorto {
    my instvar radiko tablovortoj vortktg
    if {[my estasVorteto $vorto]} {
        array set tipoArr {Nekonata ? Konjunkcio kon Interjekcio int Numeralo num Onomatopeo ono Prepozicio p Subjunkcio sbj PersonPronomo pp PosesivPronomo pos PrimitivaAdjektivo a PrimitivaAdverbo e Difinilo def}
        my estasVorto $vorto
        set radobj [Radiko prenuRad $radiko]
        if {[Object isobject $radobj]} {
            if {[$radobj exists typNombro]} {
                set typNombro [$radobj typNombro]
                if {$typNombro>0} {
                    set type [Pronomo nomoPorTypoNombro $typNombro]
                    return $tipoArr($type)
                }
            }
        } else {
            array set sArr {malpli PrimitivaAdverbo malplej PrimitivaAdverbo elde Prepozicio ekde Prepozicio disde Prepozicio samkiel PrimitivaAdverbo pli-malpli PrimitivaAdverbo plimalpli PrimitivaAdverbo}
            if {[info exists sArr($vorto)]} {
                return $tipoArr($sArr($vorto))
            }
        }
        
        if {$vorto in $tablovortoj} {
            return t
        }
        set rad [my sxercxuKategorion $vorto]
        set radobj [Radiko prenuRad $rad]
        if {$vortktg ne "" && [Object isobject $radobj]} {
            if {[$radobj exists typNombro]} {
                set typNombro [$radobj typNombro]
                if {$typNombro>0} {
                    set type [Pronomo nomoPorTypoNombro $typNombro]
                    if {$type eq "PersonPronomo"} {
                        set finajxo [lindex [my prenuGramfinajxo] end]
                        if {[string first s $finajxo]>=0} {
                            set typo i
                        } else {
                            set typo [string index $finajxo 0]
                        }
                        if {$typo eq "a"} {
                            return pos
                        }
                        return pp
                    }
                }
            }
        }
        return ?
    }
    string index [EORadikilo radikigi $vorto] end
}
@ Vortaro instproc prenuVortfarado {} {
description {rezultas la liston kun
prefikso radikojlisto sufikso vortkategorio

ekzemploj:

bona - {} bon {} a
senutila - {} {sen util} {} a
malfermi - mal ferm {} i
}
}
Vortaro instproc prenuVortfarado {} {
    my instvar prefikso radiko sufikso pradiko vortktg
    if {$pradiko ne ""} {
        list $prefikso $pradiko $sufikso $vortktg
    } else {
        list $prefikso $radiko $sufikso $vortktg
    }
}
Vortaro instproc sxarguIgnorvortoj {} {
    my instvar ignorVortoj
    set ignorVortoj [lsort -unique [IgnorvortoListo prenuListoPorLingvo eo]]
}
Vortaro instproc sxarguRadikoj {} {
    set file [Vortaro radikojDosiero]
    if {![file exists $file]} {
        EsperantoBrowser message [mc "Vortolisto de radikoj '%s' ne estis trovita!" $file]
        return
    }
    RadikoKonservadoMix malsxaltuPrivatanKonservadon

    namespace eval :: [list source $file]
    set file [Vortaro privatajRadikojDosiero]
    if {[file exists $file]} {
        if {[catch {namespace eval :: [list source $file]} mes]} {
            puts $::errorInfo
            IDE::Dialog error [mc "Eraro ĉe ŝarĝo de privata vortaro: %s" $mes]
        }
    }
    RadikoKonservadoMix sxaltuPrivatanKonservadon

}
Vortaro instproc sxercxiPartizipaVortparto vortparto {
    my instvar sufiksoj
    set radlen [string length $vortparto]
    set vortpartosuf [list int ont ant it ot at en]
    foreach s $vortpartosuf {
        if {[string length $s]>$radlen} continue
	if {[string last $s $vortparto]==$radlen-[string length $s]} {
            return [list [string range $vortparto 0 end-[string length $s]] $s]
        }
    }
    return
}
Vortaro instproc sxercxiPrefikso radiko {
    my instvar prefiksoj prefikso
    set prefikso ""
    set radobj ""
    foreach p $prefiksoj {
        if {[string range $radiko 0 [expr {[string length $p]-1}]] eq $p} {
            set prefikso $p
            return [string range $radiko [string length $p] end]
        }
    }
    return
}
Vortaro instproc sxercxiSufiksojn radiko {
    my instvar sufiksoj
    set radlen [string length $radiko]
    set rets [list]
    foreach s $sufiksoj {
        if {[string length $s]>$radlen} continue
	if {[string last $s $radiko]==$radlen-[string length $s]} {
            lappend rets [string range $radiko 0 end-[string length $s]] $s
        }
    }
    return $rets
}
@ Vortaro instproc sxercxiSufikson {} {
description {Sxercxas sufikson por vortparto
Ekzemple:
naskigx urbo - igx
duon nuda - on
kovril pago - il
}
}
Vortaro instproc sxercxiSufikson radiko {
    my instvar sufiksoj sufikso
    set radlen [string length $radiko]
    foreach s $sufiksoj {
        if {[string length $s]>$radlen} continue       
	if {[string last $s $radiko]==$radlen-[string length $s]} {
            set sufikso [linsert $sufikso 0 $s]
            return [string range $radiko 0 end-[string length $s]]
        }
    }
    return
}
Vortaro instproc sxercxiSufiksonVortparto {vortparto preradiko} {
    my instvar sufiksoj
    set radlen [string length $vortparto]
    set vortpartosuf [list aĉ ad aĵ an ar ĉj ebl ec eg ej em end er estr et id ig iĝ il in ind ing ism ist nj obl on onig op uj ul um istino anino ulino int ont ant it ot at a o e en]
    # cxu inter konata prefikso kaj novavortparto ne estis enmetita o a e
    # vortparto -> vort-o-parto [list vort o]
    foreach s {o a e o- a- e-} {
        foreach p [$preradiko prenuPrefiksoj] {
            set rs $s$p
            if {[string length $rs]>$radlen} continue
            if {[string last $rs $vortparto]==$radlen-[string length $rs]} {
                return [list [string range $vortparto 0 end-[string length $rs]] $rs]
            }
        }
    }
    # aldono vortpartosufikso al konata derivo
    # vortparto -> vortadparto -> [list vort ad]
    foreach s [concat $vortpartosuf [$preradiko prenuPrefiksoj]]  {
        if {[string length $s]>$radlen} continue
	if {[string last $s $vortparto]==$radlen-[string length $s]} {
            return [list [string range $vortparto 0 end-[string length $s]] $s]
        }
    }
    return
}
Vortaro instproc sxercxuErarojDerivajxoj {} {
    set a ""
    foreach r [Radiko chiojRadikoj] {
        foreach d [$r prenuDerivoj] {
            if {[my estasVorto $d]!=2} {
                append a "[$r prenuRadiko] $d \n"
            }
        }
    }
    return $a
}
Vortaro instproc sxercxuKategorion {vorto {testuRadiko 1}} {
    set stato start
    my instvar statoj radiko zyklo vortktg
    set radiko $vorto
    set radobj ""
    set zyklo [list]
    set estasradiko 0
    set vortktg ""
    set checkedRadiko $radiko
    set checkedZyklo $zyklo
    while 1 {
        set prog $statoj($stato)
        set erg end
        set radobj ""
        foreach komandoPriskribo $prog {
            set komando [lindex $komandoPriskribo 0]
            if {$komando eq "check"} {
                set radobj [Radiko prenuRad $radiko]
                set checkedRadiko $radiko
                set checkedZyklo $zyklo
                set vortktg [lindex $komandoPriskribo 1]
                if {[Object isobject $radobj] && $testuRadiko} {
                    set erg end
                    set estasradiko 1
                    break
                } else {
                    set radobj ""
                }
            } else {
                set parto [string index $radiko end]
                if {$parto eq [lindex $komandoPriskribo 1]} {
                    set stato [lindex $komandoPriskribo 2]
                    lappend zyklo $stato
                    set erg next
                    set radiko [string range $radiko 0 end-1]
                    break
                }
            }
        }
        if {$erg eq "end"} {
            break
        }
    }
    set radiko $checkedRadiko
    set zyklo $checkedZyklo
    return $checkedRadiko

}
Vortaro instproc testuNumeralo vorto {
    if {![catch {GP::Numeralo leguKunligitaNombro $vorto} veraNombro]} {
        my set veraNombro $veraNombro
        if {$vorto eq "unu"} {
            my set radiko unu
        } else {
            my set radiko du
        }
        my set estasNumeralo 1
        return 1
    }
    return 0
}
@ Vortaro instproc testuVortfarado {} {
description {metodu partigas vorton je silaboj
kaj ŝerĉas vortradikoj en la vorto}
}
Vortaro instproc testuVortfarado {radkandidato vorto pre suf} {
    my instvar radiko sufiksoj derivolisto kandidatoj vortktg pronomoj
    set estasradiko 0
    #set silaboj [::esp::silaboj $radkandidato]
    if {[set i [string first - $radkandidato]]<0} {
        # se - tiam nur en pozicio de streko
        set i [expr {[string length $radkandidato]-2}]
    } else {
        # streko ne estas en radiko sed en prefikso
        incr i
    }
    # sekvaj radikoj ne povas esti uzataj kiel morfemoj
    # uzu sort
    set maleblajPreradikoj {ili la li mi ni si ŝi}

    while {$i>1} {
        set parto [string range $radkandidato $i end]
        # testu cxu la parto povas estas subradiko
        if {($parto ni $sufiksoj && $parto ni $pronomoj && $parto ni {on obl op}) || $parto in {ebl ul estr min} || $vorto in {kapjesi ĝisnuna ununura kelkoble kelkobla multoble multobla multoble multobliĝi multobligo multope multobliga senpera senpere multobligi antaŭhieraŭ postmorgaŭ kapantaŭe dorsantaŭa dorsantaŭe kaponantaŭe alantaŭ deantaŭ elantaŭ ĝistiama ĝisnune ununure nurnure nurnura pluroble plurobliĝi plurobla pluropa plurope}} {
            set radobj [Radiko prenuRad $parto]
            if {[Object isobject $radobj] && $parto ne "slot"} {
                if {[llength [set derivolisto [$radobj sxercxuDerivon $vorto]]]>0} {
                    set radiko [$radobj prenuRadiko]
                    set fradiko [string range $radkandidato 0 [expr {$i-1}]]
                    my set pradiko [list $fradiko $radiko]
                    my set derivo $vorto
                    return 2
                } else {
                    set fradiko [string range $radkandidato 0 [expr {$i-1}]]
                    set fradobj [Radiko prenuRad $fradiko]
                    if {[Object isobject $fradobj]} {
                        my set pradiko [list $fradiko $parto]
                        if {[llength [set derivolisto [$radobj sxercxuDerivon $vorto]]]>0} {
                            my set derivo $vorto
                            set radiko $fradiko
                            return 2
                        } else {
                            if {[lsearch -exact -sorted $maleblajPreradikoj $fradiko]>=0} {
                                incr i -1
                                continue
                            }
                            set estasradiko 1
                            lappend kandidatoj [list $pre [list $fradiko $parto] $suf $vortktg]
                        }
                    } elseif {[llength [set vpsuf [my sxercxiSufiksonVortparto $fradiko $radobj]]]>0} {
                        set fradiko [lindex $vpsuf 0]
                        set fradobj [Radiko prenuRad $fradiko]
                        if {[Object isobject $fradobj]} {
                            set estasradiko 1
                            # konservi ankaux "o" en listo
                            # tio povas malhelpi cxar pradiko listo
                            # ne enhavas nur purajn radikojn
                            if {[llength [set derivolisto [$radobj sxercxuDerivon $vorto]]]>0} {
                                my set derivo $vorto
                                set radiko $fradiko
                                return 2
                            } else {
                                if {[lsearch -sorted $maleblajPreradikoj $fradiko]>=0} {
                                    incr i -1
                                    set estasradiko 0
                                    continue
                                }
                                lappend kandidatoj [list $pre [list [lindex $vpsuf 0][lindex $vpsuf 1] $parto] $suf $vortktg]
                            }
                        }
                    }

                }
            }
        }
        incr i -1
        if {[string first - $radkandidato]>0} {
            break
        }
    }
    return $estasradiko
}
@ Vortaro proc estasMallongigo {} {
description {testas mallongigxoj kun punktoj (ekz. ktp. pg. tn.)
rezultas la plenan formon aux neniu}
}
Vortaro proc estasMallongigo vorto {
    my instvar mallonArr
    if {[string length $vorto]==1 && [string is upper $vorto]} {
        return $vorto
    }
    if {![array exists mallonArr]} {
        array set mallongArr {
            ktp {kaj tiel plu}
            p  {paĝo}
            ekz {ekzemple}
            k {kaj}
            jan {januaro}
            feb {februaro}
            mar {marto}
            apr {aprilo}
            jun {junio}
            jul {julio}
            aŭg {aŭgusto}
            sep {septembro}
            okt {oktobro}
            nov {novembro}
            dec {decembro}
            pĝ {paĝo}
            tn {tiel nomata}
            t.n {tiel nomata}
            ĉ  ĉirka
            ia interalie
            i.a interalie
            vd  vidu
            k.a {kaj aliaj}
            te {tio estas}
            t.e {tio estas}
            inkl {inkluzive}
            anst anstataŭ
            resp respektive
            tel telefonnumero
            j jaro
            jc jarcento
            bv bonvolu
            a.K {antaŭ Kristo}
            p.K {post Kristo}
            prof {profesoro}
            dok {doktoro}
        }
    }
    if {[info exists mallongArr($vorto)]} {
        return $mallongArr($vorto)
    }
    return
}
Vortaro proc estasViraNomo vorto {
    expr {[lsearch -exact -sorted {abrahamo adamo adolfo adriano agrikolo ajakso alberto alcestiso aleksandro aleksio alfonso alfredo alio alkajo alonzo amadeo ambrozio anatolo andreo anselmo antonio antono anĝelo apolono aristido aristofano aristoto armando arnoldo arturo arĥimedo atilo aŭgusteno aŭgusto aŭrelio baldueno baltazaro baptisto barnabo bartolomeo baruĥo bastiano bazilo baĥo benedikto benito benjameno bernardo bertrando blazio bonaparto bonifaco boriso boromeo bruno celestino cezaro cicerono cinno cipriano cirilo ciro dagoberto damiano damoklo danielo dario davido demetrio demokrito denizo dimitro diodoro diogeno diomedo dionizio diono djego domiciano dominiko donaldo edgaro edmundo eduardo efraimo eliezero elija elio emanuelo emeriko emilio emilo epikteto erasmo eriko ernesto eŭgeno eŭripido eŭstaĥo fabiano fabio fabricio falko farnezo faŭsto felikso ferdinando fernando filipo filokteto filono firmiano flaminio flavio floriano francisko franko frederiko gabrielo galbo gasparo gastono gedeono georgo gerardo gilberto godfredo gontrano gonzago gregorio gustavo hanibalo haroldo hasdrubalo hektoro henriko herberto hermano herodo herodoto heziodo hipokrato hirkano homero horacio huberto hugo ignaco inocento iono isaako ismailo ivano ivo izokrato jakobo jazono jeremio jesaja jesuo jiŝajo joakimo joelo johano jona jonatano josuo jozefo judaso juliano justeno justiniano juvenalo kaino kajafas kajo kalimaĥo kamilo kandido karlo karolo kasio katono katulo kazimiro klaŭdio kleanto klemento kleono klitemnestro klodovaldo klodvigo klotaro knuto kolomano konrado konstanteno koraĥo kornelio krasso kreono kreŭzo kristiano kristofo kristoforo krizipo ksantipino ksantipo ksavero ksenofono kserkso ladislao laerto lajo lamberto lanceloto lazaro laŭranto laŭro leandro leo leonardo leono leopoldo livio lotario lubomiro luciano ludoviko luk maksimiliano maksimo makso manfredo manuelo marcelo mario marko marteno mateo matiaso maŭrico meleagro melkioro menandro merkurio merovo metodo mirko mirto mitridato miĥaelo mohamedo moseo napoleono natano nerono nestoro nikodemo nikolao noa nomoj numo oktavo olafo olivero omaro oskaro osvaldo ovidio palaso patriko patroklo paŭlo periklo petro pilado pio placido plinio pompeo prospero ptolemeo rafaelo rajmondo raulo regulo rejnaldo renardo renato rikardo rinaldo roberto rodrigo rolando rolfo romano romeo romeo romulo ronaldo roĝero rudolfo salomono salvatoro samuelo sanĉo scipiono sebastiano setho sigfrido sigismundo siksto silvano silvestro simeono simono solimano sozio stanislaso stefano tadeo teodoro teodozio teofilo terencio tiberio ticiano timoteo tobio tomaso tomo uliso ulrika ulriko umberto vaclavo valdemaro valenteno valerio valtero venceslao viktoro vilhelmo vincento virgilo virinaj vito vladimiro volfgango votano zaĥario zenono zmitro ĝeraldo ĝermano ĝofredo ĥiramo ĵafaro ĵaspero ĵeromo} $vorto]>=0}
}
Vortaro proc estasVirinaNomo vorto {
    expr {[lsearch -exact -sorted {abigaela ada adela adelajda adriana agata alberta aleksandra alica amalio anabela anastazia andrea anita anna anĝela anĝelika arabela ariana aspazia aŭgusta aŭgustena aŭrora barbara beatrica benedikta benita berenica berta betia bianka brigita celestina dafnea daniela danuta debora dejanira deniza diana dominika dora dorotea eleonora eliza elizabeta elvira elza emilia emma erika estera eva evelina fatima filomena flora franciska freja frida gabriela gaja gerda gertruda greta grizelda halina hedviĝa hekata helena heloiza henrieta hermlina hersenta hilda ida ilona ina irena irina irisa iza izabela izidora izolda jadviga jaklino jana johana jolanda jozefa judita julia julieta kamila kansandra karena karla karmena karola karolina katia katrina klanja klara klemantina kleopatra klia klitandra klotilda konstancia kornelia kristina lamberta larisa laŭra laŭranca lea leda lidia linda liza lizistrata lolita loreta lubomira lucia lucilia ludovika luiza magda maja malina manuela margareta margarita maria mariana mariana marieta marika marina marlena marta matilda melania mina mira mirjama miĥaela mona monika naama nadja nastazja nataŝa nikola nikoleta nina nora oksana olga paŭla paŭleta paŭlina penelopa perdita petra rafaela raisa ramona raĥel rebeka regina renata rita roksana roza rozalia ruta sabina sandra sara silvana sofia sonia suzana tais talia tamara tanja tatjana teodora tereza tina valpurga vanesa verena veronika viktoria vilhelmina vilma viola ĉarlota ĥimena} $vorto]>=0}
}
Vortaro proc prenuVortaron {} {
    if {![Object isobject ::espvortaro]} {
        Vortaro create ::espvortaro
    }
    return ::espvortaro
}
Vortaro proc privatajRadikojDosiero {} {
    file join [EsperantoConf prefEspDosierujo] radikoj.txt
}
Vortaro proc radikojDosiero {} {
    file join [EsperantoConf prenuFontoDosierujon] radikoj.xotcl
}
Vortaro proc trovuProblemajDerivojn {} {
    set vorto [my prenuVortaron]
    set ret [list]
    foreach i [Radiko chiojRadikoj] {
        foreach v [$i prenuDerivoj] {
            if {[$vorto estasVorto $v]!=2} {
                lappend ret $v
            }
        }
    }
    join $ret \n
}
Class VortfaradoAstoMix
@ ::VortfaradoAstoMix idemeta component EspSintaksaAnalizo
VortfaradoAstoMix instproc prenuAntauxElemento {} {
    my instvar parenco originaElemento
    set id [lsearch [$parenco set astoj] [self]]
    if {$id == -1} {
        set id [lsearch [$parenco set astoj] $originaElemento]
    }
    if {$id>0} {
        set aid [expr {$id-1}]
        [lindex [$parenco set astoj] $aid] prenuLastan
    } elseif {$id==0} {
        $parenco prenuAntauxElemento
    } elseif {$id<0} {
        error "malsana arba strukturo"
    }
}
Object AuxtomatoPrilaboro
@ ::AuxtomatoPrilaboro idemeta categoriesMethodsProcs {{konvertuEspBlogo dumpEspBlog konvertuEspBlogojn konvertuUnuBlogon refreshEspBlogojn}}
@ ::AuxtomatoPrilaboro idemeta categoriesProcs blogo-tradukado
@ ::AuxtomatoPrilaboro idemeta component EspSintaksaAnalizo
AuxtomatoPrilaboro proc dumpEspBlog {{nr 1} {gxis {}}} {
    set outdir [file join [Esperantilozentro prenuFontoDosieron] espblog]
    package require http
    if {[EsperantoConf set httpProxy] ne ""} {
        http::config -proxyhost [EsperantoConf set httpProxy] -proxyport [EsperantoConf set httpProxyPort]
    }

    encoding system utf-8

    if {![file isdirectory $outdir]} {
        file mkdir $outdir
        puts "mkdir $outdir"
    }

    set i 0
    while 1 {
        set start http://blog.esperantilo.org/?p=$nr
        puts "reciving $start"
        set id [http::geturl $start]
        set data [http::data $id]
        http::cleanup $id
        regsub {<div id="footer">.+?</div>} $data {} data
        regsub {<div id="answerdiv">.+?</div>} $data {} data

        set fileName [file join $outdir blogesp$nr.html]
        if {[file isfile $fileName] && [iloj::leguTekstoDeDosiero $fileName] eq $data} {
            puts "keine aenderung in $fileName"
        } else {
            set f [open $fileName w]
            #fconfigure $f -encoding binary -eofchar {}
            puts -nonewline $f $data
            close $f
        }
        incr i
        #if {$i>1} break
        if {![regexp {<div class=\"alignright\"><a href="http://blog\.esperantilo\.org/\?p=(\d+)} $data _ nr]} break
        if {$gxis ne "" && $nr>$gxis} {
            break
        }
    }
}
AuxtomatoPrilaboro proc importuTansitavajVerboj {{file {}}} {
    if {$file eq ""} {
        set file [::IDE::Dialog getOpenFile]
        if {$file eq ""} return
    }
    set f [open $file r]
    set vortaro [Vortaro prenuVortaron]
    while {[gets $f linio]!=-1} {
        foreach vorto [split $linio ",."] {
            set vorto [string trim $vorto]
            if {$vorto eq ""} continue
            if {[$vortaro estasVorto $vorto]==2} {
                foreach {pre rad suf} [$vortaro prenuDerivoPropono] {}
                set radobj [Radiko pr $rad]
                if {$radobj ne ""} {
                    set d [$radobj sxercxuDerivonPS $pre $suf]
                    set gd [lindex $d 2]
                    if {[lsearch -exact $d trans]<0} {
                        puts "verbo $vorto estas transitiva"
                        $radobj metuDerivoAttr $pre $suf [concat $gd trans]
                    } else {
                        puts "traniviteco estas konata $vorto"
                    }
                } else {
                    puts "radobj ne trovita $pre $rad $suf"
                }
            } else {
                puts "ne konata: $vorto"
            }
        }
    }
    close $f
}
AuxtomatoPrilaboro proc konvertuEspBlogo {template dosiero tdir} {
    set linkpref "index.html"
    set linknext "index.html"
    set teksto [iloj::leguTekstoDeDosiero $dosiero]
    if {[regexp {<div class="entry">(.+?)</div>} $teksto _ blogteksto]} {
        regsub {<p class="postmetadata alt">.+} $blogteksto {} blogteksto
        regexp {<a href="http://blog.esperantilo.org/\?p=(\d+)" .+? title="Permanent Link: ([^"]+?)">} $teksto _ onumber titolo
        regsub -all {& # } $titolo {\&#} titolo
        set titolotrad [TekstoTradukilo tradukuTekston $titolo]
        regsub -all {& # } $titolotrad {\&#} titolotrad
        set ourl "http://blog.esperantilo.org/?p=$onumber"
        if {[regexp {alignleft">&laquo; <a href="http://blog.esperantilo.org/\?p=(\d+)"} $teksto _ prefnumber]} {
            set linkpref blogesp$prefnumber.html
        }
        if {[regexp {alignright"><a href="http://blog.esperantilo.org/\?p=(\d+)"} $teksto _ nextnumber]} {
            set linknext blogesp$nextnumber.html
        }

        set frazolegilo [HTMLFrazoLegilo new]
        $frazolegilo signoLegilo [TekstoKursoro new -childof $frazolegilo [list -teksto $blogteksto]]
        set tradukilo [TekstoTradukilo new [list -frazoLegilo $frazolegilo]]
        set rez [$tradukilo traduku]
        set traduko [$tradukilo rezultoTeksto]
        set dnomo [file join $tdir [file tail $dosiero]]
        set f [open $dnomo w]
        fconfigure $f -encoding utf-8
        puts $f [string map [list %orginalink% $ourl %titolo% $titolo %titolotraduko% $titolotrad %fonto% $blogteksto %traduko% $traduko %linkpref% $linkpref %linknext% $linknext] $template]
        close $f
        $tradukilo destroy
        $frazolegilo destroy
        return [list [file tail $dosiero] $titolo $titolotrad]
   }
   return
}
AuxtomatoPrilaboro proc konvertuEspBlogojn {} {
    set dir [file join [Esperantilozentro prenuFontoDosieron] espblog]
    #set tdir [file join $dir pl]
    set tdir /home/joachim/public_html/esperantoedit/blogpl
    set template [iloj::leguTekstoDeDosiero [file join $tdir temp.html]]
    set titolo "Titolo"
    set i 0
    set indekso [list]
    set dj [list]
    foreach d [glob -directory $dir *.html] {
        regexp {blogesp([\d]+).html} $d _ number
        lappend dj [list $number $d]
    }
    set progreso [ProgresoMontrilo startProgress {Traduko de blogo}]
    foreach d [lsort -index 0 -integer $dj] {
        update
        puts $d
        $progreso setProgress [expr {round(100.0*$i/[llength $dj])}]
        if {[$progreso isStopped]} {
            break
        }
        set d [lindex $d 1]
        eval lappend indekso [my konvertuEspBlogo $template $d $tdir]
        incr i
    }
    set indeksohtml ""
    foreach {page titolo titolotrad} $indekso {
        append indeksohtml "<li><a href=\"$page\">$titolotrad - $titolo</a></li>\n"
    }
    set template [iloj::leguTekstoDeDosiero [file join $tdir tempindex.html]]
    set dnomo [file join $tdir index.html]
    set f [open $dnomo w]
    fconfigure $f -encoding utf-8
    puts $f [string map [list %indekso% $indeksohtml] $template]
    close $f
    $progreso cleanUpAfterSignal
    $progreso destroy
}
AuxtomatoPrilaboro proc konvertuUnuBlogon {} {
    set dir [file join [Esperantilozentro prenuFontoDosieron] espblog]
    #set tdir [file join $dir pl]
    set tdir /home/joachim/public_html/esperantoedit/blogpl
    set template [iloj::leguTekstoDeDosiero [file join $tdir temp.html]]
    my konvertuEspBlogo $template [file join $dir blogesp11.html] $tdir

}
AuxtomatoPrilaboro proc refreshEspBlogojn {} {
    set dir [file join [Esperantilozentro prenuFontoDosieron] espblog]
    #set tdir [file join $dir pl]
    set tdir /home/joachim/public_html/esperantoedit/blogpl
    set template [iloj::leguTekstoDeDosiero [file join $tdir temp.html]]
    set titolo "Titolo"
    set i 0
    set indekso [list]
    set dj [list]
    set timeLimit [expr {[clock seconds]-24*60*60}]
    EsperantoConf set lingvo pl
    
    foreach d [glob -directory $dir *.html] {
        regexp {blogesp([\d]+).html} $d _ number
        file stat $d statArr
        if {$statArr(mtime)<$timeLimit} {
            continue
        }
        lappend dj [list $number $d]
    }
    
    set progreso [ProgresoMontrilo startProgress {Traduko de blogo}]
    foreach d [lsort -index 0 -integer $dj] {
        update
        $progreso setProgress [expr {round(100.0*$i/[llength $dj])}]
        if {[$progreso isStopped]} {
            break
        }
        set file [lindex $d 1]
        puts $file
        if {[file exists [file join $tdir [file tail $d]]]} {
            set nova 0
        } else {
            set nova 1
        }
        puts "traduku $file"
        set ret [my konvertuEspBlogo $template $file $tdir]
        if {$nova} {
            eval lappend indekso $ret
        }
        incr i
    }
    if {[llength $indekso]>0} {
        set indeksohtml ""
        foreach {page titolo titolotrad} $indekso {
            append indeksohtml "<li><a href=\"$page\">$titolotrad - $titolo</a></li>\n"
        }
        set dnomo [file join $tdir index.html]
        set indekso [iloj::leguTekstoDeDosiero $dnomo]
        regsub {</ol>} $indekso $indeksohtml</ol> indekso
        set f [open $dnomo w]
        fconfigure $f -encoding utf-8
        puts $f $indekso
        close $f
    }
    $progreso cleanUpAfterSignal
    $progreso destroy
    
}
AuxtomatoPrilaboro proc trovuALitero {vorto1 vorto2} {
    foreach c1 [split $vorto1 ""] c2 [split $vorto2 ""] {
        if {$c1 ne $c2} {
            return [join [lsort [list $c1 $c2]] ""]
        }
    }
    return
}
AuxtomatoPrilaboro proc trovuEspSinonimojDeRevo {} {
    set bazo [REVOdatabazo prenuBazon]
    set ret ""
    scan h %c komenco
    scan z %c fino
    for {set i $komenco} {$i<=$fino} {incr i} {
        set litero [format %c $i]
        set vortoj [$bazo prenuDerivojDeMustero "${litero}*"]
        foreach vorto $vortoj {
            foreach elem [lindex [$bazo trovuSencojn $vorto] 0] {
                foreach {dif uzo} $elem {}
                set rez ""
                if {$uzo eq "FIG"} {
                    continue
                }
                foreach {teksto tag} $dif {
                    if {$tag eq ""} {
                        append rez $teksto
                    } elseif {[lindex $tag 0 0] eq "ref"} {
                        append rez $teksto
                    }
                }
                set rez [string tolower [string trim $rez ".:= "]]
                if {$rez eq ""} continue
                catch {
                    if {[llength $rez]<=2} {
                        if {[set sep [string first , $rez]]>0} {
                            foreach rez [split $rez ,] {
                                set rez [string trim $rez]
                                append ret "$vorto : $rez\n"
                            }
                        } else {
                            append ret "$vorto : $rez\n"
                        }
                    }
                }
            }
        }
    }
    EsperantoBrowser redaktoTekston $ret
}
AuxtomatoPrilaboro proc trovuTreSimilajVortoj {} {
    set d eo.freq
    set rez ""
    set rezSono ""
    set rezVido ""
    set sono {
        dt lr bp sŝ cĉ hĥ
    }
    set vido {
        mn nr ao bh
    }

    set f [open [file join [EsperantoConf prenuVortaroDosierujo] $d] r]
    fconfigure $f -encoding utf-8
    set svort [HunspellTestilo prenuInstancoPorLingvo eo]
    set espvortaro [Vortaro prenuVortaron]
    set radikilo [Radikilaro prenuPorLingvo eo]
    while {[gets $f line]>0} {
        foreach {vorto nombro fgrupo} $line {}
        if {[string length $vorto]<4} continue
        if {[$espvortaro estasVorteto $vorto]} continue
        if {[$espvortaro estasVorto $vorto]!=2} continue
        if {$fgrupo>15} break
        foreach s [$svort prenuProponoj $vorto] {
            set sr [$radikilo radikigi $s]
            if {[$espvortaro estasVorteto $sr]} continue
            if {[$espvortaro estasVorto $sr]!=2} continue
            if {$sr eq $vorto} continue
            if {[string index $sr 0] ne [string index $vorto 0] || [string index $sr end] ne [string index $vorto end]} {
                continue
            }
            if {[string length $sr] != [string length $vorto]} continue
            if {[regexp {[oai](n?t[oea])$} $vorto _ par]} {
                if {[regexp {[oai](n?t[oea])$} $sr _ spar] && $spar eq $par} {
                    continue
                }
            }
            if {[estrings::levenshteinDistance $vorto $sr]==1} {
                lappend rez [lsort [list $sr $vorto]]
                set dif [my trovuALitero $sr $vorto]
                if {[lsearch $vido $dif]>=0} {
                    lappend rezVido [lsort [list $sr $vorto]]
                }
                if {[lsearch $sono $dif]>=0} {
                    lappend rezSono [lsort [list $sr $vorto]]
                }
            }
        }
    }
    close $f
    $svort destroy
    EsperantoBrowser redaktoTekston [join [lsort -unique $rez] \n]
    EsperantoBrowser redaktoTekston [join [lsort -unique $rezVido] \n]
    EsperantoBrowser redaktoTekston [join [lsort -unique $rezSono] \n]
    return
}
Object EORadikilo
@ ::EORadikilo idemeta component EspSintaksaAnalizo
EORadikilo proc cxuCertaj vorto {
    expr {[lsearch -exact {a la de al je mi vi li ĝi ŝi oni tiu tiun tiuj tiujn} $vorto]>=0}
}
EORadikilo proc cxuIgnori vorto {
    expr {[lsearch -exact a $vorto]>=0}
}
EORadikilo proc initializeAfterLoad {} {
    my set primitivajVortoj [lsort {ajn ci du en ies iu je jen ju kaj kies kiu kun kvin neniu nun plej pli plimalpli plu sen tamen ties tiu tuj unu ĉies ĉiu ĝis ĵus}]
}
EORadikilo proc prenuFinilon vorto {
    my instvar primitivajVortoj
    if {[lsearch -exact -sorted $primitivajVortoj $vorto]>=0} {
        return ""
    }
    if {[regexp {^.+?(jn|n|j)$} $vorto m finilo]} {
        return $finilo
    }
    if {[regexp {^.+(is|as|os|us|u)$} $vorto m finilo]} {
        return $finilo
    }
    return ""
}
EORadikilo proc radikigi vorto {
    my instvar primitivajVortoj
    if {[lsearch -exact -sorted $primitivajVortoj $vorto]>=0} {
        return $vorto
    }
    if {[regexp {^(.+?)(jn|n|j)$} $vorto m radiko]} {
        return $radiko
    }
    if {[regexp {^(.+)(is|as|os|us|u)$} $vorto m radiko]} {
        return ${radiko}i
    }
    return $vorto
}
Object EoFabriko
@ ::EoFabriko idemeta component EspSintaksaAnalizo
EoFabriko proc kreuFrazTraduko {name {type normal}} {
    if {$type eq "-childof"} {
        FrazTraduko new -childof $name
    } else {
        FrazTraduko create $name
    }
}
EoFabriko proc kreuFrazo {name {type normal}} {
    if {$type eq "-childof"} {
        GP::Frazo new -childof $name
    } else {
        GP::Frazo create $name
    }
}
EoFabriko proc kreuFrazoLegilo {name {type normal}} {
    if {$type eq "-childof"} {
        FrazoLegilo new -childof $name
    } else {
        FrazoLegilo create $name
    }
}
EoFabriko proc kreuSintaksAnalizilo {name {type normal}} {
    if {$type eq "-childof"} {
        SintaksaAnalizo new -childof $name
    } else {
        SintaksaAnalizo create $name
    }
}
EoFabriko proc prenuCelanLingvon {} {
    EsperantoConf set lingvo
}
EoFabriko proc prenuFontanLingvon {} {
    return eo
}
@ Object Radikilaro {
description {Fabrika objekto por radigiloj}
}
Object Radikilaro
@ ::Radikilaro idemeta component EspSintaksaAnalizo
Radikilaro proc prenuPorLingvo lingvo {
    my instvar enradikilo deradikilo plradikilo
    if {$lingvo eq "en"} {
        if {![info exists enradikilo] || ![Object isobject $enradikilo]} {
            set enradikilo [ENRadikilo new]
        }
        return $enradikilo
    }
    if {$lingvo eq "de"} {
        if {![info exists deradikilo] || ![Object isobject $deradikilo]} {
            set deradikilo [DERadikilo new]
        }
        return $deradikilo
    }
    if {$lingvo eq "pl"} {
        if {![info exists plradikilo] || ![Object isobject $plradikilo]} {
            set plradikilo [PLRadikilo new]
        }
        return $plradikilo
    }
    [string toupper $lingvo]Radikilo
}
Object SubsSuplAnalizilo
@ ::SubsSuplAnalizilo idemeta component EspSintaksaAnalizo
SubsSuplAnalizilo proc estasSubSuplemento {substantivo prepozicio supsubstantivo} {
    if {[lsearch {de kun sen da} $prepozicio]>=0} {
        return 1
    }
    if {[my exists $prepozicio]} {
        if {[lsearch -sort [my set $prepozicio] $substantivo]>=0} {
            return 1
        }
    }
    return 0
}
SubsSuplAnalizilo proc initDeDosiero {{dosiero {}}} {
    if {$dosiero eq ""} {
        set dosiero [file join [EsperantoConf prenuFontoDosierujon] substantivojkunpp.txt]
    }
    if {![file exists $dosiero]} {
        puts "dosiero $dosiero ne trovita"
        return
    }
    set f [open $dosiero r]
    fconfigure $f -encoding utf-8
    set pListo [list]
    while {[gets $f line]>=0} {
        set line [string trim $line]
        if {[string index $line 0] eq "#" || $line eq ""} continue
        set prep [lindex $line 1]
        set substantivo [lindex $line 0]
        if {[lsearch $pListo $prep]<0} {
            lappend pListo $prep
        }
        my lappend $prep $substantivo
    }
    foreach prep $pListo {
        my set $prep [lsort -unique [my set $prep]]
    }
    close $f
}
SintaksaAnalizo initializeAfterLoad
EORadikilo initializeAfterLoad

