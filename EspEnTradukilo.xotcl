# automatically generated from XOTclIDE
# script require component EspTradukilo
@ Component EspEnTradukilo {
description {Specifaj elementoj por angla tradukado}
}
package provide EspEnTradukilo 0.993
package require EspTradukilo
Class ETEnSubstantivoartaMix -superclass ::ETSubstantivoartaMix
@ ::ETEnSubstantivoartaMix idemeta component EspEnTradukilo
ETEnSubstantivoartaMix instproc distinguSubstantivanDifinilon {} {
    next
    my instvar npArto
    if {[info exists npArto]} {
        my metuAttributonEnRadikaFunkcion npArto $npArto
    }
}
ETEnSubstantivoartaMix instproc estasDefinitiva {} {
    return 1
}
ETEnSubstantivoartaMix instproc preparuFunkcion_nekonata radikaTradukElemento {
    my instvar arto persono
    # nepura programado pro kazo
    # multe de (substantiv) en rolo de subjekto
    # la frazo "multe da viroj estas malgranda"
    # attributo estas en pluralo
    # verbo en singularo
    set pparent [$radikaTradukElemento parenco]
    if {$pparent ne "" && [[$pparent set elemento] prenuFunkcioNomo] eq "pos"} {
        set pparent [$pparent set parenco]
        set pelemento [$pparent set elemento]
        if {[$pelemento istype SintaksAsto::advsup] && [$pelemento eblasKielSubstantivo] && [$pelemento set funkcio] eq "subj"} {
            set taMain [$pparent parenco]
            $taMain set persono $persono
            $taMain set nombro pluralo
            $taMain set arto $arto
        }
    }
}
Class EnTradukElemento
@ ::EnTradukElemento idemeta component EspEnTradukilo
EnTradukElemento instproc estasDefinitiva {} {
    return 1
}
EnTradukElemento instproc kazoTrans esperantaKazo {
    switch $esperantaKazo {
        N -
        nominativo {
            return N
        }
        default {
            return A
        }
    }
}
EnTradukElemento instproc prenuFleksilon {} {
    EnFleksilo
}
EnTradukElemento instproc prenuParticiponMix {} {
    ETEnParticipoMix
}
EnTradukElemento instproc probuVortfaradon bazaformo {
    EnVortFarado prenuVortfaradoj2 $bazaformo
}
Class ETEnAdjektivo -superclass {::ETEnSubstantivoartaMix ::EnTradukElemento ::ETAdjektivo}
@ ::ETEnAdjektivo idemeta component EspEnTradukilo
ETEnAdjektivo instproc distinguGramatikon frazTraduko {
    my instvar parenco elemento kazo nombro arto npArto substantivaPrefikso bazaTraduko
    next
    set npArto [my sxercxuAttributonSupren npArto]
    my bazaTraduko [$frazTraduko prenuVortaron]
    if {![my testuSentradukeco]} {
        if {[string match {*~} $bazaTraduko]} {
            set def [my prenuDefinilanElementon]
            if {[$def istype ETSubstantivo]} {
                set substantivaPrefikso 1
                $def set adjektivaPrefikso [string range $bazaTraduko 0 end-1]
            }
        }
    }
}
ETEnAdjektivo instproc kreuKomperativon gparenco {
    my instvar bazaTraduko fgrupo
    set bazaTraduko [[my prenuFleksilon] prenuKompAdjektivo $bazaTraduko $fgrupo]
    return 1
}
ETEnAdjektivo instproc kreuSuperlativon {gparenco i} {
    my instvar bazaTraduko traduko fgrupo
    set bazaTraduko [[my prenuFleksilon] prenuKompAdjektivo $bazaTraduko $fgrupo 1]
    return 1
}
ETEnAdjektivo instproc traduku vortaro {
    my instvar bazaTraduko kazo nombro traduko arto elemento fgrupo parenco npArto substantivaPrefikso
    if {[info exists substantivaPrefikso] && $substantivaPrefikso} {
        set traduko ""
        return
    }

    if {![my testuSentradukeco]} {
        if {[string first one's $bazaTraduko]>=0 || [string first ones $bazaTraduko]>=0} {
            set main [my trovuMainVerboAston]
            if {$main ne "" && [$main exists persono]} {
                set pers [$main set persono]
                if {[$main exists nombro]} {
                    set nomb [$main set nombro]
                    if {[$main exists arto]} {
                        set art [$main set arto]
                        set bazaTraduko [EnFleksilo tradukuOnes $bazaTraduko $pers $nomb $art]
                    }
                }
            }
        }
        next
        set traduko $bazaTraduko
    }
}
Class ETEnAdverbo -superclass {::EnTradukElemento ::ETAdverbo}
@ ::ETEnAdverbo idemeta component EspEnTradukilo
ETEnAdverbo instproc kreuKomperativon {} {
    my instvar bazaTraduko fgrupo
    set bazaTraduko [[my prenuFleksilon] prenuKompAdjektivo $bazaTraduko $fgrupo]
    return 1
}
ETEnAdverbo instproc kreuSuperlativon {} {
    my instvar bazaTraduko fgrupo
    set bazaTraduko "[[my prenuFleksilon] prenuKompAdjektivo $bazaTraduko $fgrupo 1]"
    return 1
}
ETEnAdverbo instproc prenuBazanFormon {} {
    my instvar sens
    if {[info exists sens] && $sens eq "1"} {
        set adv [next]
        return [string range $adv 0 end-1]a
    } else {
        next
    }
}
ETEnAdverbo instproc traduku vortaro {
    my instvar bazaTraduko traduko elemento fgrupo parenco sens
    set sens [my sxercxuAttributonSupren sens]
    if {$sens eq "1"} {
        # estu adjektivo
        # She looks good. It smell great.
        my bazaTraduko [[my info parent] prenuVortaron]
    } else {
        my bazaTraduko $vortaro
    }
    if {![my testuSentradukeco]} {
        if {[string first one's $bazaTraduko]>=0 || [string first ones $bazaTraduko]>=0} {
            set main [my trovuMainVerboAston]
            if {[$main exists persono]} {
                set pers [$main set persono]
                if {[$main exists nombro]} {
                    set nomb [$main set nombro]
                    if {[$main exists arto]} {
                        set art [$main set arto]
                        set bazaTraduko [EnFleksilo tradukuOnes $bazaTraduko $pers $nomb $art]
                    }
                }
            }
        }
        next
    }
    if {[$elemento estasVorto multe] && [$elemento exists parenco] && [[$elemento set parenco] istype SintaksAsto::advsup]} {
        set traduko many
    } else {
        set traduko $bazaTraduko
    }
}
Class ETEnDifinilo -superclass {::EnTradukElemento ::ElemTraduko}
@ ::ETEnDifinilo idemeta component EspEnTradukilo
ETEnDifinilo instproc traduku vortaro {
    my instvar elemento traduko
    if {[$elemento prenuVorton] eq "la"} {
        set traduko the
    } else {
        next
    }
}
Class ETEnInterjekcio -superclass ::ElemTraduko
@ ::ETEnInterjekcio idemeta component EspEnTradukilo
ETEnInterjekcio instproc distinguDifinilon frazTraduko {
    my instvar elemento
    if {[$elemento prenuVorton] eq "ĉu" && [$elemento prenuAntauxElemento] eq ""} {
        my metuAttributonEnMainAsto demandaFrazo 1
    }
}
ETEnInterjekcio instproc traduku votaro {
    my instvar elemento traduko keUFrazo
    switch [$elemento prenuVorton] {
        kaj {
            set traduko and
        }
        ĉu {
           if {[$elemento prenuAntauxElemento] eq ""} {
                my class ETNul
                set traduko ""
            } else {
                set traduko if
            }
        }
        ke {
            set traduko that
        }
        se {
            set traduko if
        }
        sed {
            set traduko than
        }
        ĉar {
            set traduko because
        }
        default {
            next
        }
    }
}
Class ETEnKonjunkcio -superclass ::ElemTraduko
@ ::ETEnKonjunkcio idemeta component EspEnTradukilo
ETEnKonjunkcio instproc tradukoPostSinonimoSxangxo {} {
    my set traduko [my set bazaTraduko]
}
ETEnKonjunkcio instproc traduku vortaro {
    my instvar elemento traduko parenco
    switch [$elemento prenuVorton] {
        kaj {
            if {[info exists elemento]
                && [[$elemento set parenco] istype SintaksAsto::konj]
                && [[$elemento set parenco] estasDuobla kaj]} {
                set id [lsearch [$parenco astoj] [self]]
                if {$id==0} {
                    set traduko either
                } else {
                    set traduko or
                }
            } else {
                set traduko and
            }
        }
        aŭ {
            set traduko or
        }
        ol {
            set traduko than
        }
        nek {
            set id [lsearch [$parenco astoj] [self]]
            if {$id==0} {
                set traduko neither
            } else {
                set traduko nor
            }
        }
        default {
            next
        }
    }
}
Class ETEnKonstanto -superclass {::EnTradukElemento ::ElemTraduko}
@ ::ETEnKonstanto idemeta component EspEnTradukilo
ETEnKonstanto instproc estasDefinitiva {} {
    return 3
}
ETEnKonstanto instproc traduku vortaro {
    my instvar elemento traduko
    # TODO
    switch -- [$elemento prenuVorton] {
        ktp. {
            set traduko etc.
        }
        ekz. {
            set traduko exp.
        }
        p. {
            set traduko p.
        }
        tn. {
            set traduko sc.
        }
        t.n. {
            set traduko sc.
        }
        default {
            set traduko [$elemento prenuVorton]
        }
    }
}
Class ETEnNedefinitaDefinilo -superclass {::EnTradukElemento ::ETSenOrigina} -parameter {{arto 0}}
@ ::ETEnNedefinitaDefinilo idemeta component EspEnTradukilo
ETEnNedefinitaDefinilo instproc bazaTraduko vortaro {

}
ETEnNedefinitaDefinilo instproc posttradukaPlibonigo {indekso folioj} {
    my instvar traduko
    if {$traduko ne "a"} return
    set f ""
    for {set i [expr {$indekso+1}]} {$i<[llength $folioj]} {incr i} {
        set tf [lindex $folioj $i]
        if {[$tf set traduko] ne ""} {
            set f $tf
            break
        }
    }
    if {$f eq "" || [$f testuSentradukeco]} return
    if {[string first [string index [$f set traduko] 0] "aeo"]>=0} {
        set traduko an
    }
}
ETEnNedefinitaDefinilo instproc prenuFunkcioNomo {} {
    return "ein"
}
ETEnNedefinitaDefinilo instproc prenuSimbolo {} {
    return "de"
}
ETEnNedefinitaDefinilo instproc traduku vortaro {
    my instvar arto nombro parenco
    if {$arto==4} {
        set rad [$parenco prenuRadiko]
        if {$nombro eq "pluralo"} {
            my set traduko any
        } else {
            my set traduko no
        }
    } else {
        set rad [$parenco prenuRadiko]
        if {[$rad exists gramatiko] && [lsearch [$rad set gramatiko] uncount]>=0} {
            my set traduko some
        } else {
            my set traduko a
        }
    }
}
Class ETEnNumeralo -superclass {::EnTradukElemento ::ETNumeralo}
@ ::ETEnNumeralo idemeta component EspEnTradukilo
ETEnNumeralo instproc traduku vortaro {
    my instvar traduko bazaTraduko elemento arto kazo nombro veraNombro npArto
    if {[my tradukuNeVorto $vortaro]} {
        return
    }

    set fleksiolo [my prenuFleksilon]
    set traduko [$elemento set vorto]
    if {[$elemento hasclass GP::Adjektivo] || [regexp {aj?n?$} [$elemento set vorto]]} {
        set numarto [$elemento set arto]
        switch $numarto {
            {} {
                set mstraduko [$fleksiolo prenuNumero $bazaTraduko ordo]
            }
            op {
                set mstraduko [$fleksiolo prenuNumero $bazaTraduko opo]
            }
            default {
                next
                set traduko $traduko
                return
            }
        }
        set traduko $mstraduko
        return
    }
    if {[$elemento hasclass GP::Adverbo]} {
        set numarto [$elemento set arto]
        switch $numarto {
            {} {
                set traduko [$fleksiolo prenuNumero $bazaTraduko ordo]
                append traduko "ly"
            }
            default {
                my metuMesagxon "nombroarto $numarto nun ne subtenata" subteno
                return
            }
        }
        return
    }
    set traduko [$fleksiolo prenuNumero $bazaTraduko]
}
Class ETEnParticipoMix -superclass ::ETParticipoMix
@ ::ETEnParticipoMix idemeta component EspEnTradukilo
ETEnParticipoMix instproc bazaTraduko vortaro {
    my instvar elemento tempo preTraduko

    if {![my bazaTradukoDirekte $vortaro]} {
        # divenu partizipon de verbo
        next
        my instvar bazaTraduko tempo gramatiko fgrupo nombro mesagxoTipo arto kazo tradukoListoj
        if {![my testuSentradukeco]} {
            set vtempo $tempo
            if {[my istype ETAdverbo] && $bazaTraduko eq "be"} {
                switch $tempo {
                    ante {
                        set bazaTraduko "being"
                    }
                    onte {
                        set bazaTraduko "future"
                    }
                    inte {
                        set bazaTraduko "former"
                    }
                }
            } else {
                switch $vtempo {
                    ota {
                        set preTraduko "future"
                        set vtempo ata
                    }
                    ita {
                        set vtempo ata
                    }
                    ont -
                    onta -
                    onte {
                        set preTraduk "future"
                        if {$vtempo eq "ont"} {
                            set vtempo anta
                        } else {
                            set vtempo ant[string index $vtempo end]
                        }
                    }
                    int -
                    inta -
                    inte {
                        if {[my istype ETAdverbo] && [lsearch $gramatiko dk]>=0} {
                            # set vtempo inte
                        } else {
                            set preTraduko "former"
                            if {$vtempo eq "int"} {
                                set vtempo anta
                            } else {
                                set vtempo ant[string index $vtempo end]
                            }
                        }
                    }
                }
                if {[lindex $bazaTraduko 0] eq "not"} {
                    set bazaTraduko [lrange $bazaTraduko 1 end]
                    lappend preTraduko not
                }
                if {[llength $bazaTraduko]>1} {
                    # ekzemple: rajti -> miec racje (majacy racje)
                    my set postTraduko [join [lrange $bazaTraduko 1 end]]
                    set nurverbo [lindex $bazaTraduko 0]
                } else {
                    set nurverbo $bazaTraduko
                }
                if {[my istype ETEnSubstantivo]} {
                    if {[my exists nombro] && [my set nombro] eq "pluralo"} {
                        set p "persons who "
                    } else {
                        set p "person who "
                    }
                    set bazaTraduko
                    switch $vtempo {
                        into {
                            set vtempo is
                        }
                        anto {
                            set vtempo as
                        }
                        onto {
                            set vtempo os
                        }
                        ito {
                            if {[my exists nombro] && [my set nombro] eq "pluralo"} {
                                append p "were "
                            } else {
                                append p "was "
                            }
                            set vtempo pis
                        }
                        ato {
                            append p "is "
                            set vtempo pis
                        }
                        oto {
                            append p "will be "
                            set vtempo pis
                        }
                    }
                } else {
                    set p ""
                }
                set bazaTraduko $p[EnFleksilo prenuVerbon $nurverbo $fgrupo 3 singularo $vtempo]
                set novTradukListo {}
                set sinonimoj {}
                foreach {svorto sfgrupo sgramatiko} $tradukoListoj {
                    set sbazaTraduko $p[EnFleksilo prenuVerbon $svorto $sfgrupo 3 singularo $vtempo]
                    if {[my istype ETAdverbo] && $vtempo ne "ite"} {
                        set sbazaTraduko [string range $bazaTraduko 0 end-1]
                    }
                    lappend novTradukListo $sbazaTraduko $sfgrupo $sgramatiko
                    lappend sinonimoj $sbazaTraduko
                }
                set tradukoListoj $novTradukListo
                if {[llength $novTradukListo]>3} {
                    my aliguEblo sinonimo $sinonimoj $bazaTraduko sxangxuSinonimon
                }
            }
        }
    }
}
Class ETEnPersonPronomo -superclass {::EnTradukElemento ::ElemTraduko ::ETEnSubstantivoartaMix}
@ ::ETEnPersonPronomo idemeta component EspEnTradukilo
ETEnPersonPronomo instproc bazaTraduko vortaro {
    my set bazaTraduko ?
}
ETEnPersonPronomo instproc cxuArtoGravas {} {
    return 0
}
ETEnPersonPronomo instproc distinguDifinilon frazTraduko {
    my instvar elemento arto nombro persono
    set nombro [$elemento prenuNombron]
    set vorto [$elemento prenuVorton]
    set persono [$elemento prenuPersonon]
    if {$persono==4} {
        set persono 3
        set nombro singularo
        $elemento set nombro singularo
    }
    switch [string trimright $vorto n] {
        vi {
            set arto m
        }
        li {
            set arto m
        }
        ŝi {
            set arto f
        }
        ĝi {
            set arto n
        }
        ni {
            set arto m
        }
        ili {
            set arto m
        }
        oni {
            set arto n
        }
        si {
            set arto m
        }
        default {
            set arto m
        }
    }
    my distinguSubstantivanDifinilon
}
ETEnPersonPronomo instproc distinguDifinilonPost frazTraduko {
    set radikaTradukElemento [my miAuxRadikaElemento]
    set dfunkcio [[$radikaTradukElemento elemento] set funkcio]
    if {$dfunkcio eq "subj"} {
        my distinguSubstantivanDifinilon
        set krad [my trovuMainAston]
        if {$krad ne ""} {
            set vrad [$krad prenuRadiko]
            if {$vrad ne ""} {
                $vrad distinguGramatikon $frazTraduko
                $vrad traduku [$frazTraduko prenuVortaron]
            }
        }
        foreach a [$krad astoj] {
            if {[$a exists elemento] && [[$a elemento] prenuFunkcioNomo] eq "attr"} {
                $a distinguGramatikon $frazTraduko
                $a traduku [$frazTraduko prenuVortaron]
            }
        }
    }
}
ETEnPersonPronomo instproc distinguGramatikon frazTraduko {
    my instvar parenco kazo elemento arto nombro persono
    set skazo [$parenco sxercxuAttributonSupren kazo]
    if {$skazo ne ""} {
        set kazo $skazo
    }
    if {[$elemento prenuVorton] eq "sin"} {
        set arto [$parenco sxercxuAttributonSupren arto]
        set nombro [$parenco sxercxuAttributonSupren nombro]
        set persono [$parenco sxercxuAttributonSupren persono]
    }
}
ETEnPersonPronomo instproc traduku vortaro {
    my instvar persono parenco traduko
    if {$persono==4} {
        set traduko man
    } else {
        set bazaformo [[my elemento] prenuBazanFormon]
        my instvar kazo arto nombro
        if {$bazaformo eq "si"} {
            set traduko [EnFleksilo prenuOnself $persono $arto $nombro]
        } else {
            set traduko [EnFleksilo prenuPersonPronomon $bazaformo $arto $kazo $nombro]
        }
    }
}
Class ETEnPosesivPronomo -superclass {::EnTradukElemento ::ETPosesivPronomo}
@ ::ETEnPosesivPronomo idemeta component EspEnTradukilo
Class ETEnPrepozicio -superclass {::EnTradukElemento ::ETPrepozicio}
@ ::ETEnPrepozicio idemeta component EspEnTradukilo
ETEnPrepozicio instproc preparuFunkcion_iobj {} {
    my instvar bazaTraduko traduko kazo
    my set testuIObj 1
    set kazo A
    set basaTraduko ""
    set traduko ""
}
ETEnPrepozicio instproc preparuFunkcion_je {} {
    my instvar bazaTraduko traduko kazo
    set traduko about
    set kazo A
}
ETEnPrepozicio instproc preparuFunkcion_porinf {} {
    my instvar traduko
    set traduko for
}
ETEnPrepozicio instproc preparuFunkcion_pos {} {
    my instvar bazaTraduko traduko kazo elemento parenco
    set pparenco [$parenco set parenco]
    if {[$pparenco istype TAEn::subsup]} {
        $pparenco set ppos [self]
    }
    set kazo N
    set bazaTraduko of
    set traduko of
}
ETEnPrepozicio instproc preparuFunkcion_psubj {} {
    my instvar bazaTraduko traduko kazo
    set kazo A
    set bazaTraduko "by"
    set traduko "by"
}
ETEnPrepozicio instproc traduku vortaro {
    my instvar traduko testuIObj
    if {![info exists traduko]} {
        next
    } elseif {$traduko eq "{je}"} {
        my metuMesagxon "prepozicio ne konata" traduko
    } elseif {[info exists testuIObj] && $testuIObj eq "1"} {
        if {[my havasMerkmalonSupren iobjto]} {
            set traduko to
        }
    }
}
ETEnPrepozicio instproc tradukuHoron {} {
    my instvar traduko parenco kazo
    set traduko at
    set npTrad ""
    set kazo A
    foreach a [$parenco set astoj] {
        if {$a ne [self] && [$a istype ::TradukAsto]} {
            set npTrad $a
        }
    }
    if {$npTrad eq ""} return
    foreach a [$npTrad set astoj] {
        if {[$a istype ETEnDifinilo]} {
            $a class ETNul
            $a set traduko ""
        } elseif {[$a istype ETEnNumeralo]} {
            if {![$a tradukuNeVorto ""]} {
                $a class ETSenOrigina
                $a traduko [EnFleksilo prenuNumero [$a set bazaTraduko]]
            }
        } elseif {[$a istype ETEnSubstantivo]} {
            $a class ETSenOrigina
            $a set traduko "o'clock"
        }
    }

}
Class ETEnPrimitivaAdverbo -superclass {::EnTradukElemento ::ElemTraduko}
@ ::ETEnPrimitivaAdverbo idemeta component EspEnTradukilo
ETEnPrimitivaAdverbo instproc distinguDifinilon frazTraduko {
    my instvar elemento parenco
    set vorto [$elemento prenuVorton]
    if {$vorto eq "ĉi"} {
        my set traduko ""
        $parenco set cxi 1
    } elseif {$vorto eq "ne"} {
        set pelemento [$parenco prenuRadiko]
        # ne cxe Verbo - se frazo havas objekton, konvertu al "no"
        if {[[$pelemento set elemento] istype GP::Verbo] && [$pelemento estasRadiko]} {
            set main [my trovuMainAston]
            if {$main eq "" || [$pelemento miAuxRadikaElemento] ne $main} return
            if {[set objElemento [$main trovuKunFunkcio "obj"]] ne "" && [[$objElemento prenuRadiko] estasDefinitiva]==2} {
                set orad [$objElemento prenuRadiko]
                set estasPlur 0
                if {[$orad exists elemento]} {
                    set oelem [$orad set elemento]
                    if {[$oelem exists nombro] && [$oelem set nombro] eq "pluralo"} {
                        set estasPlur 1
                    }
                }
                if {[$objElemento istype TradukAsto]} {
                    [$objElemento prenuRadiko] set npArto 4
                    [$objElemento miAuxRadikaElemento] metuAttributonEnRadikaFunkcion npArto 4
                } else {
                    $objElemento set npArto 4
                }
                if {!$estasPlur} {
                    my class ETNul
                    set traduko ""
                } else {
                    $main metuVerboKielNegativa [self]
                }
            } else {
                $main metuVerboKielNegativa [self]
            }
        }
    }
}
ETEnPrimitivaAdverbo instproc tradukoPostSinonimoSxangxo {} {
    my set traduko [my set bazaTraduko]
}
ETEnPrimitivaAdverbo instproc traduku vortaro {
    my instvar elemento parenco
    set vorto [$elemento prenuVorton]
    if {$vorto eq "ĉi"} {
        my set traduko ""
    } elseif {$vorto eq "pli" && [[$parenco elemento] istype SintaksAsto::padj]} {
        my set traduko "more"
    } elseif {$vorto eq "ne"} {
        if {[info exists elemento] && [set par [$elemento selektu {miAuxRadikaElemento parenco}]] ne "" && [$par istype SintaksAsto::ne]} {
            my set traduko not
        } else {
            my set traduko no
        }
    } elseif {$vorto eq "mem"} {
        if {[my selektu {parenco prenuRadiko elemento prenuVorton}] eq "si"} {
            my foriguDeParenco
        } else {
            my instvar arto persono nombro
            set arto [$parenco sxercxuAttributonSupren arto]
            set persono [$parenco sxercxuAttributonSupren persono]
            set nombro [$parenco sxercxuAttributonSupren nombro]
            my set traduko [EnFleksilo prenuOnself $persono $arto $nombro]
        }
    } else {
        next
    }
}
Class ETEnSubstantivo -superclass {::EnTradukElemento ::ETSubstantivo ::ETEnSubstantivoartaMix}
@ ::ETEnSubstantivo idemeta component EspEnTradukilo
ETEnSubstantivo instproc distinguArtonKajDefinilon {} {
    # TODO angla lingvo ne konas arton
    my instvar gramatiko
    if {[lsearch $gramatiko pers]>=0} {
        my set arto m
    } else {
        my set arto n
    }
    my distinguSubstantivanDifinilon
}
ETEnSubstantivo instproc distinguDifinilon frazTraduko {
    my instvar elemento arto bazaTraduko parenco nombro fgrupo persono npArto gramatiko senTraduko

    my distinguDifinilonBaza $frazTraduko

    if {[my testuSentradukeco]} {
        if {$senTraduko==2} {
            # vortfarado "lingvokono -> kono de lingvo"
            return
        }
        set arto n
        set npArto 1
        my distinguSubstantivanDifinilon
        return
    }

    # distingu arton de np frazo
    # 0 - sen definiloj (
    # 1 - kun definilo 'la'
    # 2 - kun nedefinitiva definilo 'a'
    # 3 - Mit Possesivpronomen und kein
    # 4 - 'kein' definilo (kein estos kunmetota)
    # 5 - kun abstrakta definilo "some"
    # 6 - kun any

    if {![info exists npArto] || $npArto!=4} {
        if {[lsearch $gramatiko abst]>=0} {
            set npArto 0
        } else {
            if {[info exists elemento] && $elemento ne "" && [$elemento senDifinilo]} {
                set npArto 0
            } else {
                set npArto [my estasDefinitiva]
            }
        }
    }

    my distinguArtonKajDefinilon
}
ETEnSubstantivo instproc distinguGramatikon frazTraduko {
    my instvar kazo parenco elemento npArto arto nombro bazaTraduko havasEin

    next
    # cxu substantivo bezonas nedefinitan definilon "ein"
    if {(($nombro eq "singularo" && $npArto==2) || $npArto==4) && ![info exists havasEin]} {
        set pelem [my selektu {parenco elemento}]
        if {$pelem ne "" && [$pelem istype SintaksAsto::np]} {
            set frazoRadiko $parenco
        } else {
            set frazoRadiko [self]
        }
        set ndef [ETEnNedefinitaDefinilo new -childof [my info parent] -parenco $frazoRadiko -arto $npArto]
        $ndef set genro $arto
        $ndef set kazo $kazo
        $ndef set nombro $nombro
        if {[$frazoRadiko exists elemento] && [[$frazoRadiko set elemento] istype SintaksAsto::konj]} {
            set frazoRadiko [$frazoRadiko prenuDirektaRadiko]
        }

        if {$frazoRadiko ne [self]} {
            set pastoj [$frazoRadiko astoj]
            set pastoj [linsert $pastoj 0 $ndef]
            $frazoRadiko astoj $pastoj
        } else {
            set ta [TradukAsto new -childof [my info parent]]
            $ndef parenco $ta
            lappend tastoj $ndef
            lappend tastoj [self]
            $ta astoj $tastoj
            $ta elemento [my elemento]
            if {[lsearch [[my parenco] set astoj] [self]]<0} {
                puts "TO DO"
            } else {
                [my parenco] intersxangxiElementoj [self] $ta
                set parenco $ta
            }
        }
        set havasEin 1
    }
}
ETEnSubstantivo instproc distinguGramatikonDeElementoPost {elemento frazTraduko} {
    if {[$elemento istype ETEnNedefinitaDefinilo] || [$elemento istype ETEnDifinilo]} {
        $elemento distinguGramatikon $frazTraduko
        $elemento traduku [$frazTraduko prenuVortaron]
    }
}
ETEnSubstantivo instproc estasDefinitiva {} {
    # cxu np-subfrazo bezonus "ein"
    set frazoRadiko [[my miAuxRadikaElemento] set elemento]
    # TODO multaj subsup
    if {[$frazoRadiko istype SintaksAsto::subsup] || [$frazoRadiko istype SintaksAsto::npmain]  || [$frazoRadiko istype SintaksAsto::konj]} {
        set frazoRadiko [$frazoRadiko set radiko]
    }
    if {[$frazoRadiko istype SintaksAsto]} {
        if {[[my miAuxRadikaElemento] exists npArto]} {
            return [[my miAuxRadikaElemento] set npArto]
        }
        foreach aa [$frazoRadiko astoj] {
            set a [$aa prenuRadiko]
            if {$a eq ""} continue
            if {[$aa istype SintaksAsto::adjp] && [$aa estasPlej]} {
                return 1
            }
            if {[$a istype GP::Difinilo] || [$a istype GP::TabloVorto]} {
                if {[$a istype GP::TabloVorto] && [$a set bazo] eq "neni" && [$a set arto] eq "u"} {
                    return 3
                } elseif {[$a istype GP::TabloVorto] && [$a set bazo] eq "ti" && [$a set arto] eq "a"} {
                    return 5
                } else {
                    return 1
                }
            } elseif {[$a istype GP::Numeralo] && [$a set arto] eq ""} {
                return 5
            } elseif {[$a istype GP::PosesivPronomo]} {
                return 3
            }
        }
    }
    return 2
}
ETEnSubstantivo instproc estasPersono {} {
    my instvar elemento gramatiko
    if {[$elemento istype GP::Substantivo] && [$elemento estasPersono]} {
        return 1
    }
    if {[info exists gramatiko] && [lsearch $gramatiko pers]>=0} {
        return 1
    }
    return 0
}
ETEnSubstantivo instproc estasViva {} {
    my instvar elemento gramatiko
    if {[$elemento istype GP::Substantivo] && [$elemento estasPersono]} {
        return 1
    }
    if {[info exists gramatiko] && ([lsearch $gramatiko pers]>=0 || [lsearch $gramatiko anim]>=0)} {
        return 1
    }
    return 0
}
ETEnSubstantivo instproc prenuTradukTaugecoIndekson attr {
    my instvar nombro
    set n [next $attr]
    if {[lsearch [dict get $attr gramatiko] op]>=0 && $nombro eq "pluralo"} {
        incr n 101
    }
    return $n
}
ETEnSubstantivo instproc traduku vortaro {
    my instvar traduko bazaTraduko kazo elemento arto nombro fgrupo gramatiko npArto adjektivaPrefikso
    if {[my testuSentradukeco]} {
        set nombro [$elemento prenuNombron]
        return
    }
    if {[$elemento estasVorto %]} {
        set traduko %
        return
    }

    if {[info exists adjektivaPrefikso] && $adjektivaPrefikso ne ""} {
        set bazaTraduko $adjektivaPrefikso[string tolower $bazaTraduko]
    }
    set fleksilo [my prenuFleksilon]
    if {$fgrupo eq ""} {
        set traduko [$fleksilo prenuSubstantivon $bazaTraduko $nombro $kazo]
    } else {
        set traduko [$fleksilo prenuKompleksanSubstantivonLauxTipo $bazaTraduko $fgrupo $nombro $kazo]
    }
}
Class ETEnTabloVorto -superclass {::EnTradukElemento ::ElemTraduko ::ETEnSubstantivoartaMix}
@ ::ETEnTabloVorto idemeta component EspEnTradukilo
ETEnTabloVorto instproc distinguDifinilon frazTraduko {
    my instvar elemento persono nombro arto estasRelativPronomo parenco
    set estasRelativPronomo [$elemento estasRelativPronomo]

    set apudFrazo 0
    if {[$elemento hasclass GP::Substantivo]} {
        set persono 3
        if {$estasRelativPronomo} {
            set arto [my sxercxuAttributonCxeDisk arto]
            set apudFrazo 1
            my metuMerkmalonEnMainAsto apudFrazo
        } else {
            if {[$elemento set bazo] eq "ki" || [$elemento set arto] eq "u"} {
                set arto m
            } else {
                set arto n
            }
            if {[$elemento estasKunliga]} {
                set apudFrazo 1
                my metuMerkmalonEnMainAsto apudFrazo
            }
        }
        set nombro [$elemento prenuNombron]
        my distinguSubstantivanDifinilon
    } elseif {[$elemento estasKunliga]} {
        set apudFrazo 1
        my metuMerkmalonEnMainAsto apudFrazo
    } elseif {[$elemento set bazo] eq "ki"} {
        set pelemento [$parenco set elemento]
        # Frazo: kiam mi estas preta, tion ne scias neniu.
        if {[$pelemento istype SintaksAsto::main] && ![$pelemento estasDemando]} {
            foreach a [$pelemento astoj] {
                if {[$a istype SintaksAsto::main]} {
                    set apudFrazo 1
                    my metuMerkmalonEnMainAsto apudFrazo
                    break
                }
            }
            if {[$pelemento exists parenco] && [$pelemento set parenco] ne ""} {
                set apudFrazo 1
                my metuMerkmalonEnMainAsto apudFrazo
            }
        }
    }
    # Demandaj frazoj kun 'kiu' funkcias en angla lingvo kiel kutimaj frazoj
    # frazoj kiel: kiam, kie, kiom, kiel, kial

    if {[string index [$elemento prenuVorton] 0] eq "k" && ![$elemento estasVorto kiu] && !$estasRelativPronomo} {
        # nur kiam en unua pozitiono
        # ne forgesu demandaj pp "pri kiu", "sur kiu"
        set aelemento [[$elemento miAuxRadikaElemento] prenuAntauxElemento]

        if {$aelemento eq "" || [$aelemento prenuFunkcioNomo] eq "fkonj"} {
            if {[$elemento set funkcio] eq "adv"} {
                $elemento set funkcio kadv
            }
            my aliguMerkmalon estasDemanda
            if {!$apudFrazo} {
                my metuAttributonEnMainAsto demandaFrazo 2
            }
        } elseif {[[$elemento parenco] istype SintaksAsto::pp] && [[$elemento set parenco] prenuAntauxElemento] eq ""} {
            my aliguMerkmalon estasDemanda
            [$elemento set parenco] set funkcio kadv
            if {!$apudFrazo} {
                my metuAttributonEnMainAsto demandaFrazo 2
            }
        }
    } elseif {[string index [$elemento prenuVorton] 0] eq "k" && !$estasRelativPronomo} {
        set aelemento [[$elemento miAuxRadikaElemento] prenuAntauxElemento]

        if {[[$elemento parenco] istype SintaksAsto::pp] && ($aelemento eq "" || [$aelemento prenuFunkcioNomo] eq "fkonj")} {
            my aliguMerkmalon estasDemanda
            [$elemento set parenco] set funkcio kadv
            if {!$apudFrazo} {
                my metuAttributonEnMainAsto demandaFrazo 2
            }
        }
    }
}
ETEnTabloVorto instproc distinguGramatikon frazTraduko {
    my instvar kazo parenco elemento nombro arto estasRelativPronomo persono
    set kazo [my sxercxuAttributonSupren kazo]
    if {$kazo eq ""} {
        if {[$elemento exists kazo]} {
            switch [$elemento set kazo] {
                nominativo {
                    set kazo N
                }
                akuzativo {
                    set kazo A
                }
            }
        }
    }
    if {$estasRelativPronomo} {
        # TODO jxus konata
        set arto [my sxercxuAttributonCxeDisk arto]
    } else {
        set arto [my sxercxuAttributonSupren arto]
    }
    if {$arto eq ""} {
        my metuMesagxon "arto ne destingebla" arto
        set arto n
    }
    if {[$elemento hasclass GP::NombroKazo]} {
        set nombro [$elemento prenuNombron]
    } elseif {[$elemento estasArto es]} {
        set nombro [my sxercxuAttributonSupren nombro]
    }
}
ETEnTabloVorto instproc traduku vortaro {
    my instvar traduko bazaTraduko elemento arto kazo nombro estasRelativPronomo parenco
    set bazaTraduko [$elemento prenuBazanFormon]
    set traduko ($bazaTraduko)
    # iu ajn = kiu ajn -> ktokolwiek
    set aliguKolwiek 0
    if {[[$elemento set parenco] istype SintaksAsto::grupo] && [[[$elemento set parenco] prenuLastan] prenuVorton] eq "ajn"} {
        if {[string index $bazaTraduko 0] eq "i"} {
            set bazaTraduko k$bazaTraduko
        }
        #
        [lindex [$parenco astoj] end] class ETNul
        set aliguKolwiek 1
    }
    set fleksilo [my prenuFleksilon]

    if {[$elemento hasclass GP::Substantivo] && !$estasRelativPronomo} {
        # kiu estas tie? tio estas bona.
        set traduko [$fleksilo prenuPersonPronomon $bazaTraduko $arto $kazo $nombro]
        if {$aliguKolwiek} {
            set traduko some${traduko}
        }
        return
    }
    if {[$elemento hasclass GP::NombroKazo] || $estasRelativPronomo} {
        # tie povas esti du kazoj
        # relativ pronomo aux demanda pronomo
        # Kiu viriono estas la plej bela?
        # Mi vidis virinon, kiu estas bela.
        if {[$elemento estasVorto kies]} {
            # kobieta, czyjej spiew był bardzo piekny
            set tnombro [my sxercxuAttributonCxeDisk nombro]
            if {$tnombro ne ""} {
                set nombro $tnombro
            }
        }
        if {$bazaTraduko eq "kiu" || $bazaTraduko eq "kiun"} {
           set darto [my sxercxuAttributonCxeDisk arto]
           if {$darto eq "m"} {
               if {$bazaTraduko eq "kiu"} {
                   set traduko who
               } else {
                   set traduko whom
               }
           } else {
               set traduko which
           }
        } else {
            set traduko [$fleksilo prenuPosesivPronomon $bazaTraduko $arto $kazo $nombro]
        }
        if {$aliguKolwiek} {
            set traduko some$traduko
        }
        if {$bazaTraduko eq "tiu" && [my sxercxuAttributonSupren cxi] eq "1"} {
            if {$nombro eq "pluralo"} {
                set traduko these
            } else {
                set traduko this
            }
        }
        return
    }
    if {[$elemento estasVorto kies]} {
        if {$kazo eq ""} {
            set traduko whose
        } else {
            set traduko [$fleksilo prenuPosesivPronomon kies $arto $kazo $nombro]
        }
        if {$aliguKolwiek} {
            set traduko some$traduko
        }
        return
    }
    # de kie de tie
    if {[$elemento set arto] eq "e" && [[$parenco elemento] istype SintaksAsto::advp] && [[[$parenco elemento] prenuUnuan] estasVorto "de"]} {
        set estasDeIe 1
        set dobj [lindex [$parenco set astoj] 0]
        $dobj class ETNul
        $dobj traduko ""
    } else {
        set estasDeIe 0
    }

    switch [$elemento prenuVorton] {
        kien -
        kie {
            if {$estasDeIe} {
                set main [my trovuMainVerboAston]
                if {$main ne ""} {
                    set prep [ETSenOrigina new -childof [my info parent] -traduko from]
                    set traduko where
                    $main movuAlPozicio $prep end
                } else {
                    set traduko "from where"
                }
            } else {
                set traduko where
            }
        }
        ie {
            if {$estasDeIe} {
                set traduko somewhere
            } else {
                set traduko somewhere
            }
        }
        nenien {
            set traduko nowhere
        }
        ĉie {
            set traduko anywhere
        }
        tien {
            set cxi [my sxercxuAttributonSupren cxi]
            if {$cxi eq "1"} {
                set traduko here
            } else {
                set traduko there
            }
        }
        tie {
            set cxi [my sxercxuAttributonSupren cxi]
            if {$cxi eq "1"} {
                set traduko here
            } else {
                if {$estasDeIe} {
                    set traduko there
                } else {
                    set traduko there
                }
            }
        }
        nenie {
            if {$estasDeIe} {
                set traduko nowhere
            } else {
                set traduko nowhere
            }
        }
        ien {
            if {$estasDeIe} {
                set traduko {from somewhere}
            } else {
                set traduko somewhere
            }
        }
        ĉien {
            if {$estasDeIe} {
                set traduko {from anywhere}
            } else {
                set traduko anywhere
            }
        }
        ties {
            set traduko whose
        }
        nenies {
            set traduko noones
        }
        ĉies {
            set traduko everyones
        }
        ies {
            set traduko someones
        }
        kiam {
            set traduko when
        }
        tiam {
            set traduko then
        }
        ĉiam {
            set traduko always
        }
        iam {
            set traduko sometime
        }
        neniam {
            my set funkcio never
            set traduko never
        }
        kiom {
            set traduko "how many"
        }
        tiom {
            set traduko "so many"
        }
        kial {
            set traduko why
        }
        kiel {
            if {[my havasMerkmalon estasDemanda]} {
                set traduko how
            } else {
                set traduko like
            }
        }
        tiel {
            set traduko thus
        }
        default {
            my bazaTraduko $vortaro
            next
        }
    }
    if {$aliguKolwiek} {
        set traduko "some${traduko}"
    }
}
Class ETEnVerbo -superclass {::EnTradukElemento ::ETVerbo}
@ ::ETEnVerbo idemeta component EspEnTradukilo
ETEnVerbo instproc aliguPrepAlObjekto {prepPriskribo objElemento} {
    if {[$objElemento istype ElemTraduko] && [[$objElemento set elemento] estasBasaVorto "kio"]} {
        set parenco [$objElemento parenco]
        set prep [ETSenOrigina new -childof [my info parent] -traduko [lindex $prepPriskribo 0]]
        $parenco movuAlPozicio $prep end
    } else {
        next
    }
}
ETEnVerbo instproc distinguGramatikon frazTraduko {
    my instvar bazaTraduko fgrupo tempo gramatiko parenco traduko elemento
    next
    my testuCxuFrazo
    if {[my testuSentradukeco]} return
    if {[$elemento prenuVorton] eq "bonvolu"} {
        # bonvola ordono estas tradukota al "please"
        set smain [my trovuMainAston]
        if {$smain ne ""} {
            $smain set bonvolaOrdono 1
            my class ETSenOrigina
            set bazaTraduko please
            set traduko please
        }
    }
    if {[string first " " $bazaTraduko]>0} {
        if {[llength $bazaTraduko]>=2} {
            if {[lindex $bazaTraduko 0] eq "be"} {
                set tobj [ETSenOrigina new -childof [my info parent] -funkcio attr -traduko [lrange $bazaTraduko 1 end]]
                set pid [lsearch [$parenco astoj] [self]]
                incr pid
                set bazaTraduko [lindex $bazaTraduko 0]
                $parenco movuAlAbsPozicio $tobj $pid
            } elseif {[llength $bazaTraduko]==2 && [lindex $bazaTraduko 0] eq "make"} {
                set tobj [ETSenOrigina new -childof [my info parent] -funkcio attr -traduko [lrange $bazaTraduko 1 end]]
                set pid [lsearch [$parenco astoj] [self]]
                incr pid
                set bazaTraduko [lindex $bazaTraduko 0]
                $parenco movuAlAbsPozicio $tobj $pid
            }
        }
    }
    # pritraktu "sens" verboj
    if {[lsearch $gramatiko sens]>=0} {
        my metuAttributonEnRadikaFunkcion sens 1
    }
    if {[lsearch $gramatiko iobjto]>=0} {
        my metuMermalonEnRadikaFunkcion iobjto
    }
}
ETEnVerbo instproc metuVerboKielNegativa negObjekto {
    #my muvuElementonEnPostKampoLauFunkcio $negObjekto not
    my set negObjekto $negObjekto
    my aliguMerkmalon negativa
}
ETEnVerbo instproc muvuElementonEnPostKampo {nelemento pozicio {funkcio verb}} {
    my instvar postkampo parenco elemento
    $nelemento set vfunkcio $funkcio
    if {![info exists postkampo]} {
        set main [my trovuMainVerboAston]
        if {$main eq ""} {
            set main $parenco
        }
        set tastoj [$main astoj]
        set prep [TAEn::PreVerbo new -childof [my info parent] -parenco $main]
        #$prep set elemento $elemento
        $nelemento foriguDeParenco
        $prep astoj $nelemento
        $nelemento parenco $prep
        $main movuAlPozicio $prep end
        set postkampo $prep
    } else {
       $postkampo movuAlPozicio $nelemento $pozicio
    }
}
ETEnVerbo instproc muvuElementonEnPostKampoLauFunkcio {melemento funkcio} {
    my instvar postkampo persono tempo elemento parenco
    set ordo {ask will not}

    if {![info exists postkampo]} {
        my muvuElementonEnPostKampo $melemento 0 $funkcio
        return
    }
    set i 0
    set pos [lsearch $ordo $funkcio]
    # ne permesi du elementoj kun sama funkcio
    foreach e [$postkampo astoj] {
        if {[$e set vfunkcio] eq $funkcio} {
            return
        }
    }
    foreach e [$postkampo astoj] {
        if {[lsearch $ordo [$e set vfunkcio]]>=$pos} {
            my muvuElementonEnPostKampo $melemento $i $funkcio
            return
        }
        incr i
    }
    my muvuElementonEnPostKampo $melemento $i $funkcio
}
ETEnVerbo instproc prenuTradukTaugecoIndekson attr {
    my instvar nombro tempo

    # neniu aux ordo 0 estas tre malalto ordo 100
    set n [next $attr]

    if {$tempo ne "as" && [lsearch [dict get $attr gramatiko] auxp]>=0} {
        incr n 101
    }

    return $n
}
ETEnVerbo instproc selektuBazanTradukon tradukojListojTemp {
    my selektuBazanTradukonKunFiltro $tradukojListojTemp
}
ETEnVerbo instproc testuCxuFrazo {} {
    my instvar bazaTraduko fgrupo tempo gramatiko parenco traduko elemento postkampo persono nombro
    set main [my trovuMainAston]
    if {$main eq "" || ![my estasRadiko] || [$main prenuRadiko] ne [self]} return
    set demandaFrazo [my sxercxuMainAttributon demandaFrazo]
    if {$demandaFrazo>0} {
        if {$tempo eq "as" || $tempo eq "is"} {
            if {[lsearch {be can must might} [lindex $bazaTraduko 0]]>=0} {
                # Are you ready.
                # Was she pretty.
                my aliguMerkmalon demandaFrazoKunEsti
            } else {
                if {$tempo eq "is"} {
                    set pre did
                } else {
                    if {$persono eq 3 && $nombro eq "singularo"} {
                        set pre does
                    } else {
                        set pre do
                    }
                }
                set sobj [ETSenOrigina new -childof [my info parent]]
                $sobj set traduko $pre
                my muvuElementonEnPostKampoLauFunkcio $sobj will
            }
        }
    }
}
ETEnVerbo instproc tradukoOrdonon vortaro {
    my instvar persono tempo nombro bazaTraduko traduko fgrupo negObjekto
    set main [my trovuMainAston]
    if {$main eq "" || ($main ne "" && [[$main elemento] estasOrdonoSenSubjekto])} {
        if {[EsperantoConf set tradDeOrdonoAlSubstantivo]} {
            set traduko [EnFleksilo prenuVerbon $bazaTraduko $fgrupo 3 $nombro o]
            my aliguMerkmalon veraOrdono
        } else {
            set traduko [EnFleksilo prenuVerbon $bazaTraduko $fgrupo 3 $nombro u]
            my aliguMerkmalon veraOrdono
            if {[my havasMerkmalon negativa]} {
                $negObjekto traduku $vortaro
                my muvuElementonEnPostKampoLauFunkcio $negObjekto not
                set vpersono 1
                set sobj [ETSenOrigina new -childof [my info parent]]
                $sobj set traduko do
                my muvuElementonEnPostKampoLauFunkcio $sobj will
            }
        }
        return
    }
    set sobj [ETSenOrigina new -childof [my info parent]]
    if {[my havasMerkmalon negativa]} {
        $negObjekto foriguDeParenco
        $sobj traduko "should not"
    } else {
        $sobj traduko should
    }
    my muvuElementonEnPostKampoLauFunkcio $sobj will
    set traduko $bazaTraduko
}
ETEnVerbo instproc traduku vortaro {
    my instvar traduko bazaTraduko persono nombro tempo fgrupo gramatiko elemento keUFrazo parenco negObjekto arto
    if {[my testuSentradukeco]} return

    set vtempo $tempo
    set vpersono $persono
    if {$keUFrazo eq "1" && $vtempo eq "u"} {
        set vtempo as
        set vpersono $persono
    } elseif {$vtempo eq "u"} {
        my tradukoOrdonon $vortaro
        return
    }
    set demandaFrazo [my sxercxuMainAttributon demandaFrazo]
    # She has the book. -> Does she have a book
    if {$demandaFrazo>0} {
        if {$tempo eq "as"  && [lindex $bazaTraduko 0] ne "be"}  {
            set vpersono 1
        } elseif {$tempo eq "is" && [lindex $bazaTraduko 0] ne "be"} {
            set vtempo as
            set vpersono 1
        }
    }
    set not ""
    if {[my havasMerkmalon negativa]} {
        if {[lsearch {be can must might} [lindex $bazaTraduko 0]]>=0} {
            $negObjekto foriguDeParenco
            set not not
        } else {
            $negObjekto traduku $vortaro
            my muvuElementonEnPostKampoLauFunkcio $negObjekto not
            set vpersono 1
            if {$tempo eq "is"} {
                set pre did
                set vtempo as
            } else {
                if {$persono eq 3 && $nombro eq "singularo"} {
                    set pre does
                } else {
                    set pre do
                }
            }
            set sobj [ETSenOrigina new -childof [my info parent]]
            $sobj set traduko $pre
            my muvuElementonEnPostKampoLauFunkcio $sobj will
        }
    }

    set traduko [EnFleksilo prenuVerbon [lindex $bazaTraduko 0] $fgrupo $vpersono $nombro $vtempo]

    if {$tempo eq "os" || $tempo eq "pis" || $tempo eq "us" && [llength $traduko]>1} {
        set werdenVerbo [lindex $traduko 0]
        set sorg [ETSenOrigina new -childof [my info parent]]
        $sorg set traduko $werdenVerbo
        set wirkVerbo [lrange $traduko 1 end]
        set traduko $wirkVerbo
        my muvuElementonEnPostKampoLauFunkcio $sorg will
    }
    set bazaTraduko [EnFleksilo tradukuOnes $bazaTraduko $persono $nombro $arto]
    set traduko [join [concat $traduko $not [lrange $bazaTraduko 1 end]]]
    # modala verbo - metu la infinitivon al lasta pozicio
    if {$tempo eq "i" && [[my miAuxRadikaElemento] prenuFunkcioNomo] eq "nfvp"} {
        set masto [my trovuMainAston]
        if {$masto ne ""} {
            if {[$masto exists bonvolaOrdono]} {
                $elemento set funkcio radiko
                #$masto movuAlPozicio [self] 1
                set traduko $bazaTraduko
            } else {
                set mverbo [$masto prenuRadiko]
                if {$mverbo ne "" && $mverbo ne [self] && [$mverbo istype ETVerbo]} {
                    if {[$mverbo exists gramatiko] && [lsearch [$mverbo set gramatiko] auxto]>=0} {
                        set traduko "to $traduko"
                    } elseif {[$mverbo exists gramatiko] && ([lsearch [$mverbo set gramatiko] aux]>=0 || [lsearch [$mverbo set gramatiko] auxp]>=0)} {
                        # nothing
                    } else {
                        set traduko [EnFleksilo prenuVerbon [lindex $bazaTraduko 0] $fgrupo $vpersono $nombro ing]
                    }
                }
            }
        }
    }
}
Class TAEn -superclass ::TradukAsto
@ ::TAEn idemeta component EspEnTradukilo
Class TAEn::PreVerbo -superclass ::TAEn
@ ::TAEn::PreVerbo idemeta component EspEnTradukilo
TAEn::PreVerbo instproc miAuxRadikaElemento {} {
    return  [self]
}
TAEn::PreVerbo instproc prenuFunkcioNomo {} {
    return "preverbo"
}
Class TAEn::VerboParentezo -superclass ::TAEn
@ ::TAEn::VerboParentezo idemeta component EspEnTradukilo
TAEn::VerboParentezo instproc miAuxRadikaElemento {} {
    return  [self]
}
Class TAEn::ktempo -superclass {::TradukAstoKTempo ::TAEn}
@ ::TAEn::ktempo idemeta component EspEnTradukilo
Class TAEn::main -superclass {::TradukAstoMain ::TAEn}
@ ::TAEn::main idemeta component EspEnTradukilo
TAEn::main instproc metuVerboKielNegativa negObjekto {
   [my prenuRadiko] metuVerboKielNegativa $negObjekto
}
TAEn::main instproc preparuElementoPorKreuArbon {} {
   my transformuSubsupDePrononom
}
TAEn::main instproc reordigu {} {
    next
    my instvar astoj demandaFrazo elemento iobjto
    set verbo [my prenuRadiko]
    set subj [my trovuKunFunkcio subj]
    set comp [my trovuKunFunkcio comp]
    set kadv [my trovuKunFunkcio kadv]
    set obj [my trovuKunFunkcio obj]
    set iobj [my trovuKunFunkcio iobj]
    set fkonj [my trovuKunFunkcio fkonj]
    if {$fkonj ne "" && [$fkonj istype ETSimbolo]} {
        if {[[lindex $astoj 1] prenuFunkcioNomo] eq "fkonj"} {
            set fkonj [lindex $astoj 1]
        } else {
            set fkonj ""
        }
    }
    set adv [my trovuKunFunkcio adv]
    set midpos ""
    set apudFrazo [my havasMerkmalon apudFrazo]

    if {$adv ne "" && [$adv istype ElemTraduko] && [lsearch {never always} [$adv set traduko]]>=0} {
        set midpos $adv
    } elseif {$adv ne "" && [$adv istype ETEnAdverbo] && [$adv exists gramatiko] && [lsearch [$adv set gramatiko] midpos]>=0} {
        set midpos $adv
    }

    set demandaParto ""

    if {$verbo ne "" && [$verbo istype ETVerbo]} {
        if {[$verbo havasMerkmalon veraOrdono]} {
            set verboPozicio 0
        } else {
            set verboPozicio 1
        }

        # sed, aux kaj
        if {$fkonj ne ""} {
            incr verboPozicio
        }
        if {$kadv ne ""} {
            incr verboPozicio
        }
        if {([info exists demandaFrazo] && $demandaFrazo==2)} {
            # kie estas la kapo?
            # kiun viron vi amas?
            # kiun vi vidas?
            # kiu estas tie?
            set demandaParto [my trovuUnunanInfanonKiu infano {[$infano havasMerkmalon estasDemanda]}]
        } elseif {[$verbo havasMerkmalon demandaFrazoKunEsti]} {
            set verboPozicio 0
        } elseif {$apudFrazo} {
            set demandaParto [lindex $astoj 1]
            if {$demandaParto ne $subj} {
                incr verboPozicio
            }
        }
        if {[my selektu {0 prenuFunkcioNomo}] eq "pp"} {
            incr verboPozicio
        }

        # enmetu fiktivan subjektivo "es" se la frazo ne estas ordono
        if {($subj eq "" || [$subj istype ETVerbo]) && [[$verbo elemento] istype GP::Verbo] && ([[$verbo elemento] estasEst] || ![[$verbo elemento] necesasSubjekton]) && [my prenuFunkcioNomo] ne "subfrazo" && ![$elemento estasOrdonoSenSubjekto]} {
            set subj [ETSenOrigina new -childof [my info parent] -parenco [self]]
            $subj traduko it
            if {$apudFrazo} {
                my movuAlPozicio $subj 2
            } else {
                my movuAlPozicio $subj [expr {$verboPozicio-1}]
            }
        } elseif {[$elemento estasEkzistoEsprimo] && (![info exists demandaFrazo] || $demandaFrazo!=2)} {
            set there [ETSenOrigina new -childof [my info parent] -parenco [self]]
            $there traduko there
            my movuAlPozicio $there [expr {$verboPozicio-1}]
        }
        # ordigi subjekton
        # pritraktu ->
        # kie vi estas?
        # kiu estas tie?
        # kiu homo legas ofte?
        if {([info exists demandaFrazo] && $demandaFrazo==2) || [info exists there]} {
            if {$subj ne "" && [$subj havasMerkmalonSuben estasDemanda]} {
                set subjpos [expr {$verboPozicio-1}]
            } else {
                set subjpos [expr {$verboPozicio+1}]
            }
        } else {
            if {[$verbo havasMerkmalon demandaFrazoKunEsti]} {
               set subjpos [expr {$verboPozicio+1}]
            } else {
                set subjpos [expr {$verboPozicio-1}]
            }
        }
        if {$comp ne "" && [[$comp prenuRadiko] istype ETEnTabloVorto]} {
            set elem [[$comp prenuRadiko] elemento]
            if {[$elem estasVortoj {kiu kio tiu}]} {
                my movuAlPozicio $comp [expr {$verboPozicio-1}]
            }
        } elseif {$subj ne ""} {
            if {$verboPozicio>$subjpos} {
                my movuAlPozicio $subj $subjpos
            }
        }
        if {[[$verbo elemento] eblasObjAdjComp] || [string range [[$verbo elemento] prenuBazanFormon] end-2 end] eq "igi"} {
            # se atributiva frazo metu "ne" antaux atributo
            set attr [my trovuKunFunkcio oattr]
            if {$attr eq ""} {
                set attr [[$verbo set parenco] trovuKunFunkcio oattr]
            }
            if {$attr ne ""} {
                $verbo muvuElementonEnPostKampoLauFunkcio $attr attr
            }
        }
        # metu la pozicion de preverbo
        set preverbo [my trovuKunFunkcio preverbo]
        if {$preverbo ne ""} {
            if {[my exists demandaFrazo] && [my set demandaFrazo]} {
                if {$kadv ne "" || $demandaFrazo==2} {
                    if {$kadv eq ""} {
                        # kion vi vidas? (ne estas kadv)
                        incr verboPozicio
                    }
                    my movuAlPozicio $preverbo [expr {$verboPozicio-1}]
                    # ne nur cxe "kiu homo dormas ofte?"
                    if {$subj eq "" || ![$subj havasMerkmalonSuben estasDemanda]} {
                        set verboPozicio [expr {$subjpos+1}]
                    }
                } else {
                    my movuAlPozicio $preverbo 0
                    incr verboPozicio
                }
            } else {
                my movuAlPozicio $preverbo $verboPozicio
                incr verboPozicio
            }
        }
        # midpos = always, never, simotime
        if {$midpos ne ""} {
            my movuAlPozicio $midpos $verboPozicio
            incr verboPozicio
        }
        # metu la pozicion de verbo

        if {$verbo ne ""} {
            my movuAlPozicio $verbo $verboPozicio
        }
        # verbo antaux subjekto - ekzemple cxe demendoj kun "esti"
        # Cxu vi estas preta?
        if {$verboPozicio<$subjpos && $subj ne ""} {
            my movuAlPozicio $subj $subjpos
            set objpos [expr {$subjpos+1}]
        } else {
            # Cxu vian libron mi povas legi?
            set objpos [expr {$verboPozicio+1}]
        }

        if {[my havasMerkmalon iobjto]} {
            # pozicio de direkta objekto
            if {$obj ne "" && ![$obj havasMerkmalonSuben estasDemanda] && $obj ne $demandaParto} {
                my movuAlPozicio $obj $objpos
                incr objpos
            }
            # pozicio de indirekta objekto
            if {$iobj ne "" && $iobj ne $demandaParto} {
                my movuAlPozicio $iobj $objpos
                incr objpos
            }
        } else {
            # pozicio de indirekta objekto
            if {$iobj ne "" && $iobj ne $demandaParto} {
                my movuAlPozicio $iobj $objpos
                incr objpos
            }
            # pozicio de direkta objekto
            if {$obj ne "" && ![$obj havasMerkmalonSuben estasDemanda] && $obj ne $demandaParto} {
                my movuAlPozicio $obj $objpos
                incr objpos
            }
        }
    }
}
Class TAEn::nfvp -superclass ::TAEn
@ ::TAEn::nfvp idemeta component EspEnTradukilo
TAEn::nfvp instproc metuVerboKielNegativa negObjekto {
   [my prenuRadiko] metuVerboKielNegativa $negObjekto
}
TAEn::nfvp instproc reordigu {} {
    next
    my instvar astoj
    set verbo [my prenuRadiko]
    set pos 0
    foreach a [my prenuTradukoj] {
        if {[lsearch {neither nor not} $a]>=0} {
            incr pos
        }
        break
    }
    my movuAlPozicio $verbo $pos
    if {$verbo ne "" && [$verbo istype ETVerbo]} {
        # se atributiva frazo metu "ne" antaux atributo
        set attr [my trovuKunFunkcio attr]
        if {$attr ne ""} {
            $verbo muvuElementonEnPostKampoLauFunkcio $attr attr
        }
        set attr [my trovuKunFunkcio oattr]
        if {$attr eq ""} {
            set attr [[$verbo set parenco] trovuKunFunkcio oattr]
        }
        if {$attr ne ""} {
            $verbo muvuElementonEnPostKampoLauFunkcio $attr attr
        }
    }
}
Class TAEn::np -superclass {::TradukAstoNp ::TAEn}
@ ::TAEn::np idemeta component EspEnTradukilo
TAEn::np instproc reordigu {} {
    my instvar astoj elemento
    set rad [my prenuLokaRadiko]
    set reloku 1
    if {[info exists elemento] && [string tolower [$elemento prenuVortoj]] eq "vi ĉiuj"} {
        set reloku 0
    } elseif {[info exists elemento] && [[$elemento prenuUnuan] estasVorto "io"]} {
        set reloku 0
    }
    if {$reloku && [lindex $astoj end] ne $rad} {
        my movuAlAbsPozicio $rad end
    }
    next
}
Class TAEn::pp -superclass ::TAEn
@ ::TAEn::pp idemeta component EspEnTradukilo
TAEn::pp instproc reordigu {} {
    my instvar funkcio
    next
    if {[my prenuFunkcioNomo] eq "kadv"} {
        set main [my trovuMainAston]
        if {$main ne ""} {
            $main movuAlPozicio [my prenuRadiko] end
        }
    }
}
Class TAEn::smain -superclass ::TAEn::main
@ ::TAEn::smain idemeta component EspEnTradukilo
Class TAEn::subsup -superclass {::TradukAstoSubsup ::TAEn}
@ ::TAEn::subsup idemeta component EspEnTradukilo
TAEn::subsup instproc distinguGramatikon frazTraduko {
    my instvar ppos
    if {[info exists ppos] && $ppos ne ""} {
        # libro de frato -> a brother's book
        if {[my tradukoPosFunkcion]} {
            $ppos set traduko ""
            $ppos set bazaTraduko ""
        } else {
            unset ppos
        }
    }
    next
}
TAEn::subsup instproc reordigu {} {
    my instvar ppos
    if {[info exists ppos] && $ppos ne ""} {
        set pos [my trovuKunFunkcio pos]
        set elem [$pos elemento]
        set selem [[$elem prenuNPParton] prenuCxefRadiko]
        set spos [my trovuUnunanInfanonKiu e {[$e exists elemento] && [$e elemento] eq $selem}]
        if {$spos ne ""} {
            my movuAlPozicio $spos 0
        }
    }
}
TAEn::subsup instproc tradukoPosFunkcion {} {
   set pos [my trovuKunFunkcio pos]
   if {$pos eq ""} { return 0 }
   set prad [[lindex [$pos set astoj] end] prenuRadiko]
   if {[$prad istype ETEnSubstantivo] && [$prad estasViva]} {
        # libro de frato
        # brother's book
        set srad [my prenuRadiko]
        $prad metuAttributonEnRadikaFunkcion kazo G
        $pos set kazo G
        if {[$srad exists npArto] && ([$srad set npArto]==1 || [$srad set npArto]==2)} {
            # la libro de frato -> the brother's book
            foreach e [[$prad set parenco] set astoj] {
                if {[$e istype ETEnDifinilo]} {
                    if {[$prad exists npArto] && ([$prad set npArto]==1 || [$prad set npArto]==3)} {
                        $e class ETNul
                        set trovita 1
                        break
                    } else {
                        [$prad set parenco] movuAlPozicio $e 0
                        $prad set npArto 1
                    }
                }
            }
            $prad set havasEin 1
        }
        $srad set npArto 0
        return 1
   }
   return 0
}
TAEn::subsup instproc traduku vortaro {
    my instvar elemento astoj
    if {[info exists elemento] && [$elemento estasDato]} {
        # forigu 'la'
        my selektu {parenco 0 foriguDeParenco}
        set sobj [ETSenOrigina new -childof [my info parent] -traduko on]
        my movuAlPozicio $sobj 0
        set pp [lindex $astoj end]
        set np [$pp selektu {end prenuRadiko}]
        $pp traduku $vortaro
        $np traduku $vortaro
        set pp [$pp prenuRadiko]
        $pp foriguDeParenco
        set rad [my prenuRadiko]
        $rad traduku $vortaro
    } else {
        next
    }
}
Object EnFleksilo
@ ::EnFleksilo idemeta categoriesMethodsProcs {{prenuSubstantivoEsceptoj prenuVerboEsceptoj prenuFleksgrupojPorVerbo prenuFleksgrupojPorSubstantivo metaPriskribojPor}}
@ ::EnFleksilo idemeta categoriesProcs meta-api
@ ::EnFleksilo idemeta component EspEnTradukilo
EnFleksilo proc esceptoj2Arr {fgrupo arr_ref} {
    upvar $arr_ref arr
    foreach e $fgrupo {
        foreach {k v} $e {}
        set arr($k) $v
    }
}
EnFleksilo proc estasVovel char {
    set vovel "aeiuoy"
    expr {[string first $char $vovel]>=0}
}
EnFleksilo proc initNumeralojn {} {
    my instvar  cxefNumeraloj ordoNumeraloj

    array set cxefNumeraloj {0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 10 ten 11 eleven 12 twelve 13 thirteen 14 fourteen 15 fifteen 16 sixteen 17 seventeen 18 eighteen 19 nineteen 20 twenty 30 thirty 40 forty 50 fifty 60 sixty 70 seventy 80 eighty 90 ninety 100 hundred 1000 thousand 1000000 million 1000000000 miliard}

    array set ordoNumeraloj {0 zero 1 first 2 second 3 third 4 fourth 5 fifth 6 sixth 7 seventh 8 eighth 9 ninth 10 tenth 11 eleventh 12 twelfth 13 thirteenth 14 fourteenth 15 fifteenth 16 sixteenth 17 seventeenth 18 eighteenth 19 nineteenth}

}
EnFleksilo proc initPronomojn {} {
    my instvar pronomojArr posPronomojArr

    array set pronomojArr {
        mi {I me}
        vi you
        ŝi {she her}
        li {he him}
        ĝi it
        ni {we us}
        si {he him}
        ili {they them}
        kiu {who whom}
        kio what
        neniu no
        nenio nothing
        iu someone
        ĉiu everyone
        io something
        tio it
        ĉio everything
        tia such
        ia {some kind of}
        kia {what kind of}
        tia {that kind of}
        ĉia {every kind of}
        nenia {no kind of}
        tiu this
        oni one
    }
    array set posPronomojArr {
        mia my
        via your
        sia his
        lia his
        ĝia its
        ŝia her
        nia our
        ilia their
        kiu which
        kia {what kind of}
        nenia {no kind of}
        neniu  no
        tiu that
        tia {that kind of}
        ia {some kind of}
        iu {some}
        ĉiu {every}
        ĉia {every kind of}
        mem {self}
        iom {some}
        tiom {so much}
        ĉiom {all of it}
        kiom {how much}
        onia {ones}
        kies {whose}
    }
}
EnFleksilo proc initializeAfterLoad {} {
    my initNumeralojn
    my initPronomojn
}
EnFleksilo proc metaPriskribojPor vortarto {
    set p {}
    switch -- $vortarto {
        Substantivo {
            set p {
                {coll {(coll - collective) nomo de kolektivo} {abst pers anim}}
                {abst {(abst - abstraktum) sen singularo} {pers coll anim}}
                {pers {(pers - person) persono} {abst coll anim}}
                {anim {anim - living being} {abst coll pers}}
                {uncount {(uncount - uncountable) nekalkulebla} {abst coll}}
                {op {(op - without plural) sen pluralo} os}
                {os {(os - without singular) sen singularo} op}
            }
        }
        Verbo {
            set p {
                {trans {transitiva verbo} netrans}
                {ntrans {netransitiva verbo} trans}
                {iobjto {indirekta objekto kun prepozicio 'to'} netrans}
                {sens {sense verbs}}
                {aux {auxiliary}}
                {auxto {auxiliary + to}}
                {auxp {auxiliary only presens}}
            }
        }
        Adjektivo {
            set p {
                {sub {kiel sola substantivo}}
            }
        }
        Adverbo {
            set p {
                {midpos mid-position {}}
            }
        }
    }
    return $p
}
EnFleksilo proc prenuAdjektivoEsceptoj {} {
    return {
        pl pluralo
        ett {nedifinita 'neuter'}
        komp komperativo
        sup superlativo
    }
}
EnFleksilo proc prenuAdverboEsceptoj {} {
    return {
        komp komperativo
        sup superlativo
    }
}
EnFleksilo proc prenuEstVerbon {persono nombro tempo} {
    # persono: 1 2 3
    # arto: ms ze ni
    # nombro: singularo pluralo
    # tempo: as os is u us ata oto ita anta onta inta

    switch $tempo {
        as {
            incr persono -1
            set listo {am are is are are are}
            if {$nombro eq "pluralo"} {
                incr persono 3
            }
            return [lindex $listo $persono]
        }
        is {
            incr persono -1
            set listo {was ware was ware ware ware}
            if {$nombro eq "pluralo"} {
                incr persono 3
            }
            return [lindex $listo $persono]
        }
        os {
            return "will be"
        }
        ont {
            return future
        }
        int {
            return formar
        }
        ant {
            return current
        }
        u {
            return be
        }
        us {
            return "would be"
        }
        i {
            return be
        }
        o {
            return being
        }
        ate {
            # TODO
            return being
        }
        ing {
            return being
        }
        defualt {
            error "{esti}"
        }
    }
}
EnFleksilo proc prenuFleksgrupojPorSubstantivo {} {
    return
}
EnFleksilo proc prenuFleksgrupojPorVerbo {} {
    return
}
EnFleksilo proc prenuHavVerbon {persono nombro tempo} {
    # persono: 1 2 3
    # arto: m f n
    # nombro: singularo pluralo
    # tempo: as os is u us ata oto ita anta onta inta

    switch $tempo {
        as {
            incr persono -1
            set listo {have have has have have have}
            if {$nombro eq "pluralo"} {
                incr persono 3
            }
            return [lindex $listo $persono]
        }
        defualt {
            error "{havi}"
        }
    }
}
EnFleksilo proc prenuKazojn {} {
    return {
        N nominativo
        A aktuzativo
    }
}
EnFleksilo proc prenuKompAdjektivo {bazo fgrupo {superlativo 0}} {
    if {$fgrupo eq ""} {
        # normale por vortoj kun pli ol unu silabo
        if {[string length $bazo]>5} {
            if {$superlativo} {
                return "most $bazo"
            } else {
                return "more $bazo"
            }
        } else {
            if {[string index $bazo end] eq "y"} {
                set bazo [string range $bazo 0 end-1]i
            }
            if {$superlativo} {
                return ${bazo}est
            } else {
                return ${bazo}er
            }
        }
    } else {
        my esceptoj2Arr $fgrupo arr
        if {$superlativo} {
            if {[info exists arr(sup)]} {
                return $arr(sup)
            } else {
                if {[info exists arr(komp)]} {
                    return $arr(komp)
                } else {
                    return ${bazo}st
                }
            }
        } else {
            if {[info exists arr(komp)]} {
                return $arr(komp)
            } else {
                return ${bazo}er
            }
        }
        
    }
}
EnFleksilo proc prenuKompleksanSubstantivonLauxTipo {bazaformo fleksGrupo nombro kazo} {
    if {$kazo eq "G"} {
        set add 's
    } else {
        set add ""
    }
    if {[llength $bazaformo]==1} {
        return [my prenuSubstantivonLauxTipo $bazaformo $fleksGrupo $nombro]$add
    } elseif {[llength $bazaformo]>2} {
        # ekz: Butik mit Nähbedarf
        # versxajne prepozicia suplemento
        join [concat [my prenuSubstantivonLauxTipo [lindex $bazaformo 0] $fleksGrupo $nombro]$add [lrange $bazaformo 1 end]]
    } else {
        # Versxajne adjektivo
        set adj [lindex $bazaformo 0]
        set sub [my prenuSubstantivonLauxTipo [lindex $bazaformo 1] $fleksGrupo $nombro]
        return "$adj $sub$add"
    }
}
EnFleksilo proc prenuNumero {numero {arto cxef}} {
    # cxef ordo subs opo
    if {[lsearch {cxef ordo subs opo} $arto]<0} {
        error "atendas 'cxef ordo subs opo' kiel arto. estis $arto"
    }
    my instvar cxefNumeraloj
    set rez [list]
    if {$numero==0} {
        return zero
    }
    set seplisto {1000000000000 trillion
                  1000000000    billion
                  1000000       million
                  1000          thousand}

    foreach {num 1vorto} $seplisto {
        if {$numero>=$num} {
            set mdlimo [expr {$num/1000}]
            set rnum [expr {round($numero/$num)}]
            if {$rnum==0} continue
            if {$rnum!=1} {
                foreach r [my prenuNumeroGis1000 $rnum] {
                    lappend rez $r
                }
            }
            lappend rez $1vorto,
            set numero [expr {$numero%$num}]
        }
    }
    if {$numero!=0} {
        foreach r [my prenuNumeroGis1000 $numero $arto] {
            lappend rez $r
        }
    }
    set r [join $rez " "]
    return $r
}
EnFleksilo proc prenuNumeroGis1000 {numero {arto cxef}} {
    my instvar cxefNumeraloj ordoNumeraloj
    set rez [list]
    set sparatilo 100
    set num [expr {$numero%$sparatilo}]
    if {$arto ne "ordo"} {
        set arto cxef
    }
    if {$num<20} {
        if {$num>0} {
            lappend rez [set ${arto}Numeraloj($num)]
        }
        set arto cxef
    } else {
        set j [expr {$num%10}]
        set d [expr {$num-$j}]
        if {$j>0} {
            if {$d>0} {
                if {$arto eq "ordo"} {
                    set arto cxef
                }
            }
            lappend rez [set ${arto}Numeraloj($j)]
            if {$d>0} {
                lappend rez -
            }
        }
        if {$d>0} {
            if {$arto ne "ordo"} {
                set arto cxef
            }
            set r $cxefNumeraloj($d)
            if {$arto eq "ordo"} {
                append r ste
            }
            lappend rez $r
        }
        set arto cxef
    }
    set 100num [expr {round($numero/100)*100}]
    if {$100num>=100} {
        lappend rez " " hundred " " [set ${arto}Numeraloj([expr {$100num/100}])]
    }
    set rrez [list]
    for {set i [expr {[llength $rez]-1}]} {$i>=0} {incr i -1} {
        append rrez [lindex $rez $i]
    }
    return $rrez
}
EnFleksilo proc prenuOnself {persono arto nombro} {
    if {$persono eq "3" && $nombro eq "singularo"} {
        switch -exact -- $arto {
            f {
                set refprep herself
            }
            m {
                set refprep himself
            }
            default {
                set refprep itself
            }
        }
    } elseif {$persono eq "4"} {
        return oneself
    } else {
        set s {myself yourself himself ourself yourself themself}
        if {$persono eq ""} {
            set persono 3
        }
        set i [expr {$persono-1}]
        if {$nombro eq "pluralo"} {
            incr i 3
        }
        set refprep [lindex $s $i]
    }
    return $refprep
}
EnFleksilo proc prenuPersonPronomon {bazaformo arto kazo nombro} {
    # kazo: N A
    my instvar pronomojArr
    set l $pronomojArr($bazaformo)
    if {$kazo eq "A"} {
        lindex $l end
    } else {
        lindex $l 0
    }
}
EnFleksilo proc prenuPosesivPronomon {bazaformo sekso kazo nombro {arto 0}} {
    my instvar posPronomojArr
    if {$bazaformo eq "tiu" && $nombro eq "pluralo"} {
        return those
    }
    return $posPronomojArr($bazaformo)
}
EnFleksilo proc prenuSubstantivoEsceptoj {} {
    return {
        pl {Pluarlo}
    }
}
EnFleksilo proc prenuSubstantivon {bazaformo nombro kazo} {
    my prenuKompleksanSubstantivonLauxTipo $bazaformo "" $nombro $kazo
}
EnFleksilo proc prenuSubstantivonLauxTipo {bazaformo fleksGrupoPri nombro} {

    if {$nombro eq "singularo"} {
        return $bazaformo
    }
    foreach e $fleksGrupoPri {
        foreach {k v} $e {}
        set esceptojArr($k) $v
    }
    if {[info exists esceptojArr(pl)]} {
        return $esceptojArr(pl)
    } else {
        if {[string index $bazaformo end] eq "s"} {
            return ${bazaformo}es
        } else {
            return ${bazaformo}s
        }
    }
}
EnFleksilo proc prenuVerboEsceptoj {} {
    return {
        past {Past - estinta tempo}
        perf {Perfekt - estinta tempo}
    }
}
EnFleksilo proc prenuVerbon {bazaformo fleksGrupoPri persono nombro tempo} {
    # persono: 1 2 3
    # arto: m f n
    # nombro: singularo pluralo
    # tempo: as os is u us ata oto ita anta onta inta
    # fleksGrupoPri (Priskribo)

    # Esceptoj

    if {$bazaformo eq "be"} {
        return [my prenuEstVerbon $persono $nombro $tempo]
    } elseif {$bazaformo eq "have" && $tempo eq "as"} {
        return [my prenuHavVerbon $persono $nombro $tempo]
    }
    foreach e $fleksGrupoPri {
        foreach {k v} $e {}
        set esceptojArr($k) $v
    }
    set bazo $bazaformo

    switch $tempo {
        as {
            if {$persono==3 && $nombro eq "singularo" && ![info exists esceptojArr(aux)]} {
                if {[string index $bazo end] eq "s" || [lsearch {do go} $bazo]>=0} {
                    set fino es
                } elseif {[string index $bazo end] eq "y"} {
                    set bazo [string range $bazo 0 end-1]
                    set fino ies
                } else  {
                    set fino s
                }
            } else {
                set fino ""
            }
        }
        is {
            if {[info exists esceptojArr(past)]} {
                return $esceptojArr(past)
            }
            if {[string index $bazo end] eq "e"} {
                return ${bazo}d
            } elseif {[string index $bazo end] eq "y"} {
                return [string range $bazo 0 end-1]ied
            } else {
                if {[my estasVovel [string index $bazo end]]} {
                    return ${bazo}ed
                }
                set vovelNombro 0
                foreach c [split $bazo ""] {
                    if {[my estasVovel $c]} {
                        incr vovelNombro
                    }
                    if {$vovelNombro>1} {
                        break
                    }
                }
                if {$vovelNombro==1 && [my estasVovel [string index $bazo end-1]]} {
                    return ${bazo}[string index $bazo end]ed
                } else {
                    return ${bazo}ed
                }
            }
        }
        pis {
            # perfekt
            if {[info exists esceptojArr(perf)]} {
                return $esceptojArr(perf)
            }
            if {[string index $bazo end] eq "e"} {
                return ${bazo}d
            } elseif {[string index $bazo end] eq "y"} {
                return [string range $bazo 0 end-1]ied
            } else {
                if {[my estasVovel [string index $bazo end]]} {
                    return ${bazo}ed
                }
                set vovelNombro 0
                foreach c [split $bazo ""] {
                    if {[my estasVovel $c]} {
                        incr vovelNombro
                    }
                    if {$vovelNombro>1} {
                        break
                    }
                }
                if {$vovelNombro==1 && [my estasVovel [string index $bazo end-1]]} {
                    return ${bazo}[string index $bazo end]ed
                } else {
                    return ${bazo}ed
                }
            }
        }
        os {
            return [concat will $bazaformo]
        }
        i {
            return $bazaformo
        }
        into -
        inta -
        int {
            return "former [my prenuVerbon $bazaformo $fleksGrupoPri $persono $nombro ant]"
        }
        anto -
        anta -
        ant {
            # writing
            return [my prenuVerbon $bazaformo $fleksGrupoPri {} {} ing]
        }
        onto -
        onta -
        ont {
            return "future [my prenuVerbon $bazaformo $fleksGrupoPri $persono $nombro ant]"
        }
        ito -
        ato -
        ita -
        ata -
        it -
        at {
            # robiony
            return [my prenuVerbon $bazaformo $fleksGrupoPri 1 singular pis]
        }
        ota -
        ot {
            return "future [my prenuVerbon $bazaformo $fleksGrupoPri $persono $nombro at]"
        }
        u {
            return $bazaformo
        }
        us {
            return "would $bazaformo"
        }
        inte -
        ite -
        ante -
        ate {
            return [my prenuVerbon $bazaformo {} {} {} ing]
        }
        o {
            return $bazaformo
        }
        ing {
            if {[string index $bazaformo end] eq "e"} {
                return [string range $bazaformo 0 end-1]ing
            } else {
                return ${bazaformo}ing
            }
        }
        default {
            error "nekonato tipo $tempo"
        }
    }
    if {[string index $bazo end] eq [string index $fino 0]} {
        return ${bazo}[string range $fino 1 end]
    } else {
        return ${bazo}$fino
    }
}
EnFleksilo proc tradukuOnes {bazaTraduko persono nombro arto} {
    if {[llength $bazaTraduko]>1} {
        if {[llength $bazaTraduko]==2 && [lindex $bazaTraduko 1] eq "oneself"} {
            if {$persono eq "3" && $nombro eq "singularo"} {
                switch -exact -- $arto {
                    f {
                        set refprep herself
                    }
                    m {
                        set refprep himself
                    }
                    default {
                        set refprep itself
                    }
                }
            } else {
                set s {myself yourself himself ourself yourself themself}
                set i [expr {$persono-1}]
                if {$nombro eq "pluralo"} {
                    incr i 3
                }
                set refprep [lindex $s $i]
            }
            set bazaTraduko [lreplace $bazaTraduko 1 1 $refprep]
        }
        if {[set oi [lsearch $bazaTraduko ones]]>=0 || [set oi [lsearch $bazaTraduko one's]]>=0} {
            if {$persono eq "3" && $nombro eq "singularo"} {
                switch -exact -- $arto {
                    f {
                        set prep her
                    }
                    m {
                        set prep his
                    }
                    default {
                        set prep its
                    }
                }
            } else {
                set s {my your his our your their}
                set i [expr {$persono-1}]
                if {$nombro eq "pluralo"} {
                    incr i 3
                }
                set prep [lindex $s $i]
            }
            set bazaTraduko [lreplace $bazaTraduko $oi $oi $prep]
        }
    }
    return $bazaTraduko
}
Object EnImportilo
@ ::EnImportilo idemeta component EspEnTradukilo
EnImportilo proc changxuFGrupoPorDerivo {fgrupo ekz tipo {gramatiko {}} {force 0}} {
    set connection [SQLDBVortaro getVortaroConnection]

    set sql "select t.id,fgrupo,t.gramatiko from traduko_en t,derivo d where traduko='$ekz' and t.derivoid=d.id and d.typo='$tipo'"
    set found 0
    foreach l [$connection queryList $sql] {
        set found 1
        set id [lindex $l 0]
        set fagrupo [lindex $l 1]
        set agramatiko [lindex $l 2]
        if {($fagrupo eq "" || $force) && $fgrupo ne "ignoru"} {
            puts "updating fgrupo $id - $ekz=$fgrupo"
            set qfgrupo [$connection escape $fgrupo]
            $connection execute "update traduko_en set fgrupo='$qfgrupo' where id=$id"
        }
        if {$gramatiko ne "" && ($agramatiko eq "" || $force)} {
            puts "updating gramtiko $ekz=$gramatiko"
            set qfgrupo [$connection escape $gramatiko]
            $connection execute "update traduko_en set gramatiko='$qfgrupo' where id=$id"
        }
    }
    if {$found == 0} {
        puts "$ekz estis ne trovita"
    }
}
EnImportilo proc foreachSQL {sql sargs script} {

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por substantivoj}]
    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]

    while {[llength [set row [$query fetch]]]>0} {
        update
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set ci 0
        foreach var $sargs val $row {
            uplevel [list set $var $val]
        }
        uplevel $script
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
EnImportilo proc importuApertiumVortaron {} {
    set dos /home/artur/programs/apertium/trunk/apertium-eo-en/apertium-eo-en.eo-en.dix

    set in [open $dos r]
    set out [open [file join [Esperantilozentro prenuFontoDosieron] en_fontoj apertium_eo_en.txt] w]

    # skip till <!-- Proper nouns --> section
    while {[gets $in line]>=0} {
        if {[string first "<!-- Proper nouns -->" $line]>=0} {
            puts "trovita proper nouns"
            break
        }
    }

    while {[gets $in line]>=0} {
        if {[regexp {<p><l>(.+?)</l>\s*<r>(.+?)</r></p>} $line _ eot ent]} {
            regsub -all {<s.+?/>} $eot {} eot
            regsub -all {<s.+?/>} $ent {} ent
            regsub -all {<b/>} $eot { } eot
            regsub -all {<b/>} $ent { } ent
            regsub -all -- {-} $eot {} eot
            puts $out "[string tolower $eot]; $ent"
        }
    }

    close $in
    close $out
}
EnImportilo proc importuKompAdjektivoj {} {
 set listo {alt älter
arg ärger
arm ärmer
dumm dümmer
grob gröber
gross grösser
hart härter
hoch höher
jung jünger
kalt kälter
klug klüger
krank kränker
kurz kürzer
lang länger
scharf schärfer
schwach schwächer
schwarz schwärzer
stark stärker
warm wärmer
}

    foreach {a komp} $listo {
        set fgrupo [list [list komp $komp]]
        my changxuFGrupoPorDerivo $fgrupo $a Adjektivo {} 1
        my changxuFGrupoPorDerivo $fgrupo $a Adverbo {} 1
    }
}
EnImportilo proc importuNeregulajnPluralojn {{file english-irregular-nouns.txt}} {
    set file [file join [my prenuFontoDozierujo] $file]
    if {![file exists $file]} {
        set f [IDE::Dialog getOpenFile]
    } else {
        set f $file
    }
    if {$f eq ""} return
    set fh [open $f r]
    fconfigure $fh -encoding utf-8
    while {[gets $fh line]!=-1} {
        foreach {baza pluralo} $line {}
        my changxuFGrupoPorDerivo [list [list pl $pluralo]] $baza Substantivo {} 0
    }
    close $fh
}
EnImportilo proc importuOronoDeListo {{file top10000en.txt}} {
    set file [file join [my prenuFontoDozierujo] $file]
    if {![file exists $file]} {
        set f [IDE::Dialog getOpenFile]
    } else {
        set f $file
    }
    if {$f eq ""} return
    set fh [open $f r]
    fconfigure $fh -encoding utf-8
    set listo [list]
    while {[gets $fh line]!=-1} {
        lappend listo $line
    }
    close $fh

    set sql "select d.id from derivo d,traduko_en t where d.id=t.derivoid group by d.id having count(t.id)>1"

    set progreso [ProgresoMontrilo startProgress {sercxi fgrupoj por verboj}]

    set connection [SQLDBVortaro getVortaroConnection]
    set query [$connection query $sql]
    set i 0
    set rows [$query rows]

    while {[llength [set row [$query fetch]]]>0} {
        update
        incr i
        if {$progreso ne ""} {
           $progreso setProgress [expr {round(100.0*$i/$rows)}]
           if {[$progreso isStopped]} {
               break
           }
        }
        set did [lindex $row 0]
        set isql "select traduko,id,ordo from traduko_en where derivoid=$did"
        set tradukoj [list]
        set minTraduko ""
        set minOrdo 10000
        set minId ""
        foreach r [$connection queryList $isql] {
            set traduko [lindex $r 0]
            set id [lindex $r 1]
            set ordono [lindex $r 2]
            if {$ordono ne ""} {
                puts "ordono jam metita $traduko"
                set minTraduko continue
                break
            }
            lappend tradukoj $traduko
            set ordo [lsearch $listo $traduko]
            if {$ordo>=0 && $ordo<$minOrdo} {
                set minOrdo $ordo
                set minTraduko $traduko
                set minId $id
            }
        }
        if {$minTraduko eq "continue"} {
            continue
        }
        if {$minTraduko ne ""} {
            puts "setting $traduko de [join $tradukoj ,]"
            $connection execute "update traduko_en set ordo=1 where id=$minId"
        } else {
            puts "ne estas en listo [join $tradukoj ,]"
        }
    }
    $query destroy
    if {$progreso ne ""} {
       $progreso cleanUpAfterSignal
       $progreso destroy
   }
}
EnImportilo proc importuStarkeVerbenDeListo {{file irregularverbs.txt}} {
    set file [file join [my prenuFontoDozierujo] $file]
    if {![file exists $file]} {
        set f [IDE::Dialog getOpenFile]
    } else {
        set f $file
    }
    if {$f eq ""} return
    set fh [open $f r]
    fconfigure $fh -encoding utf-8
    while {[gets $fh line]!=-1} {
        foreach {baza praeteritum perfekt} $line {}
        my changxuFGrupoPorDerivo [list [list past $praeteritum] [list perf $perfekt]] $baza Verbo {} 1
    }
    close $fh
}
EnImportilo proc prenuConnDeVortoj {} {
    my instvar deconnection
    if {![info exists deconnection]} {
        set tconnection [MySql new]
        $tconnection connect {user root dbank thesaurus}
        set deconnection $tconnection
    }
    return $deconnection
}
EnImportilo proc prenuFontoDozierujo {} {
    return {/home/artur/esperanto/en_fontoj}
}
EnImportilo proc sercxuDubindajTradukoj {} {
    set sql "select d.derivo,t.traduko from traduko_en t,derivo d where t.derivoid=d.id"
    set aspell [AspellTestilo prenuInstancoPorLingvo en]
    set rez ""
    my foreachSQL $sql {deVorto espVorto} {
        set tvortoj [list]
        foreach v [split $espVorto] {
            if {[string is alpha $v]} {
                lappend tvortoj $v
            }
        }
        if {[llength $tvortoj]>0} {
            if {[llength [$aspell testuVortoj $tvortoj]]>0} {
                puts "$deVorto; $espVorto"
                append rez "$deVorto; $espVorto\n"
            }
        }
    }
    IDE::ResultBrowser newBrowser $rez
}
EnImportilo proc sercxuPersSubstantivoj {} {
    set sql "select t.gramatiko,t.traduko from traduko_en t,derivo d where t.derivoid=d.id and d.typo='substantivo'"
    set list [list]

    my foreachSQL $sql {gramatiko traduko} {
        if {[lsearch $gramatiko pers]>=0} { continue }
        if {[string first ' $traduko]>=0} { continue }
        if {[string first \[ $traduko]>=0} { continue }
        if {[lsearch $list $traduko]>=0} { continue }
        set wntraduko [string map {{ } _ ' \\'} $traduko]
        set wn [send wnb "search $wntraduko 1 -2 1"]
        if {[string first "=> person" $wn]>0} {
            lappend gramatiko pers
            lappend list $traduko
            my changxuFGrupoPorDerivo ignoru $traduko substantivo $gramatiko 1
            # puts "changxuFGrupoPorDerivo ignoru $traduko substantivo $gramatiko 1"
        }
    }
}
Object EnVortFarado
@ ::EnVortFarado idemeta component EspEnTradukilo
EnVortFarado proc initializeAfterLoad {} {
    my instvar definoj
    set definoj [list]
    lappend definoj {(.+)e ${v}a ${t}ly}
    lappend definoj {ge(.+o) $v $t}
    lappend definoj {ne(.+a) $v {un$t}}
    lappend definoj {ne(.+o) $v {not $t}}
    lappend definoj {ne(.+i) $v {not $t}}
    lappend definoj {ne(.+e) $v {un$t}}
    lappend definoj {mal(.+) $v {$t the other way around}}
    lappend definoj {eks(.+o) $v eks-$t}
    lappend definoj {pra(.+o) $v pra-$t}
    lappend definoj {re(.+i) $v re$t}
    lappend definoj {(.+)o ${v}i $t}
    lappend definoj {(.+)a ${v}o $t}
}
EnVortFarado proc prenuVortfaradoj {espVorto dbvoraro} {
    my instvar definoj
    foreach def $definoj {
        if {[regexp ^[lindex $def 0]$ $espVorto _ v]} {
            set v [subst [lindex $def 1]]
            set rezListo [$dbvoraro sxercxuRezListo $v en]
            if {[llength $rezListo]==0} continue
            set rez [list]
            foreach rd $rezListo {
                set t [dict get $rd traduko]
                set g [dict get $rd fgrupo]
                set r [subst [lindex $def 2]]
                if {[llength $def]>2} {
                    eval [lindex $def 3]
                    dict set rd fgrupo $g
                }
                dict set rd traduko $r
                lappend rez $rd
            }
            return $rez
        }
    }
    set vortaro [Vortaro prenuVortaron]
    # laborkampo/laborokampo - work place
    if {[string index $espVorto end] eq "o" && ([set r [$vortaro estasVorto $espVorto]]==2 || $r==1) && [$vortaro set pradiko] ne ""} {
        set cxeno [$vortaro prenuMorfcxeno]
        if {[llength $cxeno]==3} {
            set rez [list]
            set pre [lindex $cxeno 0]
            if {[string index $pre end] ne "o"} {
                append pre o
            }
            set prezListo [$dbvoraro sxercxuRezListo $pre en]
            foreach rp $prezListo {
                set rezListo [$dbvoraro sxercxuRezListo [lindex $cxeno 1][lindex $cxeno 2] en]
                foreach rd $rezListo {
                    dict set rd traduko "[dict get $rp traduko] [dict get $rd traduko]"
                    lappend rez $rd
                }
            }
            if {[llength $rez]>0} {
                return $rez
            }
        }
    }
    return
}
EnVortFarado proc prenuVortfaradoj2 espVorto {
    my prenuVortfaradoj $espVorto [DBVortaro prenuDepVortaron]
}
EnFleksilo initializeAfterLoad
EnVortFarado initializeAfterLoad

